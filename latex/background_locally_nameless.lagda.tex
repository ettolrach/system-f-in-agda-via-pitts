
\subsection{De Bruijn indices}
\label{section:background_debruijn}
Consider this expression,
\begin{equation*}
  x \colon \nat \in \Gamma \vdash (\lambda \, y \colon \nat \to \nat. y x) \colon \nat.
\end{equation*}

Suppose we move this expression into a context where $y$ is already defined,
\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash (\lambda \, y \colon \nat \to \nat. y x) \colon \nat.
\end{equation*}

It's unclear whether we are referring to the bound $y$ or the free $y$. One way to resolve this is
to always choose the most recently declared variable. This is called \textit{shadowing}, since the
older definitions are `in the shadow of' the most recent occurence \citep{wadler_programming_2022}.
Another approach is to use an $\alpha$-conversion. Here we can apply $y \mapsto_{\alpha} f$ to the
$\lambda$-abstraction,
\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash (\lambda \, f. f x) \colon \nat,
\end{equation*}
which solves the problem. We can add further assumptions to our context without affecting the
semantics of the expression \citep{pitts_locally_2023} (for example, adding $k \colon \nat$ to
$\Gamma$ doesn't cause any name conflicts). I shall call this property weakening-invariance (taken
from proof theory, where extra assumptions make a theorem weaker \citep{buss_handbook_1998}).

Since we have these $\alpha$-equivalent expressions, we can say that we have \textit{quotient}
inductive definitions \citep{aydemir_engineering_2008}; we have both an inductive definition of the
$\lambda$-calculus, but also (infinitely) many $\alpha$-equivalence classes which induce a quotient
set. In some proof assistants, this makes proofs difficult, as they don't handle quotient
definitions well \citep{pitts_locally_2023}.

We can solve this by using \textit{De Bruijn indices}, which ensure variables in the context don't
cause name conflicts and accidental shadowing with bound variables. In fact, $\alpha$-conversions
cannot be performed anymore. In our example,
\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash (\lambda \, 0 2) \colon \nat.
\end{equation*}

However, if the context changes, the indices would need to change too. For example, if we remove the
$y$, then we need to reindex the $2$ to a $1$:
\begin{equation*}
  x \colon \nat \in \Gamma \vdash (\lambda \, 0 1) \colon \nat,
\end{equation*}
We have lost weakening-invariance \citep{aydemir_engineering_2008}. This leaves a demand for a
syntax which solves both the issue of quotient definitions and weakening-invariance.

\subsection{Locally Nameless Representation}
\label{section:background_locally_nameless}
Using \textit{locally nameless representation}, we can get both purely inductive definitions
\textit{and} weakening-invariance. Free variables use variable names while bound variables use
indices. Our example becomes
\begin{equation*}
  x \colon \nat, \in \Gamma \vdash (\lambda \, 0 x) \colon \nat,
\end{equation*}
or with another variable in the context,
\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash (\lambda \, 0 x) \colon \nat.
\end{equation*}

As part of using locally nameless terms, common operations and properties (called `infrastructure'
by \citet{aydemir_engineering_2008}) need to be defined for the target language. A recent article by
Andrew \citet{pitts_locally_2023} uses Agda to explore an abstraction of this representation called
locally nameless sets, and shows that this infrastructure can be defined in a syntax-agnostic way.

The drawback of using this representation is that we need to define infrastructure and prove some
properties of the syntax before we can prove the properties of the metalangauge. But usually, this
drawback is too small to outweight the benefits.

\paragraph*{Opening and closing.} Two fundamental operations on locally nameless terms are
\textit{term opening} and \textit{term closing} \citep{pitts_locally_2023}. Opening will replace all
occurrences of a bound variable with a free variable, written $[i \to x] L$ for some De Bruijn
index $i$, name $x$, and term $L$. For example,
\begin{equation*}
  [0 \to y] (0 q (\lambda \, 1 t 0)) \quad \mapsto \quad y q (\lambda \, y t 0).
\end{equation*}
Every occurence of the bound variable $0$ is replaced with the free variable $y$. Note how after we
go under a new $\lambda$-abstraction, we have to increment this index to $1$ to keep referring to
the same bound variable.

Closing works similarly, and is the inverse of opening; it replaces all occurrences of a free
variable with a given index. For example,
\begin{equation*}
  [0 \leftarrow y] (y q (\lambda \, y t 0)) \quad \mapsto \quad 0 q (\lambda \, 1 t 0).
\end{equation*}

\paragraph*{Local closure.} A term is said to be \textit{locally closed} up to level $i$ if it
remains unchanged after opening it at index $i$ with an arbitrary string. For some $i \in \nat$ and
term $L$, we write that $L$ is locally closed at level $i$ as $i \succ L$. Formally,
\begin{equation}
  \label{equation:local_closure}
  i \succ L \triangleq \forall j \geq i, \; \cof a , \; [j \to a] L = L.
\end{equation}
If it is locally closed at level $0$, we simply call it \textit{locally closed}. Local closure is
defined for System F in section \ref{chapter3:local_closure}.

As detailed in \citet{aydemir_engineering_2008}, local closure can be defined using universal
quantification instead. For example, equation (\ref{equation:local_closure}) could read $\forall a
\notin \fv(L), \; [j \to a] L = L$ (where $\text{fv} \colon \text{Terms} \to \text{Identifiers}$
returns all identifiers of free variables). The benefit of using cofinite quantification comes when
we use quantified properties in assumptions of theorems.

For example, suppose we have two properties $P$ and $Q$ of a term $L$, each of which hold for all
fresh identifiers, and we wish to prove that there exists some identifier $z$ for which both
properties hold,
\begin{equation*}
  \forall x, y \notin \fv(L), \; P(L, x) \wedge Q(L, y)
    \implies \exists z \; \text{such that} \; P(L, z) \wedge Q(L, z).
\end{equation*}

Since there are only a finite number of free variables in a term, we can always find a fresh
identifier. Informally, the proof is trivial since we can choose a fresh identifier such that $z = x
= y$.

Proof-assistants like Agda model universal quantification as an argument to a function. In this
example, $x$ and $y$ would be arguments of type Identifier. These are arbitrary, as in, we cannot
make any assumptions on these arguments other than their type
\citep[chapter~Quantifier]{wadler_programming_2022}. We would additionally be given evidence that $x
\notin \fv(L)$ and that $P(L, x)$ holds, and that $y \notin \fv(L)$ and that $Q(L, x)$ holds.
Importantly, unlike the informal proof, we cannot set $x = y$.

To solve this, we can use cofinite quantification. By writing
\begin{equation*}
  \cof x, y, \; P(L, x) \wedge Q(L, y)
  \implies \exists z \; \text{such that} \; P(L, z) \wedge Q(L, z),
\end{equation*}
Agda will now give us a proof that for any $x \notin S_1$ and $y \notin S_2$ for some sets $S_1$ and
$S_2$, the properties $P(L, x)$ and $Q(L, y)$ hold. We now choose a $z \notin S_1 \cup
S_2$ (note that as both $S_1$ and $S_2$ are by definition finite, this doesn't require the
axiom of choice). This $z$ will satisfy $P(L, z)$ since $z \notin S_1$ and it will also satisfy
$Q(L, z)$ since $z \notin S_2$.

This technique of combining several different `disallowed' sets will be used in chapter
\ref{chapter3} for theorems such as \texttt{rename}.
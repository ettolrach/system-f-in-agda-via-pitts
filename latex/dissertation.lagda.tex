% UG project example file, February 2024
%
%   Added the "online" option for equal margins, February 2024 [Hiroshi Shimodaira, Iain Murray]
%   A minor change in citation, September 2023 [Hiroshi Shimodaira]
%
% Do not change the first two lines of code, except you may delete "logo," if causing problems.
% Understand any problems and seek approval before assuming it's ok to remove ugcheck.
\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


% Include any packages you need below, but don't include any that change the page
% layout or style of the dissertation. By including the ugcheck package above,
% you should catch most accidental changes of page layout though.

\usepackage{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

% === Custom packages === %

% Syntax highlighting
\usepackage{minted}
% BNF
\usepackage{simplebnf}
% Inference rules
\usepackage{mathpartir}
% Agda
\usepackage{agda}
\AgdaNoSpaceAroundCode{}
% Hide in output
\usepackage{comment}
% Colour
\usepackage{xcolor}

% Unicode

\usepackage{fontspec}
\usepackage{newunicodechar}
\newfontface{\notosansmono}{NotoSansMono-Regular.ttf}[Path = fonts/]
\newfontface{\ibmplexmath}{IBMPlexMath-Regular.otf}[Path = fonts/]
\newfontface{\hack}{HackNerdFontMono-Regular.ttf}[Path = fonts/]
\newunicodechar{ℕ}{{\notosansmono{ℕ}}}
\newunicodechar{∀}{{\notosansmono{∀}}}
\newunicodechar{≡}{{\notosansmono{≡}}}
\newunicodechar{≥}{{\notosansmono{≥}}}
\newunicodechar{≤}{{\notosansmono{≤}}}
\newunicodechar{≰}{{\notosansmono{≰}}}
\newunicodechar{⊔}{{\notosansmono{⊔}}}
\newunicodechar{≟}{{\notosansmono{≟}}}
\newunicodechar{⇒}{{\hack{⇒}}}
\newunicodechar{≢}{{\notosansmono{≢}}}
\newunicodechar{≮}{{\notosansmono{≮}}}
\newunicodechar{⟪}{{\notosansmono{⟪}}}
\newunicodechar{⟫}{{\notosansmono{⟫}}}
\newunicodechar{⊤}{{\notosansmono{⊤}}}
\newunicodechar{⊥}{{\notosansmono{⊥}}}
\newunicodechar{∣}{{\notosansmono{∣}}}
\newunicodechar{⟨}{{\notosansmono{⟨}}}
\newunicodechar{⟩}{{\notosansmono{⟩}}}
\newunicodechar{∎}{{\notosansmono{∎}}}
\newunicodechar{⌊}{{\notosansmono{⌊}}}
\newunicodechar{⌋}{{\notosansmono{⌋}}}
\newunicodechar{₁}{{\notosansmono{₁}}}
\newunicodechar{₂}{{\notosansmono{₂}}}
\newunicodechar{∃}{{\notosansmono{∃}}}
\newunicodechar{∷}{{\notosansmono{∷}}}
\newunicodechar{∈}{{\notosansmono{∈}}}
\newunicodechar{∉}{{\notosansmono{∉}}}
\newunicodechar{λ}{{\notosansmono{λ}}}
\newunicodechar{И}{{\notosansmono{И}}}
\newunicodechar{∘}{{\notosansmono{∘}}}
\newunicodechar{≠}{{\notosansmono{≠}}}
\newunicodechar{‵}{{\notosansmono{‵}}}
\newunicodechar{ƛ}{{\notosansmono{ƛ}}}
\newunicodechar{≻}{{\ibmplexmath{≻}}}
\newunicodechar{⦃}{{\ibmplexmath{⦃}}}
\newunicodechar{⦄}{{\ibmplexmath{⦄}}}
\newunicodechar{′}{{\notosansmono{′}}}
\newunicodechar{∋}{{\notosansmono{∋}}}
\newunicodechar{⦂}{{\ibmplexmath{⦂}}}
\newunicodechar{∅}{{\hack{∅}}}
\newunicodechar{⊢}{{\hack{⊢}}}
\newunicodechar{ξ}{{\notosansmono{ξ}}}
\newunicodechar{β}{{\notosansmono{β}}}
\newunicodechar{↠}{{\hack{↠}}}
\newunicodechar{ρ}{{\notosansmono{ρ}}}

% Maths:

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{xurl}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Real}{Re}
\DeclareMathOperator{\Imag}{Im}
\DeclareMathOperator{\complex}{\mathbb{C}}
\DeclareMathOperator{\reals}{\mathbb{R}}
\DeclareMathOperator{\nat}{\mathbb{N}}
\DeclareMathOperator{\integer}{\mathbb{Z}}
\DeclareMathOperator{\rational}{\mathbb{Q}}
\DeclareMathOperator{\Log}{Log}
\DeclareMathOperator{\Arg}{Arg}
\DeclareMathOperator{\cof}{\text{И}}

% Use minted for Agda

\let\oldcode\code
\NewCommandCopy{\mintedcopy}{\minted}
\NewCommandCopy{\endmintedcopy}{\endminted}
% Adapted from https://tex.stackexchange.com/a/488451/202867
\renewenvironment{code}{\mintedcopy[breaklines,breaksymbolleft=\;]{agda}}{\endmintedcopy}

\begin{document}
\begin{preliminary}

\title{System F in Agda via Pitts}

\author{Charlotte Ausel}

% CHOOSE YOUR DEGREE a):
% please leave just one of the following un-commented
% \course{Artificial Intelligence}
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Software Engineering}
%\course{Cognitive Science}
%\course{Computer Science}
%\course{Computer Science and Management Science}
\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}
%\course{Software Engineering}
%\course{Master of Informatics} % MInf students

% CHOOSE YOUR DEGREE b):
% please leave just one of the following un-commented
%\project{MInf Project (Part 1) Report}  % 4th year MInf students
%\project{MInf Project (Part 2) Report}  % 5th year MInf students
\project{4th Year Project Report}        % all other UG4 students


\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

TODO.

This document is a literate Agda file and uses {\color{violet}colour}. Please see appendix
\ref{appendix:compilation_instructions} for details.

\begin{code}
module dissertation where
\end{code}

\chapter{Background}

\section{Agda}
Agda is a dependently-typed functional programming language based on Martin--Löf type theory, which
makes it suitable as a proof-assistant using intuitionistic logic \citep{norell_towards_2007}.

In Agda, most definitions are done inductively, that is, using recursion. For example, following the
Peano axioms for the natural numbers $\nat$ \citep{boolos_freges_1995}, we may define them like so.

\begin{code}
module Example where
  data ℕ : Set where
    zero : ℕ
    suc  : ℕ → ℕ
\end{code}


\paragraph*{Propositions as types.} First noted by William A. Howard in 1969
\citep{howard_formulae-as-types_1980}, there is a direct correspondence between proofs and programs.
\citet{wadler_propositions_2015} calls this correspondence \textit{propositions as types}, known as
the Curry-Howard correspondence by some authors. Thanks to this correspondence, a correct Agda
function with the appropriate type signature matching the claim (proposition) suffices for a proof.
For example, a proof that addition is associative would use recursion, which corresponds to
induction, as shown below.

\begin{code}
  -- We can import from the standard library, here we're using
  -- the reflexive and congruence properties of equality.
  open import Relation.Binary.PropositionalEquality
    using (_≡_; refl; cong)

  _+_ : ℕ → ℕ → ℕ
  zero  + m = m
  suc n + m = suc (n + m)

  +-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
  +-assoc zero    n p = refl
  +-assoc (suc m) n p = cong suc (+-assoc m n p)
\end{code}

Imports from the standard library \citep{the_agda_community_agda_2024} are omitted, but are
available in the full source file (see appendix \ref{appendix:compilation_instructions}).
\begin{comment}
\begin{code}
-- Data types (naturals, strings, characters)
open import Data.Nat using (ℕ; zero; suc; _<_; _≥_; _≤_; _≤?_; _<?_; z≤n; s≤s; _⊔_)
  renaming (_≟_ to _≟ℕ_)
open import Data.Nat.Properties using (≤-refl; ≤-trans; ≤-<-trans; <-≤-trans; ≤-antisym; ≤-total;
  +-mono-≤; n≤1+n; m≤n⇒m≤1+n; suc-injective; <⇒≢; ≰⇒>; ≮⇒≥)
open import Data.String using (String; fromList; toList) renaming (_≟_ to _≟str_;
  _++_ to _++str_; length to str-length)
open import Data.Char using (Char)
open import Data.Char.Properties using () renaming (_≟_ to _≟char_)

-- Function manipulation.
open import Function using (_∘_; flip; it; id; case_returning_of_)

-- Relations and predicates/decidability.
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; sym; trans; cong; cong-app; cong₂)
open Eq.≡-Reasoning using (begin_; step-≡-∣; step-≡-⟩; _∎)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Nullary.Decidable using (Dec; yes; no; True; False; toWitnessFalse;
  toWitness; fromWitness; ¬?; ⌊_⌋; From-yes)
open import Relation.Unary using (Decidable)
open import Relation.Binary using () renaming (Decidable to BinaryDecidable)
open import Relation.Nullary.Negation using (¬_; contradiction)
open import Data.Empty using (⊥-elim)

-- Products and exists quantifier.
open import Data.Product using (_×_; proj₁; proj₂; ∃-syntax) renaming (_,_ to ⟨_,_⟩)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])

-- Lists.
open import Data.List using (List; []; _∷_; _++_; length; filter; map; foldr; head; replicate)
open import Data.List.Properties using (≡-dec)
import Data.List.Membership.DecPropositional as DecPropMembership
open import Data.List.Relation.Unary.All using (All; all?; lookup)
  renaming (fromList to All-fromList; toList to All-toList)
open import Data.List.Relation.Unary.Any using (Any; here; there)
open import Data.List.Extrema Data.Nat.Properties.≤-totalOrder using (max; xs≤max)

-- Import list membership using List Char comparisons.
_≟lchar_ : ∀ (xs ys : List Char) → Dec (xs ≡ ys)
xs ≟lchar ys = ≡-dec (_≟char_) xs ys

open DecPropMembership _≟lchar_ using (_∈_; _∉_; _∈?_)
\end{code}
\end{comment}

\section{Cofinite Quantification}

\input{cofinite.lagda}

\section{The Lambda Calculus and System F}
\input{background_lambda_calculus.tex}

\section{Evaluation strategy}
\label{background:evaluation_strategy}
\input{background_evaluation_strategy.tex}

\section{Locally Nameless Representation}
\input{background_locally_nameless.tex}

\section{Prior research}
System F was previously formalised in Agda by \citet{hutton_system_2019}. However, the authors
formalised a variant of System F with language extensions known as \textit{System F$_{\omega \mu}$}.
They also used a different approach, opting to make use of De Bruijn indices only. This paper will
use the locally nameless representation, which hasn't been used for System F in Agda before.

I have previously submitted some work on STLC using locally nameless representation for a course
called \textit{Types and Semantics of Programming Languages} (TSPL). I have presented my prior work
in appendix \ref{appendix:tspl}. There are some new additions to this work which are presented in
the next chapter.

\chapter{Substitution and Evaluation in STLC}
\label{chapter3:stlc_sub_and_eval}
The remaining properties of STLC which were not proven in \ref{appendix:tspl} include some
substitution properties and creating an evaluator. Since it is a necessary prelude to System F, this
new work is presented here. As explained in section \ref{background:evaluation_strategy}, one
evaluation strategy is weak-head reduction, which is also used by
\citet[chapter~Properties]{wadler_programming_2022} and \citet[section~5]{chargueraud_locally_2012}.
Thus, evaluation will be restricted to closed terms only (those without free variables).
\begin{code}
module chapter3 where
  open import plfa_adaptions
  open import tspl_prior_work
  open import cofinite
\end{code}

To avoid name conflicts with Agda's reserved keywords, the syntax of the metalangauge is different
to how it may be commonly written. We will use substitutes, like ƛ for $\lambda$, or $\cdot$ for
function application (which is usually left implicit).

\section{Substitution Preserves Types}
A good example of the induction principle for cofinite quantification is the following proof, that
all well-typed expressions are locally closed using induction on the type judgement.

\begin{code}
  ⊢⇒lc : ∀ {Γ t A} → Γ ⊢ t ⦂ A → LocallyClosed t
  ⊢⇒lc {Γ} {t} {A} (⊢free Γ∋A) = free-lc
  ⊢⇒lc {Γ} {ƛ t} {A} (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) j =
    И⟨ Иe₁ , (λ a {a∉} → cong ƛ_
      (open-rec-lc-lemma
        (λ ())
        (open-rec-lc (⊢⇒lc (Иe₂ a {a∉}))))) ⟩
  ⊢⇒lc {Γ} {t₁ · t₂} (⊢· ⊢A⇒B ⊢A) _ =
    И⟨ domain Γ , (λ _ → cong₂ _·_
      (open-rec-lc (⊢⇒lc ⊢A⇒B)) (open-rec-lc (⊢⇒lc ⊢A))) ⟩
  ⊢⇒lc {Γ} {‵zero} ⊢zero = ‵zero-≻
  ⊢⇒lc {Γ} {‵suc t} (⊢suc ⊢t) j =
    И⟨ domain Γ , (λ a {a∉} →
      cong ‵suc_ (open-rec-lc (⊢⇒lc ⊢t))) ⟩
\end{code}

Recall the definition of local closure (see equation \ref{equation:local_closure}). In Agda,
\begin{minted}{agda}
  _≻_ : ℕ → Term → Set
  i ≻ t = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , ([ j —→ a ] t ≡ t)
\end{minted}
Given a $j \in \nat$, we need to show that for cofinite $a$, opening $t$ with $[j \to a]$ will leave
$t$ unchanged. This is why each case includes the extra \texttt{j} argument.

For all except the $\lambda$-abstraction case, the inductive hypothesis is straight-forward. For
$\lambda$-abstractions, we are given a list \texttt{Иe₁} and a property \texttt{Иe₂} which states
that $(\Gamma , \, x \colon A \vdash [0 \to x] t \colon B)$ for some \texttt{List Char} $x \not \in
\texttt{Иe₁}$. We need to provide a proof that $\lambda \, t$ is locally closed. By including the
argument \texttt{j}, we now only need to show that $\cof a, \; (\lambda \, ([j + 1 \to a] t) =
\lambda \, t)$. The inductive hypothesis allows us to call \texttt{⊢⇒lc} on \texttt{Иe₂}, or in
other words, it implies that for cofinite $a$, the term $[0 \to a] t$ is locally closed. After
applying the inductive hypothesis, the proof is a consequence of a previous lemma
\texttt{open-rec-lc} which was proven in appendix \ref{appendix:tspl}.

Now we need show that substituting preserves types. As mentioned, we restrict ourselves to only
closed terms for substitution.
\begin{code}
  {-# TERMINATING #-}
  subst : ∀ {Γ x t u A B}
    → ∅ ⊢ u ⦂ A
    → Γ , x ⦂ A ⊢ t ⦂ B
      --------------------
    → Γ ⊢ [ x := u ] t ⦂ B
  subst {x = y} ⊢u (⊢free {x = x} (H refl)) with y ≟lchar y
  ... | yes _   = weaken ⊢u
  ... | no  y≢y = contradiction refl y≢y
  subst {x = y} ⊢u (⊢free {x = x} (T x≢y ∋x)) with y ≟lchar x
  ... | yes y≡x = contradiction (sym y≡x) x≢y
  ... | no  _   = ⊢free ∋x
  subst {x = x} {t = ƛ t} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢ƛ И⟨ x ∷ Иe₁
        , (λ a {a∉} →
          let a≢y   = ∉∷[]⇒≢ (proj₁ (∉-++ a∉))
              a∉Иe₁ = proj₂ (∉-++ a∉)
          in subst-open-context
            {t = t}
            (sym-≢ a≢y)
            (⊢⇒lc ⊢u)
            (subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))) )
        ⟩
  subst ⊢u (⊢· ⊢t₁ ⊢t₂) = ⊢· (subst ⊢u ⊢t₁) (subst ⊢u ⊢t₂)
  subst ⊢u ⊢zero = ⊢zero
  subst ⊢u (⊢suc ⊢t) = ⊢suc (subst ⊢u ⊢t)
\end{code}

The property is proven by induction on the type judgement of the term \texttt{M}. Agda cannot
determine the termination of this function, and the problematic call is when the type judgement is a
$\lambda$-abstraction \texttt{ƛ M}. Specifically, it highlights the problematic code to be
\texttt{subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))}. Thus, I will only detail that
step\footnote{Technically, the Agda compiler also highlits a problematic call for the application
case, but this is caused by the problematic $\lambda$-abstraction case, so is irrelevant.}.

Since we are inducting on the type judgement, the inductive hypothesis for a term \texttt{ƛ M} of
type \texttt{A ⇒ A'} states that the property $P$ holds for $P(\texttt{И⟨ Иe₁ , Иe₂ ⟩})$. Let
\texttt{b} be an appropriate \texttt{List Char} to supply to \texttt{Иe₂}, then it will return a
proof that \texttt{Γ , x ⦂ A , b ⦂ A' ⊢ [ 0 —→ b ] t ⦂ B}. In this case, the \texttt{subst} function
is called on \texttt{Иe₂} (with a \texttt{swap} function applied, but since this function doesn't
call \texttt{subst} and only operates on the context, this call is irrelevant to this termination
issue). Since we are deconstructing the type judgement and are calling \texttt{subst} on the term
\texttt{Иe₂} which makes up the input type judgement, this function call corresponds to the
inductive hypothesis, and is thus valid.

Substituting a term for an index is similar to the definition of the free-variable substitution
(defined in appendix \ref{appendix:substitution_proofs}). This is, confusingly, also called
`opening' by \citet{chargueraud_locally_2012}.
\begin{code}
  [_:→_]_ : ℕ → Term → Term → Term
  [ k :→ u ] (free x) = free x
  [ k :→ u ] (bound i) with k ≟ℕ i
  ... | yes _ = u
  ... | no  _ = bound i
  [ k :→ u ] (ƛ t) = ƛ [ (suc k) :→ u ] t
  [ k :→ u ] (t₁ · t₂) = [ k :→ u ] t₁ · [ k :→ u ] t₂
  [ k :→ u ] ‵zero = ‵zero
  [ k :→ u ] (‵suc t) = ‵suc ([ k :→ u ] t)
\end{code}

Using an index $i$ to open with $x \in \texttt{List Char}$ is the same as using the index
substitution with the term \texttt{free $x$}.
% Unused.
\begin{code}
  —→≡:→free : ∀ {i : ℕ} {x : List Char} (t : Term)
    → [ i —→ x ] t ≡ [ i :→ free x ] t
  —→≡:→free {i} {x} (free y) = refl
  —→≡:→free {i} {x} (bound k) with i ≟ℕ k
  ... | yes _ = refl
  ... | no  _ = refl
  —→≡:→free {i} {x} (ƛ t) = cong ƛ_ (—→≡:→free t)
  —→≡:→free {i} {x} (t₁ · t₂) =
    cong₂ _·_ (—→≡:→free t₁) (—→≡:→free t₂)
  —→≡:→free {i} {x} ‵zero = refl
  —→≡:→free {i} {x} (‵suc t) = cong ‵suc_ (—→≡:→free t)
\end{code}

There are quite a few more properties of index substitution which \citet{chargueraud_locally_2012}
proves, but the only relevant one for evaluation is \texttt{subst-intro}. It proves that
substituting a term for an index is the same as first opening the term with an $x \in \texttt{List
Char}$ and then using the free variable substitution using this $x$.
\begin{code}
  subst-intro : ∀ {x : List Char} {i : ℕ} (t u : Term)
    → x # t
    → [ i :→ u ] t ≡ [ x := u ] ([ i —→ x ] t)
  subst-intro {x} (free y) u x#t with x ≟lchar y
  ... | yes refl with () ← x#t
  ... | no  x≢y  = refl
  subst-intro {x} {i} (bound j) u x#t with i ≟ℕ j
  ... | no  i≢j  = refl
  ... | yes refl with x ≟lchar x
  ...   | yes refl = refl
  ...   | no  x≢x  = contradiction refl x≢x
  subst-intro (ƛ t) u x#ƛt = cong ƛ_ (subst-intro t u (#-ƛ t x#ƛt))
  subst-intro {x} (t₁ · t₂) u x#t =
    let ⟨ x#t₁ , x#t₂ ⟩ = #-· t₁ t₂ x#t in
      cong₂ _·_ (subst-intro t₁ u x#t₁) (subst-intro t₂ u x#t₂)
  subst-intro ‵zero u x#t = refl
  subst-intro (‵suc t) u x#st =
    cong ‵suc_ (subst-intro t u (#-‵suc t x#st))
\end{code}

Since we need to replace bound variables for free ones to perform a $\beta$-reduction, we should
prove that this substitution preserves types.
\begin{code}
  subst-op : ∀ {Γ t u A B}
    → ∅ ⊢ u ⦂ A
    → Γ ⊢ ƛ t ⦂ A ⇒ B
      --------------------
    → Γ ⊢ [ 0 :→ u ] t ⦂ B
  subst-op {t = t} {u = u} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
    let x                  = fresh (fv t ++ Иe₁)
        ⟨ x∉fv-t , x∉Иe₁ ⟩ = ∉-++ {xs = fv t} {ys = Иe₁}
                                (fresh-correct (fv t ++ Иe₁))
    in ≡-with-⊢ (subst ⊢u (Иe₂ x {x∉Иe₁}))
      (sym (subst-intro t u (∉fv⇒# x t (x∉fv-t))))
\end{code}

\section{Substitution Commutes}
Here we prove a property which...

None of these functions are necessary for evaluation, so we can postulate function extensionality,
that is, for some sets $A$ and $B$ and functions $f, g \colon A \to B$, 
\begin{equation*}
  (\forall x \in A, \, f(x) = g(x)) \implies f = g.
\end{equation*}

This is the 4\textsuperscript{th} axiom in the elementary
theory of the category of sets \citep{tom_leinster_rethinking_2014}. It's known that this does not
cause an inconsistency in Agda's system of logic \citep{wadler_programming_2022}, however, since it
needs to be postulated, we cannot call this function. So, we leave it only defined in this module.

\begin{code}
  -- module substitution_commutes where
  --   private postulate
  --     extensionality : ∀ {A B : Set} {f g : A → B}
  --       → (∀ (x : A) → f x ≡ g x)
  --         -----------------------
  --       → f ≡ g

  --   free-inferred : ∀ {x : List Char} → Term
  --   free-inferred {x} = free x

  --   ctx-weaken : ∀ {Γ x y A B} → x ≢ y → Γ , y ⦂ B ∋ x ⦂ A → Γ ∋ x ⦂ A
  --   ctx-weaken x≢y (H refl) = contradiction refl x≢y
  --   ctx-weaken x≢y (T _ ∋x) = ∋x

  --   exts : ∀ {Γ Δ x y A B}
  --     → (Γ ∋ x ⦂ A        → ∃[ L ]        (Δ ⊢ L ⦂ A))
  --       ------------------------------------------------------------
  --     → (Γ , y ⦂ B ∋ x ⦂ A → ∃[ L ] (Δ , y ⦂ B ⊢ L ⦂ A))
  --   exts σ (H refl) = ⟨ free-inferred , (⊢free (H refl)) ⟩
  --   exts σ (T x≢y x) = ⟨ proj₁ (σ x) , rename (T {!!}) (proj₂ (σ x)) ⟩

    -- subst : ∀ {Γ Δ}
    --   → (∀ {x A} → Γ ∋ x ⦂ A → Δ ⊢ A)
    --     -----------------------
    --   → (∀ {x A} → Γ ⊢ A → Δ ⊢ A)
    -- subst σ (` x)          =  σ x
\end{code}

\section{Evaluation}
Using weak-head reduction, only $\lambda$-abstractions are values, together with the two primitives
that were introduced.
\begin{code}
  data Value : Term → Set where
    V-ƛ : ∀ {t} → Value (ƛ t)
    V-zero : Value ‵zero
    V-suc : ∀ {t} → Value t → Value (‵suc t)
\end{code}

\citet{chargueraud_locally_2012} adds another requirement for $\lambda$-abstractions: $1 \succ M$,
or in other words, that $\lambda M$ is locally closed. However, since we are only evaluating
well-typed terms, and all well-typed terms are locally closed (see section
\ref{appendix:type_judgements}), this requirement isn't necessary here.

We follow the rules for small-step reduction given in \citet{chargueraud_locally_2012}. These are
encoded in Agda below.
\begin{code}
  infix 4 _—→_
  data _—→_ : Term → Term → Set where
    ξ₁ : ∀ {t₁ t₁' t₂}
      → t₁ —→ t₁'
      → LocallyClosed t₂
        -------------------
      → t₁ · t₂ —→ t₁' · t₂

    ξ₂ : ∀ {t₁ t₂ t₂'}
      → t₂ —→ t₂'
        ---------
      → t₁ · t₂ —→ t₁ · t₂'

    ξ-suc : ∀ {t t'}
      → t —→ t'
        ------------------
      → ‵suc t —→ ‵suc t'

    β : ∀ {t u}
      → 1 ≻ t
      → Value u
        -------
      → (ƛ t) · u —→ [ 0 :→ u ] t
\end{code}
Once again, the requirements for local closure could be removed, but they are kept here to follow
the rules presented in \citet{chargueraud_locally_2012}.

Following \citet{wadler_programming_2022}, we define some convenience functions, namely, reflexive
and transitive closure properties which will help reason about taking a reduction step. These follow
similar syntax to how equality reasoning is written in the Agda standard library
\citep{the_agda_community_agda_2024}.
\begin{comment}
\begin{code}
  infix  2 _—↠_
  infix  1 begin'_
  infixr 2 _—→⟨_⟩_
  infix  3 _∎'
\end{code}
\end{comment}
\begin{code}
  data _—↠_ : Term → Term → Set where
    _∎' : ∀ M
        ---------
      → M —↠ M

    step—→ : ∀ L {M N}
      → M —↠ N
      → L —→ M
        ---------
      → L —↠ N

  pattern _—→⟨_⟩_ L L—→M M—↠N = step—→ L M—↠N L—→M

  begin'_ : ∀ {M N}
    → M —↠ N
      ------
    → M —↠ N
  begin' M—↠N = M—↠N
\end{code}

There are two important properties which are required to implement evaluation. Progress (that terms
can always take a step, or are a value and are thus finished reducing) is presented below.
\begin{code}
  data Progress (t : Term) : Set where
    step : ∀ {t'}
      → t —→ t'
        ----------
      → Progress t

    done :
        Value t
        ----------
      → Progress t

  progress : ∀ {t A}
    → ∅ ⊢ t ⦂ A
      ----------
    → Progress t
  progress (⊢ƛ x) = done V-ƛ
  progress (⊢· ⊢t₁ ⊢t₂) with progress ⊢t₁
  ... | step t₁→t₁' = step (ξ₁ t₁→t₁' (⊢⇒lc ⊢t₂))
  ... | done V-ƛ with progress ⊢t₂
  ...   | step t₂→t₂' = step (ξ₂ t₂→t₂')
  ...   | done val    = step (β (i≻ƛt⇒si≻t (⊢⇒lc ⊢t₁)) val)
  progress ⊢zero = done V-zero
  progress (⊢suc ⊢t) with progress ⊢t
  ... | step t→t' = step (ξ-suc t→t')
  ... | done val  = done (V-suc val)
\end{code}

And preservation, that types are preserved when reducing.
\begin{code}
  preserve : ∀ {t t' A}
    → ∅ ⊢ t ⦂ A
    → t —→ t'
      ----------
    → ∅ ⊢ t' ⦂ A
  preserve (⊢· ⊢t₁ ⊢t₂) (ξ₁ t→t' _) = ⊢· (preserve ⊢t₁ t→t') ⊢t₂
  preserve (⊢· ⊢t₁ ⊢t₂) (ξ₂ t→t') = ⊢· ⊢t₁  (preserve ⊢t₂ t→t')
  preserve (⊢· ⊢t₁ ⊢t₂) (β x x₁) = subst-op ⊢t₂ ⊢t₁
  preserve (⊢suc ⊢t) (ξ-suc t→t') = ⊢suc (preserve ⊢t t→t')
\end{code}

Since STLC is not Turing complete \citep{church_formulation_1940}, we don't need to worry about
programs which don't terminate. Still, the evaluation function needs to receive a timeout argument,
as otherwise, Agda cannot determine that it would terminate. Thus, we define a record which limits
evaluation to a certain number of reduction steps. Then we can use the preserve and progress
properties to make an \texttt{eval} function. This is the same definition as
\citet{wadler_programming_2022} uses, so the explanation is ommitted here.
\begin{code}
  record Gas : Set where
    eta-equality
    constructor gas
    field
      amount : ℕ

  data Finished (t : Term) : Set where
    done : Value t → Finished t
    out-of-gas : Finished t

  data Steps (t : Term) : Set where
    steps : ∀ {t'} → t —↠ t' → Finished t' → Steps t

  eval : ∀ {t A} → Gas → ∅ ⊢ t ⦂ A → Steps t
  eval {t} (gas zero) ⊢t = steps (t ∎') out-of-gas
  eval {t} (gas (suc n)) ⊢t with progress ⊢t
  ... | done V-t = steps (t ∎') (done V-t)
  ... | step {t'} t→t' with eval (gas n) (preserve ⊢t t→t')
  ...   | steps t'→u fin-u = steps (t —→⟨ t→t' ⟩ t'→u) fin-u
\end{code}

We provide an example for evaluation. First, we require a type derivation for $2+2$. We would show
that it evaluates to $4$, but because the evaluation proof requires more than eleven thousand lines
of code, it is omitted. But we encourage the reader to try it out for themselves. The proofs of
\texttt{⊢two} and \texttt{⊢plus} are long and are omitted (but present in the source file).
\begin{code}
  two : Term
  two = ƛ ƛ bound 1 · (bound 1 · bound 0)

  plus : Term
  plus = ƛ ƛ ƛ ƛ bound 3 · bound 1 · (bound 2 · bound 1 · bound 0)

  suc' : Term
  suc' = ƛ ‵suc (bound 0)

  ⊢two : ∅ ⊢ two ⦂ (‵ℕ ⇒ ‵ℕ) ⇒ ‵ℕ ⇒ ‵ℕ
  -- omitted.

  ⊢plus : ∀ {Γ A} → Γ ⊢ plus ⦂
    ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A)
  -- omitted

  ⊢suc' : ∀ {Γ} → Γ ⊢ suc' ⦂ ‵ℕ ⇒ ‵ℕ
  ⊢suc' = ⊢ƛ И⟨ [] , (λ _ → ⊢suc (⊢free H′)) ⟩

  ⊢2+2 : ∅ ⊢ plus · two · two · suc' · ‵zero ⦂ ‵ℕ
  ⊢2+2 = ⊢· (⊢· (⊢· (⊢· ⊢plus  ⊢two) ⊢two) ⊢suc') ⊢zero

  -- Using Emacs, normalise "eval (gas 100) ⊢2+2" by pressing
  -- C-c C-n.
\end{code}
\begin{comment}
\begin{code}
  ⊢two = ⊢ƛ
    И⟨ []
    , (λ a → ⊢ƛ
      И⟨ (a ∷ [])
      , (λ b {b∉} →
        ⊢·
        (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′))
        (⊢· (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′)) (⊢free (H′)))) ⟩) ⟩

  ⊢plus = ⊢ƛ
    И⟨ []
    , (λ a → ⊢ƛ
      И⟨ a ∷ []
      , (λ b {b∉} → ⊢ƛ
        И⟨ a ∷ b ∷ []
        , (λ c {c∉} → ⊢ƛ
          И⟨ a ∷ b ∷ c ∷ []
          , (λ d {d∉} →
          ⊢·
            (⊢·
              (⊢free (T (a≢d d∉) (T (a≢c c∉) (T (a≢b b∉) H′))))
              (⊢free (T (c≢d d∉) (H′))))
            (⊢·
              (⊢·
                (⊢free (T (b≢d d∉) (T (b≢c c∉) H′)))
                (⊢free (T (c≢d d∉) H′)))
              (⊢free H′))) ⟩) ⟩) ⟩) ⟩
    where
      a≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → a ≢ d
      a≢d d∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ d∉)))
      a≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → a ≢ c
      a≢c c∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ c∉)))
      a≢b : ∀ {a b} → b ∉ a ∷ [] → a ≢ b
      a≢b b∉ = sym-≢ (∉∷[]⇒≢ b∉)
      c≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → c ≢ d
      c≢d {a} {b} d∉ =
        sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ b ∷ []} d∉)))
      b≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → b ≢ d
      b≢d {a} {b} d∉ =
        sym-≢ (∉∷[]⇒≢ (proj₂ (
          ∉-++
            {xs = a ∷ []}
            (proj₁ (∉-++ {xs = a ∷ b ∷ []} d∉)))))
      b≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → b ≢ c
      b≢c {a} c∉ = sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ []} c∉)))
\end{code}
\end{comment}

\chapter{System F}
Combining System F with the locally nameless representation was previously described by
\citet{chargueraud_locally_2012}.
\begin{code}
module chapter4 where
  open import cofinite
  open import plfa_adaptions using (∉∷[]⇒≢; ∉-++)
  open import tspl_prior_work
    using (suc-preserves-≢; sym-≢; fresh; fresh-correct)
\end{code}

\section{Syntax of types and terms}
In System F, types become part of the syntax, as they now become a part of how terms are built.
Note, some authors use $\Pi$ for the $∀$ type instead, such as \citet{hutton_system_2019}, and some
use the lowercase $\lambda$ for both term and type abstraction, such as \citet{pierce_types_2002}.

\begin{code}
  data Type : Set where
    ‵ℕ      : Type               -- Base type.
    t-fr     : List Char → Type   -- Free type variables.
    t-#      : ℕ → Type           -- Bound type variables.
    _⇒_      : Type → Type → Type -- Arrow types.
    t-∀      : Type → Type        -- "For all" type.

  data Term : Set where
    fr     : List Char → Term
    #      : ℕ → Term
    -- λ terms now have a type bound. E.g. λ: T. M
    ƛ_,_   : Type → Term → Term
    _·_    : Term → Term → Term
    Λ_     : Term → Term
    _[_]   : Term → Type → Term
    ‵zero  : Term
    ‵suc_  : Term → Term

  ƛ-inj : ∀ {L M A B}
    → ƛ A , L ≡ ƛ B , M → (A ≡ B) × (L ≡ M)
  ƛ-inj refl = ⟨ refl , refl ⟩
  ·-inj : ∀ {L M L' M'}
    → L · M ≡ L' · M' → (L ≡ L') × (M ≡ M')
  ·-inj refl = ⟨ refl , refl ⟩
  Λ-inj : ∀ {L M}
    → Λ L ≡ Λ M → L ≡ M
  Λ-inj refl = refl
  []-inj : ∀ {L M A B}
    → L [ A ] ≡ M [ B ] → (L ≡ M) × (A ≡ B)
  []-inj refl = ⟨ refl , refl ⟩
  ‵suc-inj : ∀ {L M}
    → ‵suc L ≡ ‵suc M → L ≡ M
  ‵suc-inj refl = refl
\end{code}

Since there are two different types of free and bound variables now, outside of Agda code, I shall
refer to free variables in lowercase and free type variables in UPPERCASE, and bound variables using
regular arabic numerals ($0$) and bound type variables using bold arabic numerals ($\mathbf{0}$). So
for example,

\begin{equation*}
  \text{id} \triangleq (\Lambda \lambda \colon \mathbf{0}. 0) \colon \forall \mathbf{0} \to \mathbf{0}
\end{equation*}
\begin{code}
  id' : Term
  id' = Λ ƛ t-# 0 , # 0
\end{code}

More examples are given after we define type judgements in equation \ref{equation:twice_big_omega}
in section \ref{chapter4:type_judgements}.

\section{Opening}
In System F, we only require the opening operation \citep{chargueraud_locally_2012}. There are three
kinds of opening:
\begin{itemize}
  \item opening a kind at an index by replacing the bound type variable at that index with a free
        type variable,
  \item opening a term at an index by replacing the bound type variable at that index in the term
        with a free type variable, and
  \item opening a term at an index by replacing the bound variable at that index with a free
        variable.
\end{itemize}

\begin{code}
  ty-ty[_—→_]_ : ℕ → List Char → Type → Type
  ty-ty[ i —→ x ] ‵ℕ = ‵ℕ
  ty-ty[ i —→ x ] (t-fr y) = t-fr y
  ty-ty[ i —→ x ] (t-# n) with i ≟ℕ n
  ... | yes _ = t-fr x
  ... | no  _ = t-# n
  ty-ty[ i —→ x ] (A ⇒ B) = (ty-ty[ i —→ x ] A) ⇒ (ty-ty[ i —→ x ] B)
  ty-ty[ i —→ x ] t-∀ A = t-∀ (ty-ty[ suc i —→ x ] A)

  ty-tm[_—→_]_ : ℕ → List Char → Term → Term
  ty-tm[ i —→ x ] (fr y) = fr y
  ty-tm[ i —→ x ] (# n) = # n
  ty-tm[ i —→ x ] (ƛ A , L) = ƛ (ty-ty[ i —→ x ] A) , (ty-tm[ i —→ x ] L)
  ty-tm[ i —→ x ] (L · M) = (ty-tm[ i —→ x ] L) · (ty-tm[ i —→ x ] M)
  ty-tm[ i —→ x ] (Λ L) = Λ ty-tm[ suc i —→ x ] L
  ty-tm[ i —→ x ] (L [ A ]) = (ty-tm[ i —→ x ] L) [ (ty-ty[ i —→ x ] A) ]
  ty-tm[ i —→ x ] ‵zero = ‵zero
  ty-tm[ i —→ x ] (‵suc L) = ‵suc ty-tm[ i —→ x ] L

  tm-tm[_—→_]_ : ℕ → List Char → Term → Term
  tm-tm[ i —→ x ] (fr y) = fr y
  tm-tm[ i —→ x ] (# n) with i ≟ℕ n
  ... | yes _ = fr x
  ... | no  _ = # n
  tm-tm[ i —→ x ] (ƛ K , L) = ƛ K , tm-tm[ (suc i) —→ x ] L
  tm-tm[ i —→ x ] (L · M) = (tm-tm[ i —→ x ] L) · (tm-tm[ i —→ x ] M)
  tm-tm[ i —→ x ] (Λ L) = Λ (tm-tm[ i —→ x ] L)
  tm-tm[ i —→ x ] (L [ A ]) = (tm-tm[ i —→ x ] L) [ A ]
  tm-tm[ i —→ x ] ‵zero = ‵zero
  tm-tm[ i —→ x ] (‵suc L) = ‵suc tm-tm[ i —→ x ] L
\end{code}

\begin{comment}
However, I may use a different approach at some point and need to use closing. Just in case, I'll
define it here.
\begin{code}
  ty-ty[_←—_]_ : ℕ → List Char → Type → Type
  ty-ty[ i ←— x ] ‵ℕ = ‵ℕ
  ty-ty[ i ←— x ] (t-fr y) with x ≟lchar y
  ... | yes _ = t-# i
  ... | no  _ = t-fr y
  ty-ty[ i ←— x ] (t-# n) = t-# n
  ty-ty[ i ←— x ] (A ⇒ B) = (ty-ty[ i ←— x ] A) ⇒ (ty-ty[ i ←— x ] B)
  ty-ty[ i ←— x ] t-∀ A = t-∀ (ty-ty[ i ←— x ] A)

  ty-tm[_←—_]_ : ℕ → List Char → Term → Term
  ty-tm[ i ←— x ] (fr y) = fr y
  ty-tm[ i ←— x ] (# n) = # n
  ty-tm[ i ←— x ] (ƛ A , L) = ƛ (ty-ty[ i ←— x ] A) , (ty-tm[ i ←— x ] L)
  ty-tm[ i ←— x ] (L · M) = (ty-tm[ i ←— x ] L) · (ty-tm[ i ←— x ] M)
  ty-tm[ i ←— x ] (Λ L) = Λ (ty-tm[ suc i ←— x ] L)
  ty-tm[ i ←— x ] (L [ A ]) = (ty-tm[ i ←— x ] L) [ (ty-ty[ i ←— x ] A) ]
  ty-tm[ i ←— x ] ‵zero = ‵zero
  ty-tm[ i ←— x ] (‵suc L) = ‵suc ty-tm[ i ←— x ] L

  tm-tm[_←—_]_ : ℕ → List Char → Term → Term
  tm-tm[ i ←— x ] (fr y) with x ≟lchar y
  ... | yes _ = # i
  ... | no  _ = fr y
  tm-tm[ i ←— x ] (# n) = # n
  tm-tm[ i ←— x ] (ƛ A , L) = ƛ A , tm-tm[ (suc i) ←— x ] L
  tm-tm[ i ←— x ] (L · M) = (tm-tm[ i ←— x ] L) · (tm-tm[ i ←— x ] M)
  tm-tm[ i ←— x ] (Λ L) = Λ (tm-tm[ i ←— x ] L)
  tm-tm[ i ←— x ] (L [ A ]) = (tm-tm[ i ←— x ] L) [ A ]
  tm-tm[ i ←— x ] ‵zero = ‵zero
  tm-tm[ i ←— x ] (‵suc L) = ‵suc tm-tm[ i ←— x ] L
\end{code}
\end{comment}

\section{Local closure}
\label{chapter4:local_closure}
Like before, a term or kind locally closed at level $i$ if it remains unchanged after opening it at
$i$, see equation \ref{equation:local_closure}.

\begin{comment}
\begin{code}
  _≻k_ : ℕ → Type → Set
  i ≻k A = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , (ty-ty[ j —→ a ] A ≡ A)

  _≻t_ : ℕ → Term → Set
  i ≻t L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , (tm-tm[ j —→ a ] L ≡ L)

  K-LocallyClosed : Type → Set
  K-LocallyClosed A = 0 ≻k A

  T-LocallyClosed : Term → Set
  T-LocallyClosed T = 0 ≻t T
\end{code}
\end{comment}

To make future proofs simpler, we will make use of Agda's instances, which are similar to
typeclasses in Haskell or traits in Rust or Scala. We will follow how \citet{pitts_locally_2023}
defined locally nameless sets, but require fewer of the locally nameless set axioms to be fulfilled
(as we'll only need axioms 1 and 5).

Thanks to using instances, we can prove the local closure properties for both kinds of local
closure.
\begin{code}
  record Lns (A : Set) : Set where
    infix 5 [_—→_]_
    field
      -- We only need opening.
      [_—→_]_ : ℕ → List Char → A → A
      ax1 : ∀ (i : ℕ) (a b : List Char) (L : A)
        → [ i —→ a ] ([ i —→ b ] L) ≡ [ i —→ b ] L
      ax5 : ∀ (i j : ℕ) (a b : List Char) (L : A)
        → (i≢j : i ≢ j)
        → [ i —→ a ] ([ j —→ b ] L) ≡ [ j —→ b ] ([ i —→ a ] L)

  open Lns ⦃ ... ⦄

  
  -- Local closure definition.
  _≻_ : ∀ {A : Set} ⦃ _ : Lns A ⦄ → ℕ → A → Set
  i ≻ L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , ([ j —→ a ] L ≡ L)
  LocallyClosed : ∀ {A : Set} ⦃ _ : Lns A ⦄ → A → Set
  LocallyClosed L = 0 ≻ L
  -- Local closure lemmas.
  lemma2·6 : ∀ {A : Set} ⦃ _ : Lns A ⦄ {i j : ℕ} {L : A}
    → j ≥ i   → i ≻ L
      ---------------
    → j ≻ L
  lemma2·6 j≥i i≻L k = i≻L k ⦃ ≤-trans j≥i it ⦄

  lemma2·7-1 : ∀ {A : Set} ⦃ _ : Lns A ⦄ {i : ℕ} {x y : List Char} {L : A}
    → [ i —→ x ] L ≡ L
      ----------------
    → [ i —→ y ] L ≡ L
  lemma2·7-1 {_} {i} {x} {y} {L} assump =
    begin
      [ i —→ y ] L
    ≡⟨ sym (cong ([ i —→ y ]_) assump) ⟩
      [ i —→ y ] ([ i —→ x ] L)
    ≡⟨ ax1 i y x L ⟩
      [ i —→ x ] L
    ≡⟨ assump ⟩
      L
    ∎

  lemma2·7-2 : ∀ {A : Set} ⦃ _ : Lns A ⦄ {i j : ℕ} {x : List Char} {L : A}
    → j ≥ i → i ≻ L
      ----------------
    → [ j —→ x ] L ≡ L
  lemma2·7-2 {j = j} j≥i i≻L =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻L j ⦃ j≥i ⦄ in
      lemma2·7-1 (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})

  lemma2·13 : ∀ {A : Set} ⦃ _ : Lns A ⦄ {L : A} {x : List Char} {i : ℕ} (j : ℕ)
    → j ≥ i      → i ≻ L
      ------------------
    → i ≻ ([ j —→ x ] L)
  lemma2·13 {_} {L} {x} j j≥i i≻L k
    with j ≟ℕ k | Иe₁ (i≻L j ⦃ j≥i ⦄)
  ... | yes refl | l = И⟨ l , (λ a → ax1 j a x L) ⟩
  ... | no  j≢k  | l = И⟨ l , (λ a → 
    begin
      [ k —→ a ] ([ j —→ x ] L)
    ≡⟨ ax5 k j a x L (sym-≢ j≢k) ⟩
      [ j —→ x ] ([ k —→ a ] L)
    ≡⟨ cong [ j —→ x ]_ (lemma2·7-2 it i≻L) ⟩
      [ j —→ x ] L
    ∎) ⟩

  open-rec-lc-lemma : ∀ {L i j u v}
    → i ≢ j
    → tm-tm[ i —→ u ] (tm-tm[ j —→ v ] L) ≡ tm-tm[ j —→ v ] L
    → tm-tm[ i —→ u ] L ≡ L
  open-rec-lc-lemma {fr x} i≢j assump = refl
  open-rec-lc-lemma {# k} {i} {j} i≢j assump
    with i ≟ℕ j | i ≟ℕ k
  ... | yes refl | _ = contradiction refl i≢j
  ... | no _     | no _ = refl
  ... | no _     | yes refl with j ≟ℕ k
  ...   | yes refl = contradiction refl i≢j
  ...   | no j≢k with k ≟ℕ k
  ...     | yes refl with () ← assump
  ...     | no  k≢k  = contradiction refl k≢k
  open-rec-lc-lemma {ƛ A , L} {i} {j} i≢j assump
    rewrite open-rec-lc-lemma {L} {suc i} {suc j}
      (suc-preserves-≢ i≢j)
      (proj₂ (ƛ-inj assump))
    = refl
  open-rec-lc-lemma {L · M} i≢j assump rewrite
      open-rec-lc-lemma {L} i≢j (proj₁ (·-inj assump))
    | open-rec-lc-lemma {M} i≢j (proj₂ (·-inj assump))
    = refl
  open-rec-lc-lemma {Λ L} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (Λ-inj assump) = refl
  open-rec-lc-lemma {L [ x ]} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (proj₁ ([]-inj assump)) = refl
  open-rec-lc-lemma {‵zero} i≢j assump = refl
  open-rec-lc-lemma {‵suc L} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (‵suc-inj assump) = refl
\end{code}

Now we simply prove axioms 1 and 5 for both kinds of opening, and we get the lemmas above for both.
\begin{code}
  ax1-type : ∀ (i : ℕ) (a b : List Char) (A : Type)
    → ty-ty[ i —→ a ] (ty-ty[ i —→ b ] A) ≡ ty-ty[ i —→ b ] A
  ax1-type i a b ‵ℕ = refl
  ax1-type i a b (t-fr x) = refl
  ax1-type i a b (t-# k) with i ≟ℕ k
  ... | yes _   = refl
  ... | no  i≢k with i ≟ℕ k
  ... | yes refl = contradiction refl i≢k
  ... | no  _    = refl
  ax1-type i a b (A ⇒ B)
    rewrite ax1-type i a b A | ax1-type i a b B = refl
  ax1-type i a b (t-∀ A) rewrite ax1-type (suc i) a b A = refl

  ax5-type : ∀ (i j : ℕ) (a b : List Char) (A : Type)
    → (i≢j : i ≢ j)
    → ty-ty[ i —→ a ] (ty-ty[ j —→ b ] A)
      ≡ ty-ty[ j —→ b ] (ty-ty[ i —→ a ] A)
  ax5-type i j a b ‵ℕ i≢j = refl
  ax5-type i j a b (t-fr x) i≢j = refl
  ax5-type i j a b (t-# k) i≢j with j ≟ℕ k
  ... | yes refl with i ≟ℕ k
  ... |   yes refl = contradiction refl i≢j
  ... |   no  i≢k  with j ≟ℕ j
  ... |     yes refl = refl
  ... |     no  j≢j  = contradiction refl j≢j
  ax5-type i j a b (t-# k) i≢j | no j≢k with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k  with j ≟ℕ k
  ... |   yes refl = contradiction refl j≢k
  ... |   no  _    = refl
  ax5-type i j a b (A ⇒ B) i≢j
    rewrite ax5-type i j a b A i≢j | ax5-type i j a b B i≢j = refl
  ax5-type i j a b (t-∀ A) i≢j
    rewrite ax5-type (suc i) (suc j) a b A (suc-preserves-≢ i≢j)
          = refl
  
  instance
    LnsType : Lns Type
    LnsType = record
      { [_—→_]_ = ty-ty[_—→_]_
      ; ax1 = ax1-type
      ; ax5 = ax5-type }
\end{code}

The proof for \texttt{Term} is very similar and omitted here (see the source file for the full proof).
\begin{code}
  ax1-term : ∀ (i : ℕ) (a b : List Char) (L : Term)
    → tm-tm[ i —→ a ] (tm-tm[ i —→ b ] L) ≡ tm-tm[ i —→ b ] L
  -- omitted.
  ax5-term : ∀ (i j : ℕ) (a b : List Char) (L : Term)
    → (i≢j : i ≢ j)
    → tm-tm[ i —→ a ] (tm-tm[ j —→ b ] L)
        ≡ tm-tm[ j —→ b ] (tm-tm[ i —→ a ] L)
  -- omitted.

  instance
    LnsTerm : Lns Term
    LnsTerm = record
      { [_—→_]_ = tm-tm[_—→_]_
      ; ax1 = ax1-term
      ; ax5 = ax5-term }
\end{code}

\begin{comment}
\begin{code}
  ax1-term i a b (fr x) = refl
  ax1-term i a b (# k) with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k  with i ≟ℕ k
  ... |   yes refl = contradiction refl i≢k
  ... |   no  _    = refl
  ax1-term i a b (ƛ A , L) rewrite ax1-term (suc i) a b L = refl
  ax1-term i a b (L · M)
    rewrite ax1-term i a b L | ax1-term i a b M = refl
  ax1-term i a b (Λ L) rewrite ax1-term i a b L = refl
  ax1-term i a b (L [ A ]) rewrite ax1-term i a b L = refl
  ax1-term i a b ‵zero = refl
  ax1-term i a b (‵suc L) rewrite ax1-term i a b L = refl

  ax5-term i j a b (fr x) i≢j = refl
  ax5-term i j a b (# k) i≢j with j ≟ℕ k
  ... | yes refl with i ≟ℕ j
  ... |   yes refl = contradiction refl i≢j
  ... |   no  i≢j with j ≟ℕ j
  ... |     yes refl = refl
  ... |     no  j≢j  = contradiction refl j≢j
  ax5-term i j a b (# k) i≢j | no j≢k with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k with j ≟ℕ k
  ... |   yes refl = contradiction refl j≢k
  ... |   no  j≢k  = refl
  ax5-term i j a b (ƛ A , L) i≢j
    rewrite ax5-term (suc i) (suc j) a b L (suc-preserves-≢ i≢j)
      = refl
  ax5-term i j a b (L · M) i≢j
    rewrite ax5-term i j a b L i≢j | ax5-term i j a b M i≢j = refl
  ax5-term i j a b (Λ L) i≢j
    rewrite ax5-term i j a b L i≢j = refl
  ax5-term i j a b (L [ A ]) i≢j
    rewrite ax5-term i j a b L i≢j = refl
  ax5-term i j a b ‵zero i≢j = refl
  ax5-term i j a b (‵suc L) i≢j rewrite ax5-term i j a b L i≢j
    = refl
\end{code}
\end{comment}

\section{Free variables}
I don't think this is needed...
\begin{code}
  ftv-ty : Type -> List (List Char)
  ftv-ty ‵ℕ = []
  ftv-ty (t-fr x) = x ∷ []
  ftv-ty (t-# i) = []
  ftv-ty (A ⇒ B) = ftv-ty A ++ ftv-ty B
  ftv-ty (t-∀ A) = ftv-ty A

  ftv-tm : Term → List (List Char)
  ftv-tm (fr x) = []
  ftv-tm (# i) = []
  ftv-tm (ƛ A , L) = ftv-ty A
  ftv-tm (L · M) = ftv-tm L ++ ftv-tm M
  ftv-tm (Λ L) = ftv-tm L
  ftv-tm (L [ A ]) = ftv-ty A
  ftv-tm ‵zero = []
  ftv-tm (‵suc L) = ftv-tm L

  fv-tm : Term → List (List Char)
  fv-tm (fr x) = x ∷ []
  fv-tm (# i) = []
  fv-tm (ƛ A , L) = fv-tm L
  fv-tm (L · M) = fv-tm L ++ fv-tm M
  fv-tm (Λ L) = fv-tm L
  fv-tm (L [ A ]) = fv-tm L
  fv-tm ‵zero = []
  fv-tm (‵suc L) = fv-tm L

  record FreeVariables : Set where
    constructor ⟨fv:_,ftv:_⟩
    field
      fv : List (List Char)
      ftv : List (List Char)
\end{code}

\section{Substitution of Types and Terms}
\begin{code}
  ty-ty[_:=_]_ : List Char → Type → Type → Type
  ty-ty[ x := T ] ‵ℕ = ‵ℕ
  ty-ty[ x := T ] (t-fr y) with x ≟lchar y
  ... | yes refl = T
  ... | no  _    = t-fr y
  ty-ty[ x := T ] (t-# i) = t-# i
  ty-ty[ x := T ] (A ⇒ B) = (ty-ty[ x := T ] A) ⇒ (ty-ty[ x := T ] B)
  ty-ty[ x := T ] (t-∀ A) = t-∀ (ty-ty[ x := T ] A)

  ty-tm[_:=_]_ : List Char → Type → Term → Term
  ty-tm[ x := T ] (fr y) = fr y
  ty-tm[ x := T ] (# i) = # i
  ty-tm[ x := T ] (ƛ A , L) = ƛ ty-ty[ x := T ] A , (ty-tm[ x := T ] L) 
  ty-tm[ x := T ] (L · M) = (ty-tm[ x := T ] L) · (ty-tm[ x := T ] M)
  ty-tm[ x := T ] (Λ L) = Λ (ty-tm[ x := T ] L)
  ty-tm[ x := T ] (L [ A ]) = (ty-tm[ x := T ] L) [ ty-ty[ x := T ] A ]
  ty-tm[ x := T ] ‵zero = ‵zero
  ty-tm[ x := T ] (‵suc L) = ‵suc ty-tm[ x := T ] L

  tm-tm[_:=_]_ : List Char → Term → Term → Term
  tm-tm[ x := N ] (fr y) with x ≟lchar y
  ... | yes refl = N
  ... | no  _    = fr y
  tm-tm[ x := N ] (# i) = # i
  tm-tm[ x := N ] (ƛ A , L) = ƛ A , tm-tm[ x := N ] L
  tm-tm[ x := N ] (L · M) = (tm-tm[ x := N ] L) · (tm-tm[ x := N ] M)
  tm-tm[ x := T ] (Λ L) = Λ (tm-tm[ x := T ] L)
  tm-tm[ x := T ] (L [ A ]) = (tm-tm[ x := T ] L) [ A ]
  tm-tm[ x := N ] ‵zero = ‵zero
  tm-tm[ x := N ] (‵suc L) = tm-tm[ x := N ] L
\end{code}

We should also define the alternative substitution.
\begin{code}
  ty-ty[_:→_]_ : ℕ → Type → Type → Type
  ty-ty[ k :→ T ] ‵ℕ = ‵ℕ
  ty-ty[ k :→ T ] (t-fr x) = t-fr x
  ty-ty[ k :→ T ] (t-# i) with k ≟ℕ i
  ... | yes refl = T
  ... | no  _    = t-# i
  ty-ty[ k :→ T ] (A ⇒ B) = (ty-ty[ k :→ T ] A) ⇒ (ty-ty[ k :→ T ] B)
  ty-ty[ k :→ T ] (t-∀ A) = t-∀ (ty-ty[ k :→ T ] A)

  ty-tm[_:→_]_ : ℕ → Type → Term → Term
  ty-tm[ k :→ T ] (fr x) = fr x
  ty-tm[ k :→ T ] (# i) = # i
  ty-tm[ k :→ T ] (ƛ A , L) = ƛ ty-ty[ k :→ T ] A , ty-tm[ k :→ T ] L
  ty-tm[ k :→ T ] (L · M) = (ty-tm[ k :→ T ] L) · (ty-tm[ k :→ T ] M)
  ty-tm[ k :→ T ] (Λ L) = Λ ty-tm[ suc k :→ T ] L
  ty-tm[ k :→ T ] (L [ A ]) = (ty-tm[ k :→ T ] L) [ ty-ty[ k :→ T ] A ]
  ty-tm[ k :→ T ] ‵zero = ‵zero
  ty-tm[ k :→ T ] (‵suc L) = ‵suc ty-tm[ k :→ T ] L

  tm-tm[_:→_]_ : ℕ → Term → Term → Term
  tm-tm[ k :→ N ] (fr x) = fr x
  tm-tm[ k :→ N ] (# i) with k ≟ℕ i
  ... | yes refl = N
  ... | no  _    = # i
  tm-tm[ k :→ N ] (ƛ A , L) = ƛ A , tm-tm[ suc k :→ N ] L
  tm-tm[ k :→ N ] (L · M) = (tm-tm[ k :→ N ] L) · (tm-tm[ k :→ N ] M)
  tm-tm[ k :→ N ] (Λ L) = Λ tm-tm[ k :→ N ] L
  tm-tm[ k :→ N ] (L [ A ]) = (tm-tm[ k :→ N ] L) [ A ]
  tm-tm[ k :→ N ] ‵zero = ‵zero
  tm-tm[ k :→ N ] (‵suc L) = ‵suc tm-tm[ k :→ N ] L
\end{code}

\section{Type Environments}
Type environments work as they did for the STLC. Note that since we're implementing System F with
the \texttt{‵zero} and \texttt{‵suc} primitives only (and no other language extensions), we don't
need to add free type variables to the context \citep{pierce_types_2002}. This would, however, be
necessary if one wanted to implement System F$_{<:}$ \citep{chargueraud_locally_2012} or System
F$_{\omega}$ \citep{hutton_system_2019}.

\begin{code}
  data Context : Set where
    ∅ : Context
    _,_⦂_ : Context → List Char → Type → Context
\end{code}

Accessing the context is done in two different ways:
\begin{itemize}
  \item If a free variable is required, then the accessor is the constructor \texttt{∋fv}.
  \item If a free type variable is required, then the accessor is the constructor \texttt{∋ftv}.
\end{itemize}
\begin{code}
  infix  4  _∋_⦂_
  data _∋_⦂_ : Context → List Char → Type → Set where
    H : ∀ {Γ x y A}
      → x ≡ y
        --------------------
      → (Γ , x ⦂ A) ∋ y ⦂ A

    T : ∀ {Γ x y A B}
      → x ≢ y
      → (Γ ∋ x ⦂ A)
        -----------------
      → (Γ , y ⦂ B) ∋ x ⦂ A

  H′ : ∀ {Γ x A} → (Γ , x ⦂ A) ∋ x ⦂ A
  H′ = H refl

  T′ : ∀ {Γ x y A B}
    → {x≢y : False (x ≟lchar y)}
    → Γ ∋ x ⦂ A
      ------------------
    → (Γ , y ⦂ B) ∋ x ⦂ A
  T′ { x≢y = x≢y } x = T (toWitnessFalse x≢y) x
\end{code}

We require three ways of accessing the context (and thus three constructors) for each accessor;
\begin{itemize}
  \item one for when the variable is at the top of the context,
  \item one for going deeper in the context if a free variable is on the top, and
  \item one for going deeper in the context if a free type variable is on top.
\end{itemize}

As for the STLC, we provide some convenience functions with the \texttt{′} character to find the
relevant evidence automatically.

Here are three examples of accessing the context.
\begin{code}
  _ : ((∅ , ('x' ∷ []) ⦂ ‵ℕ) , ('t' ∷ []) ⦂ ‵ℕ) ∋ ('t' ∷ []) ⦂ ‵ℕ
  _ = H refl

  _ : ((∅ , ('x' ∷ []) ⦂ ‵ℕ) , ('t' ∷ []) ⦂ ‵ℕ) ∋ ('x' ∷ []) ⦂ ‵ℕ
  _ = T (λ ()) (H refl)

  _ : ((∅ , ('f' ∷ []) ⦂ (‵ℕ ⇒ ‵ℕ)) , ('x' ∷ []) ⦂ ‵ℕ) ∋ ('f' ∷ []) ⦂ (‵ℕ ⇒ ‵ℕ)
  _ = T′ H′
\end{code}

\begin{code}
  domain : Context → List (List Char)
  domain ∅ = []
  domain (ctx , x ⦂ x₁) = x ∷ domain ctx
\end{code}

\section{Type judgements}
\label{chapter4:type_judgements}
Modifying the ones presented in \citet{chargueraud_locally_2012}, since he uses subtyping, System F
has these type judgements (some $x \in \texttt{List Char}$, types $A, B, T$, context $\Gamma$, and
terms $L, M$):
\begin{equation}
\begin{gathered}
  \inferrule
    { }
    {\Gamma \vdash \texttt{‵zero} \colon \nat}
    \; (\vdash\texttt{zero})\quad
  \inferrule
    {\Gamma \vdash L \colon \nat}
    {\Gamma \vdash \texttt{‵suc} \, L \colon \nat}
    \; (\vdash\texttt{suc})\quad
  \inferrule
    {x \colon A \in \Gamma}
    {\Gamma \vdash x \colon A}
    \; (\vdash\text{free})
  \\
  \inferrule
    {\cof x , \; (\Gamma , \, x \colon A \vdash [0 \to x] L \colon B)}
    {\Gamma \vdash (\lambda \colon A. L) \colon A \to B}
    \; (\vdash\lambda)\quad
  \inferrule
    {\Gamma \vdash L \colon A \to B\\\Gamma \vdash M \colon A}
    {\Gamma \vdash L M \colon B}
    \; (\vdash\text{app})
  \\
  \inferrule
    {\cof T, \; (\Gamma \vdash ([0 \to T] L) \colon [0 \to T] B)}
    {\Gamma \vdash (\Lambda \, L) \colon \forall B}
    \; (\vdash\Lambda)
  \quad
  \inferrule
    {\Gamma \vdash L \colon \forall B}
    {\Gamma \vdash L [ A ] \colon [0 \to A] B}
    \; (\vdash[])
\end{gathered}
\end{equation}

The first five rules are the same as they were for the STLC (with the exception that the ($\vdash
\lambda$) case was adapted to the new syntax, it includes a `$\colon A$' after the $\lambda$ in the
consequent). Notice how the two new rules for type abstraction are similar to the two rules for
$\lambda$-abstraction. For the ($\vdash\Lambda$) judgement, both the term and the type need to be
opened with the cofinite type variable $T$ because bound type variables can be referenced in both
the term and the type. For the ($\vdash[]$) judgement, if one were to rewrite the antecedant type in
fully named syntax, it would be $\Gamma \vdash L \colon \forall A. B$, which more closely mirrors
the ($\vdash\text{app}$) judgement. There is only one part to the antecedant because we don't keep
track of free type variables in the context.

\begin{code}
  infix  4 _⊢_⦂_
  data _⊢_⦂_ : Context → Term → Type → Set where
    ⊢free : ∀ {Γ x A}
      → Γ ∋ x ⦂ A
        --------------
      → Γ ⊢ fr x ⦂ A

    ⊢ƛ : ∀ {Γ L A B}
      → И x , (Γ , x ⦂ A ⊢ tm-tm[ 0 —→ x ] L ⦂ B)
        ----------------------------------------
      → Γ ⊢ ƛ A , L ⦂ (A ⇒ B)

    ⊢· : ∀ {Γ L M A B}
      → Γ ⊢ L ⦂ (A ⇒ B)
      → Γ ⊢ M ⦂ A
        ---------------
      → Γ ⊢ L · M ⦂ B

    ⊢Λ : ∀ {Γ L B}
      → И T , (Γ ⊢ ty-tm[ 0 —→ T ] L ⦂ (ty-ty[ 0 —→ T ] B))
        ---------------------------------------------------
      → Γ ⊢ Λ L ⦂ t-∀ B

    ⊢[] : ∀ {Γ L A B}
      → Γ ⊢ L ⦂ t-∀ B
        ---------------
      → Γ ⊢ L [ A ] ⦂ ty-ty[ 0 :→ A ] B

    ⊢zero : ∀ {Γ}
        --------------
      → Γ ⊢ ‵zero ⦂ ‵ℕ

    ⊢suc : ∀ {Γ L}
      → Γ ⊢ L ⦂ ‵ℕ
        ---------------
      → Γ ⊢ ‵suc L ⦂ ‵ℕ
\end{code}

We can give a type to \textit{twice} and $\Omega$ now.
\begin{align}
\label{equation:twice_big_omega}
  \text{twice} &\triangleq (\Lambda \lambda \colon \mathbf{0} \to \mathbf{0}. \lambda \colon \mathbf{0}. 1(10))
    \colon \forall (\mathbf{0} \to \mathbf{0}) \to \mathbf{0} \to \mathbf{0}\\
  \Omega &\triangleq (\lambda \colon (\forall \mathbf{0} \to \mathbf{0}). (0 [\forall \mathbf{0} \to \mathbf{0}]) 0)
    \colon (\forall \mathbf{0} \to \mathbf{0}) \to (\forall \mathbf{0} \to \mathbf{0}) \notag
\end{align}
\begin{code}
  module example where
    twice : ∅ ⊢ (Λ ƛ ((t-# 0) ⇒ (t-# 0))
      , (ƛ (t-# 0) , ((# 1) · ((# 1) · (# 0)))))
        ⦂ t-∀ (((t-# 0) ⇒ (t-# 0))
          ⇒ ((t-# 0) ⇒ (t-# 0)))
    twice = ⊢Λ И⟨ [] , (λ A {A∉} → ⊢ƛ И⟨ [] , (λ f {f∉} →
      ⊢ƛ И⟨ (f ∷ []) , (λ x {x∉} → ⊢·
        (⊢free (T (f≢x x∉) H′ ))
        (⊢· (⊢free (T (f≢x x∉) H′ )) (⊢free H′))) ⟩) ⟩) ⟩
      where
        f≢x : ∀ {f x} → x ∉ f ∷ [] → f ≢ x
        f≢x x∉ = sym-≢ (∉∷[]⇒≢ x∉)

    big-omega : ∅ ⊢ (ƛ (t-∀ ((t-# 0) ⇒ (t-# 0)))
      , (((# 0) [ t-∀ ((t-# 0) ⇒ (t-# 0)) ]) · (# 0)))
        ⦂ (t-∀ ((t-# 0) ⇒ (t-# 0)))
          ⇒ (t-∀ ((t-# 0) ⇒ (t-# 0)))
    big-omega =
      ⊢ƛ И⟨ [] , (λ x {x∉} → ⊢· (⊢[] (⊢free H′)) (⊢free H′)) ⟩
\end{code}

\section{Typing properties}
Once again, these properties are similar to those in \citet{wadler_programming_2022}.
\begin{code}
  -- Extending contexts.
  ext : ∀ {Γ Δ}
    → (∀ {x A}     →        Γ ∋ x ⦂ A → Δ ∋ x ⦂ A)
      -----------------------------------------------------
    → (∀ {x y A B} → Γ , y ⦂ B ∋ x ⦂ A → Δ , y ⦂ B ∋ x ⦂ A)
  ext ρ (H refl) = H′
  ext ρ (T x≢y ∋x) = T x≢y (ρ ∋x)

  -- Renaming (a.k.a. rebasing) contexts.
  rename : ∀ {Γ Δ}
    → (∀ {x A} → Γ ∋ x ⦂ A → Δ ∋ x ⦂ A)
      ---------------------------------
    → (∀ {L A} → Γ ⊢ L ⦂ A → Δ ⊢ L ⦂ A)
  rename ρ (⊢free x) = ⊢free (ρ x)
  rename {Δ = Δ} ρ (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) = ⊢ƛ
    И⟨ (domain Δ ++ Иe₁)
    , (λ a {a∉} → rename (ext ρ) (Иe₂ a {proj₂ (∉-++ a∉)}))
    ⟩
  rename ρ (⊢· ⊢A⇒B ⊢A) = ⊢· (rename ρ ⊢A⇒B) (rename ρ ⊢A)
  rename ρ (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢Λ И⟨ Иe₁ , (λ T {T∉} → rename ρ (Иe₂ T {T∉})) ⟩
  rename ρ (⊢[] ⊢L) = ⊢[] (rename ρ ⊢L)
  rename ρ ⊢zero = ⊢zero
  rename ρ (⊢suc ⊢L) = ⊢suc (rename ρ ⊢L)

  -- Weakening contexts.
  weaken : ∀ {Γ L A}
    → ∅ ⊢ L ⦂ A
      ---------
    → Γ ⊢ L ⦂ A
  weaken ⊢L = rename (λ ()) ⊢L

  -- Swapping variables in a context.
  swap : ∀ {Γ x y L A B C}
    → x ≢ y
    → (Γ , y ⦂ B) , x ⦂ A ⊢ L ⦂ C
      -------------------------
    → (Γ , x ⦂ A) , y ⦂ B ⊢ L ⦂ C
  swap {Γ} {x} {y} {L} {A} {B} {C} x≢y ⊢L = rename ρ ⊢L
    where
      ρ : ∀ {z C}
        → (Γ , y ⦂ B) , x ⦂ A ∋ z ⦂ C
          -------------------------
        → (Γ , x ⦂ A) , y ⦂ B ∋ z ⦂ C
      ρ (H refl) = T x≢y H′
      ρ (T z≢x (H refl)) = H′
      ρ (T z≢x (T z≢y ∋z)) = T z≢y (T z≢x ∋z)

  -- Dopping shadowed variables.
  drop : ∀ {Γ x L A B C}
    → (Γ , x ⦂ A) , x ⦂ B ⊢ L ⦂ C
      --------------------------
    → Γ , x ⦂ B ⊢ L ⦂ C
  drop {Γ} {x} {L} {A} {B} {C} ⊢L = rename ρ ⊢L
    where
      ρ : ∀ {z C}
        → (Γ , x ⦂ A) , x ⦂ B ∋ z ⦂ C
          -------------------------
        → Γ , x ⦂ B ∋ z ⦂ C
      ρ (H refl) = H′
      ρ (T z≢x (H refl)) = contradiction refl z≢x
      ρ (T z≢x (T .z≢x ∋z)) = T z≢x ∋z

  -- Apply term-equality within type judgements.
  ≡-with-⊢ : ∀ {Γ L M A}
    → Γ ⊢ L ⦂ A
    → L ≡ M
      ---------
    → Γ ⊢ M ⦂ A
  ≡-with-⊢ ⊢L refl = ⊢L
\end{code}

We will also need a lemma called \texttt{subst-open-context}
by Charguéraud [TODO: CITE].

\begin{code}
  subst-open-var : ∀ {N : Term} {x y : List Char} {i : ℕ}
    (L : Term)
    → x ≢ y
    → (i ≻ N)
    → tm-tm[ x := N ] (tm-tm[ i —→ y ] L)
      ≡ tm-tm[ i —→ y ] (tm-tm[ x := N ] L)
  subst-open-var {x = x} (fr z) x≢y i≻u with x ≟lchar z
  ... | yes refl = sym (lemma2·7-2 ≤-refl i≻u)
  ... | no  _    = refl
  subst-open-var {_} {x} {y} {i} (# k) x≢y i≻u with i ≟ℕ k
  ... | no  _ = refl
  ... | yes refl with x ≟lchar y
  ...    | yes refl = contradiction refl x≢y
  ...    | no  _    = refl
  subst-open-var {x = x} {i = i} (ƛ A , L) x≢y i≻u
    = cong₂ ƛ_,_
      refl
      (subst-open-var L x≢y (lemma2·6 (n≤1+n i) i≻u))
  subst-open-var (L · M) x≢y i≻u = cong₂ _·_
    (subst-open-var L x≢y i≻u) (subst-open-var M x≢y i≻u)
  subst-open-var (Λ L) x≢y i≻u =
    cong Λ_ (subst-open-var L x≢y i≻u)
  subst-open-var (L [ A ]) x≢y i≻u =
    cong₂ _[_] (subst-open-var L x≢y i≻u) refl
  subst-open-var ‵zero x≢y i≻u = refl
  subst-open-var (‵suc L) x≢y i≻u = subst-open-var L x≢y i≻u

  subst-open-var-ctx : ∀ {Γ A} {N : Term} {x y : List Char} {i : ℕ}
    (L : Term)
    → x ≢ y
    → (i ≻ N)
    → Γ ⊢ tm-tm[ x := N ] (tm-tm[ i —→ y ] L) ⦂ A
    → Γ ⊢ tm-tm[ i —→ y ] (tm-tm[ x := N ] L) ⦂ A
  subst-open-var-ctx L x≢y i≻N assump =
    ≡-with-⊢ assump (subst-open-var L x≢y i≻N)
\end{code}

\section{Substitution preserves types}
TODO: Talk.
\begin{code}
  ⊢⇒lc : ∀ {Γ L A} → Γ ⊢ L ⦂ A → LocallyClosed L
  ⊢⇒lc (⊢free x) j = И⟨ [] , (λ a → refl) ⟩
  ⊢⇒lc (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) j = И⟨ Иe₁ , (λ a {a∉} → cong₂ ƛ_,_ refl
    (open-rec-lc-lemma
      (λ())
      (lemma2·7-2 z≤n (⊢⇒lc (Иe₂ a {a∉}))))) ⟩
  ⊢⇒lc {Γ} (⊢· ⊢A⇒B ⊢A) _ = И⟨ domain Γ , (λ _ → cong₂ _·_
    (lemma2·7-2 z≤n (⊢⇒lc ⊢A⇒B)) (lemma2·7-2 z≤n (⊢⇒lc ⊢A))) ⟩
  ⊢⇒lc {Γ} (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) j = И⟨ domain Γ ++ Иe₁ , (λ a {a∉} → cong Λ_ (lemma2·7-2 z≤n (helper z≤n (⊢⇒lc (Иe₂ a {proj₂ (∉-++ a∉)}))))) ⟩
    where
      helper : ∀ {N i k x}
        → k ≥ i
        → i ≻ (ty-tm[ k —→ x ] N)
        → k ≻ N
      helper {fr x} {k = k} k≥i i≻ty j = i≻ty k ⦃ k≥i ⦄
      helper {# n} k≥i i≻ty = lemma2·6 k≥i i≻ty
      helper {ƛ A , N} k≥i i≻ty j =
        let И⟨ Иe₁ , Иe₂ ⟩ = i≻ty j ⦃ ≤-trans k≥i it ⦄
        in И⟨ Иe₁ , (λ a {a∉} → cong (ƛ A ,_) {!helper ? (proj₂ (ƛ-inj (Иe₂ a {a∉})))!} ) ⟩
      helper {N · N₁} k≥i i≻ty = {!!}
      helper {Λ N} k≥i i≻ty = {!!}
      helper {N [ x ]} k≥i i≻ty = {!!}
      helper {‵zero} k≥i i≻ty = {!!}
      helper {‵suc N} k≥i i≻ty = {!!}
  ⊢⇒lc {L = L [ A ]} (⊢[] ⊢L) j =
    let И⟨ Иe₁ , Иe₂ ⟩ = (⊢⇒lc ⊢L) j
    in И⟨ Иe₁ , (λ a {a∉} → cong _[ A ]  (Иe₂ a {a∉})) ⟩
  ⊢⇒lc ⊢zero j = И⟨ [] , (λ _ → refl) ⟩
  ⊢⇒lc (⊢suc ⊢L) j =
    let И⟨ Иe₁ , Иe₂ ⟩ = (⊢⇒lc ⊢L) j
    in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩
\end{code}
\chapter{Conclusions}

\section{Final Reminder}

The body of your dissertation, before the references and any appendices,
\emph{must} finish by page~40. The introduction, after preliminary material,
should have started on page~1.

You may not change the dissertation format (e.g., reduce the font size, change
the margins, or reduce the line spacing from the default single spacing). Be
careful if you copy-paste packages into your document preamble from elsewhere.
Some \LaTeX{} packages, such as \texttt{fullpage} or \texttt{savetrees}, change
the margins of your document. Do not include them!

Over-length or incorrectly-formatted dissertations will not be accepted and you
would have to modify your dissertation and resubmit. You cannot assume we will
check your submission before the final deadline and if it requires resubmission
after the deadline to conform to the page and style requirements you will be
subject to the usual late penalties based on your final submission time.

\bibliographystyle{plainnat}
\bibliography{dissertation}


% You may delete everything from \appendix up to \end{document} if you don't need it.
\appendix

\chapter{Miscellaneous Proofs}
\label{appendix:misc_proofs}

Some miscellaneous proofs are required in the main chapters. Since they aren't of interest, they are presented here in the appendix.

\input{plfa_adaptions.lagda}

\chapter{Prior work submitted for TSPL}
\label{appendix:tspl}
\input{tspl_prior_work.lagda}

\chapter{Compilation instructions}
\label{appendix:compilation_instructions}

This document is a literate Agda file. It has been tested to work with
\begin{itemize}
  \item Agda 2.7.0,
  \item the Agda Standard Library 2.1 \citep{the_agda_community_agda_2024},
  \item XeLaTeX 3.141592653-2.6-0.999996 (TeX Live 2024/Arch Linux 2024.2-4).
\end{itemize}

The full source code is available at [TODO: TO BE MADE PUBLIC LATER].

Since this document uses the Minted package [TODO: cite], XeLaTeX needs to be run with the
\texttt{--shell-escape} option. While Agda does provide its own typesetting of Agda code, it uses a
sans-serif typeface. I decided to use the Minted package to provide a monospace typeface for the
code blocks.

To typecheck the document, run Agda with the \texttt{--latex} option. If successful, it will give no
output and return an exit code \texttt{0}.

\end{document}

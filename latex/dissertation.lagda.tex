% UG project example file, February 2024
%
%   Added the "online" option for equal margins, February 2024 [Hiroshi Shimodaira, Iain Murray]
%   A minor change in citation, September 2023 [Hiroshi Shimodaira]
%
% Do not change the first two lines of code, except you may delete "logo," if causing problems.
% Understand any problems and seek approval before assuming it's ok to remove ugcheck.
\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


% Include any packages you need below, but don't include any that change the page
% layout or style of the dissertation. By including the ugcheck package above,
% you should catch most accidental changes of page layout though.

\usepackage{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

% === Custom packages === %

% Syntax highlighting
\usepackage{minted}
% BNF
\usepackage{simplebnf}
% Inference rules
\usepackage{mathpartir}
% Agda
\usepackage{agda}
\AgdaNoSpaceAroundCode{}
% Hide in output
\usepackage{comment}
% Colour
\usepackage{xcolor}

% Unicode

\usepackage{fontspec}
\usepackage{newunicodechar}
\newfontface{\notosansmono}{NotoSansMono-Regular.ttf}[Path = fonts/]
\newfontface{\ibmplexmath}{IBMPlexMath-Regular.otf}[Path = fonts/]
\newfontface{\hack}{HackNerdFontMono-Regular.ttf}[Path = fonts/]
\newunicodechar{ℕ}{{\notosansmono{ℕ}}}
\newunicodechar{∀}{{\notosansmono{∀}}}
\newunicodechar{≡}{{\notosansmono{≡}}}
\newunicodechar{≥}{{\notosansmono{≥}}}
\newunicodechar{≤}{{\notosansmono{≤}}}
\newunicodechar{≰}{{\notosansmono{≰}}}
\newunicodechar{⊔}{{\notosansmono{⊔}}}
\newunicodechar{≟}{{\notosansmono{≟}}}
\newunicodechar{⇒}{{\hack{⇒}}}
\newunicodechar{≢}{{\notosansmono{≢}}}
\newunicodechar{≮}{{\notosansmono{≮}}}
\newunicodechar{⟪}{{\notosansmono{⟪}}}
\newunicodechar{⟫}{{\notosansmono{⟫}}}
\newunicodechar{⊤}{{\notosansmono{⊤}}}
\newunicodechar{⊥}{{\notosansmono{⊥}}}
\newunicodechar{∣}{{\notosansmono{∣}}}
\newunicodechar{⟨}{{\notosansmono{⟨}}}
\newunicodechar{⟩}{{\notosansmono{⟩}}}
\newunicodechar{∎}{{\notosansmono{∎}}}
\newunicodechar{⌊}{{\notosansmono{⌊}}}
\newunicodechar{⌋}{{\notosansmono{⌋}}}
\newunicodechar{₁}{{\notosansmono{₁}}}
\newunicodechar{₂}{{\notosansmono{₂}}}
\newunicodechar{∃}{{\notosansmono{∃}}}
\newunicodechar{∷}{{\notosansmono{∷}}}
\newunicodechar{∈}{{\notosansmono{∈}}}
\newunicodechar{∉}{{\notosansmono{∉}}}
\newunicodechar{λ}{{\notosansmono{λ}}}
\newunicodechar{И}{{\notosansmono{И}}}
\newunicodechar{∘}{{\notosansmono{∘}}}
\newunicodechar{≠}{{\notosansmono{≠}}}
\newunicodechar{‵}{{\notosansmono{‵}}}
\newunicodechar{ƛ}{{\notosansmono{ƛ}}}
\newunicodechar{≻}{{\ibmplexmath{≻}}}
\newunicodechar{⦃}{{\ibmplexmath{⦃}}}
\newunicodechar{⦄}{{\ibmplexmath{⦄}}}
\newunicodechar{′}{{\notosansmono{′}}}
\newunicodechar{∋}{{\notosansmono{∋}}}
\newunicodechar{⦂}{{\ibmplexmath{⦂}}}
\newunicodechar{∅}{{\hack{∅}}}
\newunicodechar{⊢}{{\hack{⊢}}}
\newunicodechar{ξ}{{\notosansmono{ξ}}}
\newunicodechar{β}{{\notosansmono{β}}}
\newunicodechar{↠}{{\hack{↠}}}
\newunicodechar{ρ}{{\notosansmono{ρ}}}

% Maths:

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{xurl}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Real}{Re}
\DeclareMathOperator{\Imag}{Im}
\DeclareMathOperator{\complex}{\mathbb{C}}
\DeclareMathOperator{\reals}{\mathbb{R}}
\DeclareMathOperator{\nat}{\mathbb{N}}
\DeclareMathOperator{\integer}{\mathbb{Z}}
\DeclareMathOperator{\rational}{\mathbb{Q}}
\DeclareMathOperator{\Log}{Log}
\DeclareMathOperator{\Arg}{Arg}
\DeclareMathOperator{\cof}{\text{И}}

% Use minted for Agda

\let\oldcode\code
\NewCommandCopy{\mintedcopy}{\minted}
\NewCommandCopy{\endmintedcopy}{\endminted}
% Adapted from https://tex.stackexchange.com/a/488451/202867
\renewenvironment{code}{\mintedcopy[breaklines,breaksymbolleft=\;]{agda}}{\endmintedcopy}
% \let\oldcode\code
% % Adapted from https://tex.stackexchange.com/a/488451/202867
% \def\code{\minted{agda}}

\begin{document}
\begin{preliminary}

\title{System F in Agda via Pitts}

\author{Charlotte Ausel}

% CHOOSE YOUR DEGREE a):
% please leave just one of the following un-commented
% \course{Artificial Intelligence}
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Software Engineering}
%\course{Cognitive Science}
%\course{Computer Science}
%\course{Computer Science and Management Science}
\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}
%\course{Software Engineering}
%\course{Master of Informatics} % MInf students

% CHOOSE YOUR DEGREE b):
% please leave just one of the following un-commented
%\project{MInf Project (Part 1) Report}  % 4th year MInf students
%\project{MInf Project (Part 2) Report}  % 5th year MInf students
\project{4th Year Project Report}        % all other UG4 students


\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

TODO.

This document is a literate Agda file and uses {\color{violet}colour}. Please see appendix
\ref{appendix:compilation_instructions} for details.

\begin{code}
module dissertation where
\end{code}

\chapter{Background}

\section{Agda}
Agda is a dependently-typed functional programming language, which makes it
suitable as a proof-assistant for intuitionistic logic
\citep{norell_towards_2007}, similar to other such proof-assistants like Coq or
Lean. Its syntax is very similar to Haskell, and in fact, the two are closely
related; the Agda compiler is a transpiler to Haskell, and the Haskell standard
library can be used in Agda \citep{kusee_compiling_2017}. Yet, Agda has stricter
limitations on recursive functions and some other such language features which,
if included, would make it harder to reason about proofs
\citep{berghofer_brief_2009}.

Agda most commonly uses inductive definitions. For example, following the Peano
axioms for the natural numbers $\nat$ \citep{boolos_freges_1995}, we may define
them like so.

\begin{code}
module Example where
  data ℕ : Set where
    zero : ℕ
    suc  : ℕ → ℕ
\end{code}

Taking advantage of the Curry-Howard correspondence, a proof in Agda is simply a
function with an appropriate type signature and function body
\citep{wadler_propositions_2015}. So, a proof that addition is associative would
use recursion, which corresponds to induction, as shown below.

\begin{comment}
\begin{code}
\end{code}
\end{comment}

\begin{code}
  -- We can import from the standard library, here we're using
  -- the reflexive and congruence properties of equality.
  open import Relation.Binary.PropositionalEquality
    using (_≡_; refl; cong)

  _+_ : ℕ → ℕ → ℕ
  zero  + m = m
  suc n + m = suc (n + m)

  +-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
  +-assoc zero    n p = refl
  +-assoc (suc m) n p = cong suc (+-assoc m n p)
\end{code}


We will need to import a lot of functions from the Agda standard library
\citep{the_agda_community_agda_2024}. These imports are omitted here, but are available in the full
source file (see appendix \ref{appendix:compilation_instructions}).
\begin{comment}
\begin{code}
-- Data types (naturals, strings, characters)
open import Data.Nat using (ℕ; zero; suc; _<_; _≥_; _≤_; _≤?_; _<?_; z≤n; s≤s; _⊔_)
  renaming (_≟_ to _≟ℕ_)
open import Data.Nat.Properties using (≤-refl; ≤-trans; ≤-<-trans; <-≤-trans; ≤-antisym; ≤-total;
  +-mono-≤; n≤1+n; m≤n⇒m≤1+n; suc-injective; <⇒≢; ≰⇒>; ≮⇒≥)
open import Data.String using (String; fromList) renaming (_≟_ to _≟str_; _++_ to _++str_;
  length to str-length; toList to ⟪_⟫)
open import Data.Char using (Char)
open import Data.Char.Properties using () renaming (_≟_ to _≟char_)
open import Data.Unit using (⊤; tt)

-- Function manipulation.
open import Function using (_∘_; flip; it; id; case_returning_of_)

-- Relations and predicates/decidability.
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; sym; trans; cong; cong-app; cong₂)
open Eq.≡-Reasoning using (begin_; step-≡-∣; step-≡-⟩; _∎)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Nullary.Decidable using (Dec; yes; no; True; False; toWitnessFalse;
  toWitness; fromWitness; ¬?; ⌊_⌋; From-yes)
open import Relation.Unary using (Decidable)
open import Relation.Binary using () renaming (Decidable to BinaryDecidable)
open import Relation.Nullary.Negation using (¬_; contradiction)
open import Data.Empty using (⊥-elim)

-- Products and exists quantifier.
open import Data.Product using (_×_; proj₁; proj₂; ∃-syntax) renaming (_,_ to ⟨_,_⟩)

-- Lists.
open import Data.List using (List; []; _∷_; _++_; length; filter; map; foldr; head; replicate)
open import Data.List.Properties using (≡-dec)
import Data.List.Membership.DecPropositional as DecPropMembership
open import Data.List.Relation.Unary.All using (All; all?; lookup)
  renaming (fromList to All-fromList; toList to All-toList)
open import Data.List.Relation.Unary.Any using (Any; here; there)
open import Data.List.Extrema Data.Nat.Properties.≤-totalOrder using (max; xs≤max)

-- Import list membership using List Char comparisons.
_≟lchar_ : ∀ (xs ys : List Char) → Dec (xs ≡ ys)
xs ≟lchar ys = ≡-dec (_≟char_) xs ys

open DecPropMembership _≟lchar_ using (_∈_; _∉_; _∈?_)
\end{code}

Include some infixes.

\begin{code}
infix  4  _∋_⦂_
infix  4 _⊢_⦂_
infixl 5 _,_⦂_

infixr 7 _⇒_

infix  5 ƛ_
infixl 7 _·_
infix  9 free_
infix  9 bound_

infix 4 _—→_
\end{code}
\end{comment}

We also need to forward-declare some theorems. These are proven in appendix
\ref{appendix:misc_proofs}. Similar to lanugages like C, we can declare a function's type signature
before its body. That way, functions whose exact definitions aren't of interest can be specified
in the appendix.

\begin{code}
All¬⇒¬Any : ∀ {A : Set} {P : A → Set} {xs : List A}
  → All (¬_ ∘ P) xs → (¬_ ∘ Any P) xs

¬Any⇒All¬ : ∀ {A : Set} {P : A → Set} {xs : List A}
  → (¬_ ∘ Any P) xs → All (¬_ ∘ P) xs

∉-++ : ∀ {s : List Char} {xs ys : List (List Char)}
  → s ∉ xs ++ ys → (s ∉ xs) × (s ∉ ys)

++-∉ : ∀ {s : List Char} {xs ys : List (List Char)}
  → s ∉ xs → s ∉ ys → s ∉ xs ++ ys

∉∷[]⇒≢ : {x y : List Char} → x ∉ y ∷ [] → x ≢ y

sym-≢ : ∀ {A : Set} {x y : A}
  → x ≢ y → y ≢ x

∉⇒≢ : ∀ {xs : List (List Char)} {x y : List Char}
  → x ∈ xs → y ∉ xs → x ≢ y
\end{code}

\section{The $\lambda$-Calculus and System F}

\paragraph*{The $\lambda$-calculus.} The $\lambda$-calculus (pronounced
\textit{lambda calculus}), is a theoretical model of computation developed by
Alonzo Church in the 1930s (first described in \citet{church_set_1932}) and is
what System F is based upon. It looks and works similarly to familiar functional
programming languages, yet its definition is as minimal as possible while still
being Turing-complete\footnote{Although Turing machines would be invented after
the $\lambda$-calculus, `turing-complete' has become a shorthand for `universal
method of computation'. Such a universal method was not Church's initial goal,
but is why we're still interested in the $\lambda$-calculus.}. As described in
\cite{pierce_types_2002}, the most relevant results are summarised below.

We have the following familiar BNF grammar for any $\lambda$-calculus term $t$.

\begin{center}
\begin{bnf}
  $t$ ::=
  | $x$ : variables
  | $\lambda \, x. t$ : ($\lambda$)-abstractions
  | $t_1 t_2$ : function application
\end{bnf}
\end{center}

Function application is left-associative (so for all abstractions $f$, $f a b =
(f a) b$), and $\lambda$-abstractions extend as far as possible (e.g. $\lambda
f. f a b = \lambda f. (f a b)$).

The $\lambda$-calculus includes three reductions. $\alpha$-conversion is the
renaming of variables such that the semantics of the program are not changed;
terms which are semantically identical but use different variable bindings are
called $\alpha$-equivalent, and $\alpha$-equivalence is an equivalence-relation.
$\beta$-reduction is how functions are applied; for any term $t$, we write a
reduction as $t \mapsto_{\beta} t'$. For any function application $(\lambda \,
x. t) u$, we replace all occurrences of $x$ in $t$ with $u$. $\beta$-reduction
is a congruence, so if $t \mapsto_{\beta} t'$, then $st \mapsto_{\beta} st'$,
and $ts \mapsto_{\beta} t's$.

Finally, we have $\eta$-reduction; for all $\lambda$-abstractions $\lambda \, x.
f x$, we have that $\lambda \, x. f x \mapsto_{\eta} f$ (this is the idea of
function extensionality).

If further $\beta$-reducations do not simplify a term, we say that it is in its
\textit{normal form}. We shall represent an arbitrary number of successive
$\beta$-reductions as $\mapsto_{\beta^{\star}}$.

Lastly, the Church-Rosser theorem states that for any term $t$, if it
$\beta$-reduces to two terms $a$ and $b$, then there exists a common term $t'$
which both $a$ and $b$ eventually $\beta$-reduce to
\citep{church_properties_1936}.

Notably, some terms may not have a normal form. A famous example is
\textit{omega} (sometimes called the \textit{omega combinator}) defined as
$(\lambda \, x. (x x)) (\lambda \, x. (x x))$, which when applied to itself
doesn't reduce any further.

\begin{equation*}
  (\lambda \, x. (x x)) (\lambda \, x. (x x)) \quad \mapsto_{\beta} \quad (\lambda \, x. (x x)) (\lambda \, x. (x x))
\end{equation*}

Just the first $\lambda \, x. (x x)$ part on its own is called \textit{little
omega}. Another famous example is the fixpoint called the
\textit{y-combinator}\footnote{Defined as $\mathcal{Y} \triangleq (\lambda \, f.
(\lambda \, x. f (x x )) (\lambda \, x. f (xx)))$}. Given any argument, it will
$\beta$-reduce to the argument applied to itself.

We say that these terms \textit{do not have a normal form}.

\paragraph*{The simply-typed $\lambda$-calculus.} While not being
Turing-complete, the simply-typed $\lambda$-calculus (STLC for short and
sometimes given the symbol $\lambda^{\rightarrow}$) is an extension of the
untyped $\lambda$-calculus described above that was developed in
\citet{church_formulation_1940} which requires each term to have a
\textit{type}. Terms which do not have a normal form cannot be given a type. As
such, we only permit `nice' expressions, that is, all expressions will (after
successive $\beta$-reductions) result in an irreducible expression---their
normal form. This is also called \textit{strong normalisation}.
\citep{pierce_types_2002}

Since we can no longer represent all of the terms of the untyped
$\lambda$-calculus, the STLC is not Turing-complete. Nevertheless, the STLC is
still useful, since we can guarantee that any term which can be given a type
will have a normal form. Having a normal form is the $\lambda$-calculus
equivalent of a Turing machine encoding halting. The popular saying goes,
`well-typed programs can't go wrong!' \citep{milner_theory_1978}

The base types we will commonly be using are the booleans $\mathbb{B}$ and the
naturals $\nat$ (we could use just one, but using two will make the examples
easier to understand)\footnote{If we didn't include any base types, then our
computational model becomes \textit{degenerate} (that is, there are no terms).
This is because everything has to have a type, and if there are no types, then
nothing can exist.}. We shall call the set of base types $T$, so in our case, $T
= \{ \mathbb{B} , \nat \}$. The set of variables will be $V$. Our \textit{type
context} (also called \textit{type environment}) will be given the symbol
$\Gamma$, which is a map from variables to types $\Gamma \colon V \to T$
(alternatively, we can see it as a sequence indexed by variables $(T_v)_{v \in
V}$). We closely follow the syntax that is used by \citet{pierce_types_2002}.

In the STLC, we couldn't give a type to little omega, since we can't give a type
to both the argument and the argument applied to itself ($\lambda \, x  \colon ?
. x x \colon ??$). If our context contained the mapping $x \colon \nat$, then we
could write an function which applies its argument to $x$ like so,

\begin{equation*}
  x \colon \nat \in \Gamma \vdash (\lambda \, f \colon \nat \to \nat . f x) \colon \nat.
\end{equation*}

Crucially, if $x$ had type $\mathbb{B}$, we would fail to determine the type of
the function, and so we can guarantee that all permitted expressions `can't go
wrong' \citep{milner_theory_1978} (since untypable expresisons are disallowed).

This paper will build upon and borrow notation from the textbook
\textit{Programming Language Foundations in Agda}
\citep{wadler_programming_2022}, which includes an implementation of the STLC
and also serves as further background.

\paragraph*{System F.} System F has been the formal background to what many modern programming
languages call \textit{generics}. For example, in Rust, we could write a function which applies a
function twice to an argument.

\begin{minted}[samepage]{rust}
fn twice<A, F>(f: F, x: A) -> A
where
    F: Fn(A) -> A,
{
    f(f(x))
}
\end{minted}

Since we used a \textit{type parameter} in the function's type signature, in this case called
\texttt{T}, we can supply any appropriate function which has the type signature $T \to T$. One such
function is \texttt{u64::isqrt}, the (flooring) square root function. If this function was invoked
with \texttt{twice(u64::isqrt, 81)}, its output would be \texttt{3}. In this case, the compiler is
clever enough to infer that the type for \texttt{A} should be \texttt{u64}, so we don't need to
specify it manually.

System F is the STLC equipped with \textit{polymorphic types}, another term for type parameters. It
was independently discovered by Jean-Yves  and John (who gave it the more straight-forward name,
\textit{the polymorphic
$\lambda$-calulus}). We can write this \textit{twice} function like so in System F:

\begin{equation*}
  \Lambda \, T. \lambda \, f \colon T \to T . \lambda \, x \colon T . f (f x) \colon \forall T . (T \to T) \to T \to T.
\end{equation*}

If we wanted to use this function and be explicit about what type we're using, we could instantiate
it with a specific type, notated using [square brackets]. For instance,

\begin{align*}
  s \colon \nat \to \nat, z \colon \nat \in \Gamma \vdash &(\Lambda \, T. \lambda \, f \colon T \to T . \lambda \, x \colon T . f (f x))[\nat] s z \colon \nat\\
  &\mapsto_{\beta} (\lambda \, f \colon \nat \to \nat . \lambda \, x \colon \nat . f (f x)) s z \colon \nat\\
  &\mapsto_{\beta^{\star}} s s z \colon \nat.
\end{align*}

When trying to formalise System F, we will face a choice of using an
intrinsically- or extrinsically-typed approach; although these were first
described by Alonzo Church and Haskell Curry respectively, we will use the
former two terms. The different approaches are described in detail in
\citet{gries_what_2003}, but to summarise, an intrinsic approach will define the
types of terms before the terms themselves, whereas an extrinsic approach will
define terms first (without types), and only later justify that the type system
is consistent.

Using the intrinsic approach will require less code and effort, so we shall
proceed that way.

\section{De Bruijn indices and Locally Nameless Sets}

Suppose we had the following expression,

\begin{equation*}
  x \colon \nat \in \Gamma \vdash \lambda \, y \colon \nat \to \nat. y x \colon \nat.
\end{equation*}

This takes in a function $y$ and applies it to the $x$ that is in the context.
Now suppose we move this expression into a context where we already have a bound
$y$.

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \, y \colon \nat \to \nat. y x \colon \nat.
\end{equation*}

It's unclear whether we are referring to the local $y$ or the previously bound
$y$ that is in our context (if we were to use actual functions on the naturals,
then we could have a real problem if the outer $y$ is the squaring function and
the inner $y$ the successor function, for instance). We can use an
$\alpha$-conversion and resolve this issue. We shall apply the conversion $y
\mapsto_{\alpha} q$ to our inner expression,

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \, q \colon \nat \to \nat. q x \colon \nat,
\end{equation*}

which solves our problem. We can add further assumptions to our context without
affecting the semantics of the expression (for example, adding $k \colon \nat$
to $\Gamma$ won't change the semantics of the expression), this is called
weakening-invariance (taken from proof theory, where extra assumptions make a
theorem weaker).

Since we have these $\alpha$-equivalent expressions, we can say that we have
\textit{quotient} inductive definitions \citep{aydemir_engineering_2008}, since
we have both an inductive definition of the $\lambda$-calculus, but also
(infinitely) many $\alpha$-equivalence classes which we need to deal
with\footnote{The name \textit{quotient} is taken from other areas of
mathematics where equivalence classes produce quotient objects. For example, in
ring theory, for a ring $R$ and ideal $I \subseteq R$, the quotient ring $R/I$
is the set of equivalence classes where for all $a, b \in R$ we have the
relation $a \sim b \iff a - b \in I$. If we let $R = \integer$ and $I =
2\integer$, the relation is $a \sim b \iff a - b \in 2\integer \iff \text{they
have the same parity}$. The quotient ring $R/I$ is just the set $\{0, 1\}$. In
our case, the relation is $a \sim b \iff a =_{\alpha} b$, and our quotient
becomes the set of possible terms which are semantically distinct}. This becomes
difficult in Agda, since Agda primarily relies on inductive definitions
\citep{pitts_locally_2023}.

We can solve this by using \textit{De Bruijn indices}. Using these ensures that
no matter what variables we have in our context, we don't have any local
variable names which could cause issues (since we only use indices that directly
reference the scope). In our example,

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \nat \to \nat. 0 2 \colon \nat.
\end{equation*}

We can't use any $\alpha$-conversions since each bound variable is indexed by a
(unique) natural number. However, if we were to change the context, we would
need to change the index too. So we have a purely inductive definition. For
example, if we remove the $y$,

\begin{equation*}
  x \colon \nat, \in \Gamma \vdash \lambda \nat \to \nat. 0 1 \colon \nat,
\end{equation*}

then we need to reindex the $2$ to a $1$. We have lost weakening invariance
\citep{aydemir_engineering_2008}.

Using \textit{locally nameless sets}, we can get both purely inductive
definitions \textit{and} weakening-invariance. Free variables will use variable
names while bound variables will use indices. Our example becomes

\begin{align*}
  x \colon \nat, \in \Gamma &\vdash \lambda \nat \to \nat. 0 x \colon \nat,\quad \text{or with another variable in the context,}\\
  x \colon \nat, y \colon \nat \to \nat \in \Gamma &\vdash \lambda \nat \to \nat. 0 x \colon \nat.
\end{align*}

This approach has been of research interest as of late \citep{aydemir_engineering_2008}
\citep{chargueraud_locally_2012}. As part of using locally nameless terms, common operations (called
`infrastructure' by ) need to be defined for the language used as part of the metatheory. A recent
article by explores locally nameless sets in Agda, and proves that this infrastructure can be
defined in a syntax-agnostic way. This will form part of the basis of our approach to implementing
System F in Agda.

\section{Evaluation strategy}
\label{section:evaluation_strategy}
There are several ways of evaluating the $\lambda$-calculus. The main question is whether to treat
$\lambda$-abstractions as values, or to reduce these if they are a redex.

The idea of reducible expressions, called a \textit{redex}, was introduced by Church
\citet[p.~56]{pierce_types_2002}. We refer to any expression of the form $(\lambda x. M) N$ as a
redex, since we can perform a $\beta$-reduction.

When evaluating, we need to consider some terms to be \textit{values}. These cannot be reduced any
further. One method is to consider $\lambda$-abstractions to be values and to only evaluated
\textit{closed} terms, that is, terms without any free variables. This is called weak-head
reduction, and the values are called weak-head normal forms \citep{wadler_programming_2022}. This
method is also used by popular programming languages such as Haskell \citep{hutchison_sharing_2005}.
The definition of $\lambda$-calculus as Church first described it uses what is nowadays referred to
as full normalisation \citep{wadler_programming_2022}. The reduction rule which is missing in
weak-head reduction is often called $\zeta$, or \textit{reducing under a $\lambda$-abstraction}, and
can be written like so \citep{hutchison_sharing_2005}, for some terms $M$ and $N$.
\begin{equation*}
\inferrule
  {M \to N}
  {\lambda x. M \to \lambda x. N}
\end{equation*}

One of the early explorations of weak-head reduction was made by \citet{cagman_combinatory_1998},
comparing it to combinatory logic. They presented the necessity of another reduction rule. Since
evaluation stops at $\lambda$-abstractions, the Church-Rosser property no longer applies (and, in
fact, the system is no longer Turing complete). While one could introduce specific rules when one
can reduce under a $\lambda$-abstraction to restore this property \citep{hutchison_sharing_2005},
another, simpler, method is to introduce primitives \citep{wadler_programming_2022}. These
primitives are a small subset of Scott and Plotkin's Programming Computable Functions (PCF)
\citep{plotkin_lcf_1977}, described in section \ref{section:stlc_terms}.

\section{Cofinite Quantification}

Often, we may want to prove a property for \textit{almost} all members of a set, where we exclude a
finite subset. For example, for \textit{almost} all natural numbers $n$, $n \geq 2$. Or in number
theory, \textit{almost} all natural numbers can be written as a product of primes. To prove this,
one would need to give a set of numbers which the proof will ignore (in the example, $\{ (0), 1
\}$), and then prove it for all $n \in \nat$ with the extra assumption that $n \not \in \{0, 1\}$.
Practically, this is never done, since we usually want the exceptions explicitly in the proof. But
this special pattern proves useful.

In several papers on the locally nameless representation, \textit{cofinite} quantification is
discussed. This is exactly what we would understand as `for almost all'.

While the Agda implementation that Pitts gave [TODO cite] uses an arbitrary set, I chose to use the
specific \texttt{List Char}, since we will only quantify over strings.

\begin{code}
record Cof (P : List Char → Set) : Set where
  inductive
  eta-equality
  constructor И⟨_,_⟩
  field
    Иe₁ : List (List Char)
    Иe₂ : (a : List Char) {_ : a ∉ Иe₁} → P a
open Cof
syntax Cof (λ a → P) = И a , P
\end{code}

For a simple example, I can show \textit{almost} all strings have a length greater or equal to $1$
(with the exception being the empty string).

\begin{code}
simple-cof : {s : String} → И s , (1 ≤ length s)
simple-cof = И⟨ [] ∷ [] , (
  λ{[] {a∉}  → contradiction refl (∉∷[]⇒≢ a∉)
  ; (x ∷ xs) → s≤s z≤n}) ⟩
\end{code}

\section{Prior research}
System F was previously formalised in Agda by \citet{hutton_system_2019}. However, the authors of
that paper formalised a variant of System F with language extensions known as \textit{System
F$_{\omega \mu}$}. They also used a different approach, opting to make use of De Bruijn indices.
This paper will use the locally nameless representation, which hasn't been used for System F in Agda
before.

\section{Syntax and basic theorems of STLC}
I have previously submitted some work on STLC using locally nameless representation for a university
course called \textit{Types and Semantics of Programming Languages} [TODO: Cite DRPS]. I will
present my prior work in this subsection. Some functions which were submitted are presented without their
function bodies and are instead included in appendix A [TODO: appendix]. Any new additions are in
the next chapter.

\subsection{Creating new strings}
We will use \texttt{List Char} rather than the built-in \texttt{String} type, since it's easier to
reason with lists. The \texttt{String} type is opaque in Agda, and reasoning about length and other
properties of \texttt{String} is more difficult than if we just used \texttt{List Char}. To generate
arbitrary strings, we'll provide functions for \texttt{List A} for some set \texttt{A} and then use
the specific where \texttt{A} is \texttt{Char}. The `toList` function for `String` (which I have
renamed to \texttt{⟪\_⟫}) can be used to convert from a \texttt{String}.

\begin{code}
new-list : ∀ {A : Set} → A → List (List A) → List A
new-list a xss = a ∷ replicate (max 0 (map length xss)) a

fresh : List (List Char) → List Char
fresh xss = new-list 'q' xss
\end{code}

We can create a new string by finding the longest string and creating a string which is one
character longer. Now to prove that this function is correct:

\begin{code}

new-list-correct : ∀ {A : Set} (xss : List (List A)) (a : A)
  → ¬ Any ((new-list a xss) ≡_) xss
-- Function body in appendix.

fresh-correct : (xss : List (List Char)) → (fresh xss) ∉ xss
fresh-correct xss = new-list-correct xss 'q'
\end{code}

\subsection{Terms and their operations}
\label{section:stlc_terms}
Since we will need to have quite a few proofs on local closure, we should define our terms.
\begin{code}
data Term : Set where
  free_  : List Char → Term
  bound_ : ℕ → Term
  ƛ_     : Term → Term
  _·_    : Term → Term → Term
  ‵zero  : Term
  ‵suc_  : Term → Term

ƛ-inj : ∀{t t'} → ƛ t ≡ ƛ t' → t ≡ t'
ƛ-inj refl = refl

·-inj : {t₁ t₂ t₁' t₂' : Term}
  → t₁ · t₂ ≡ t₁' · t₂'
    -----------------------
  → (t₁ ≡ t₁') × (t₂ ≡ t₂')
·-inj refl = ⟨ refl , refl ⟩

‵suc-inj : {t₁ t₂ : Term}
  → ‵suc t₁ ≡ ‵suc t₂
    -------------
  → t₁ ≡ t₂
‵suc-inj refl = refl
\end{code}

We have free and bound variables, $\lambda$-abstractions, and applications (written explicitly with
a $\cdot$). Later when doing evaluation, we will only implement weak-head normalisation, so we also
need to include two primitives \texttt{‵zero} and \texttt{‵suc}, as explained in
\ref{section:evaluation_strategy}. To avoid name conflicts with the Agda built-in natural number
keywords, a small \texttt{‵} symbol is used, following what is done in
\citet{wadler_programming_2022}. We also exploit the injectivity of terms to help in proofs later.

\paragraph*{Opening and closing.} Two important operations in the locally nameless representation are
opening and closing terms. This is when an index is replaced with a free variable, and when a free
variable is replaced with an index. We write these as $[k \to x] M$ and $[k \leftarrow x] M$
respectively, for some $k \in \nat$, $x \in \texttt{List Char}$, and $M \in \texttt{Terms}$. These
can be defined recursively.
\begin{code}
[_—→_]_ : ℕ → List Char → Term → Term
[ k —→ x ] (free y) = free y
[ k —→ x ] (bound i) with k ≟ℕ i
... | yes _ = free x
... | no  _ = bound i
[ k —→ x ] (ƛ t) = ƛ ([ suc k —→ x ] t)
[ k —→ x ] (t₁ · t₂) = [ k —→ x ] t₁ · [ k —→ x ] t₂
[ k —→ x ] ‵zero = ‵zero
[ k —→ x ] ‵suc t = ‵suc ([ k —→ x ] t)

[_←—_]_ : ℕ → List Char → Term → Term
[ k ←— x ] (free y) with x ≟lchar y
... | yes _ = bound k
... | no  _ = free y
[ k ←— x ] (bound i) = bound i
[ k ←— x ] (ƛ t) = ƛ [ suc k ←— x ] t
[ k ←— x ] (t₁ · t₂) = [ k ←— x ] t₁ · [ k ←— x ] t₂
[ k ←— x ] ‵zero = ‵zero
[ k ←— x ] ‵suc t = ‵suc ([ k ←— x ] t)
\end{code}
We take advantage of Agda's ability to use mixfix operators to make the opening and closing
operations look like the notation used in the prose.

\citet{pitts_locally_2023} shows that nine axioms need to be fulfilled for a set to be considered a
locally nameless set. For our terms we only need three: axioms 1, 2, and 5. As before, the function
bodies are provided in appendix A [TODO: Appendix].
\begin{code}
ax1 : ∀ (i : ℕ) (a b : List Char) (t : Term)
  → [ i —→ a ] ([ i —→ b ] t) ≡ [ i —→ b ] t

ax1-cor : ∀ (i k : ℕ) (a : List Char) (t : Term)
  → i ≡ k
  → [ k —→ a ] ([ i —→ a ] t) ≡ [ i —→ a ] t

ax2 : ∀ (i j : ℕ) (x : List Char) (t : Term)
  → [ i ←— x ] ([ j ←— x ] t) ≡ [ j ←— x ] t

ax5 : ∀ (i j : ℕ) (a b : List Char) (t : Term)
  → (i≢j : i ≢ j)
  → [ i —→ a ] ([ j —→ b ] t) ≡ [ j —→ b ] ([ i —→ a ] t)
\end{code}

\subsection{Fresh variables}
Fresh variables are those whose identifier (i.e. \texttt{List Char}) hasn't already been used for
any free variables in a term. We will exploit this when proving properties of substitution. Free
variables can be collected recursively.
\begin{code}
fv : Term → List (List Char)
fv (free x) = x ∷ []
fv (bound i) = []
fv (ƛ t) = fv t
fv (t₁ · t₂) = fv t₁ ++ fv t₂
fv ‵zero = []
fv (‵suc t) = fv t
\end{code}

A variable is also fresh if a term remains unchanged after it is closed at index $0$ using the
variable. This definition and the previous one imply each other.
\begin{code}
_#_ : List Char → Term → Set
x # t = [ 0 ←— x ] t ≡ t

#⇒∉fv : ∀ (x : List Char) (t : Term) → x # t → x ∉ fv t

∉fv⇒# : ∀ (x : List Char) (t : Term) → x ∉ fv t → x # t

-- Some more helper functions for later.
#-ƛ : ∀ {x : List Char} (t : Term)
  → x # (ƛ t)
    -------
  → x # t

#-· : ∀ {x : List Char} (t₁ t₂ : Term)
  → x # (t₁ · t₂)
    ---------------
  → x # t₁ × x # t₂

#-‵suc : ∀ {x : List Char} (t : Term)
  → x # (‵suc t)
    -------
  → x # t
\end{code}

\subsection{Local Closure}
A term is said to be \textit{locally closed} up to level $i$ if it remains unchanged after opening
it at index $i$ with a string. We write (for some $i \in \nat$ and term $M$),
\begin{equation*}
  i \succ M \triangleq \forall j \geq i, \; \cof a , \; [j \to a] M = M.  
\end{equation*}
If it is locally closed at level $0$, we simply call it \textit{locally closed}. As mentioned in \citet{pitts_locally_2023}, the predicate that \citet{chargueraud_locally_2012} calls `body' is equivalent to $1 \succ M$ for some term $M$.

\begin{code}
_≻_ : ℕ → Term → Set
i ≻ t = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , ([ j —→ a ] t ≡ t)

LocallyClosed_ : Term → Set
LocallyClosed t = 0 ≻ t
\end{code}

We can show some interesting lemmas which will also be needed later. These are named after the lemma
number used in \citet{pitts_locally_2023}.
\begin{code}
lemma2·6 : ∀ {i j : ℕ} {t : Term}
  → j ≥ i
  → i ≻ t
    -----
  → j ≻ t
lemma2·6 {i} {j} {t} j≥i i≻t k = i≻t k ⦃ ≤-trans j≥i it ⦄

≻⇒s≻ : ∀ {i : ℕ} {t : Term}
  → i ≻ t
    -----
  → (suc i) ≻ t
≻⇒s≻ {i} i≻t = lemma2·6 (n≤1+n i) i≻t

lemma2·7-1 : ∀ {i : ℕ} {x y : List Char} {t : Term}
  → [ i —→ x ] t ≡ t
    ----------------
  → [ i —→ y ] t ≡ t

lemma2·7-2 : ∀ {i j : ℕ} {x : List Char} {t : Term}
  → j ≥ i
  → i ≻ t
    ----------------
  → [ j —→ x ] t ≡ t

open-rec-lc : ∀ {t : Term} {i : ℕ} {x : List Char}
  → LocallyClosed t
    ----------------
  → [ i —→ x ] t ≡ t
open-rec-lc lc-t = lemma2·7-2 z≤n lc-t

open-rec-lc-lemma : ∀ {t : Term} {i j : ℕ} {u v : List Char}
  → i ≢ j
  → [ i —→ u ] ([ j —→ v ] t) ≡ [ j —→ v ] t
  → [ i —→ u ] t ≡ t

lemma2·13 : ∀ {t : Term} {a : List Char} {i : ℕ} (j : ℕ)
  → j ≥ i
  → i ≻ t
  → i ≻ ([ j —→ a ] t)
\end{code}

\citet{pitts_locally_2023} uses an existential quantification for this property instead of the
cofinite quantification I used. To show that these two are equivalent, we'll use a recursively
defined local closure predicate (as is done in \citet{chargueraud_locally_2012}). It's sufficient
for us to show an iff relation between the cofinite and recursive definitions, since
\citet{pitts_locally_2023} shows an iff relation between the existential and recursive definitions
(proposition 4.3); thus, we can prove that the two different quantification definitions imply each
other.

\begin{code}
data Lc-at : ℕ → Term → Set where
  lc-at-bound : ∀ {i j : ℕ} ⦃ _ : j < i ⦄ → Lc-at i (bound j)
  lc-at-free : ∀ {i : ℕ} {a : List Char} → Lc-at i (free a)
  lc-at-lam : ∀ {i : ℕ} {t : Term}
    → Lc-at (suc i) t
      ------------------
    → Lc-at i (ƛ t)
  lc-at-app : ∀ {i : ℕ} {t₁ t₂ : Term}
    → Lc-at i t₁
    → Lc-at i t₂
      -------------------
    → Lc-at i (t₁ · t₂)
  lc-at-‵zero : ∀ {i : ℕ} → Lc-at i ‵zero
  lc-at-‵suc : ∀ {i : ℕ} {t : Term}
    → Lc-at i t
      ------------------
    → Lc-at i (‵suc t)

≻⇒lc-at : ∀ (i : ℕ) (t : Term) → i ≻ t → Lc-at i t
lc-at⇒≻ : ∀ (i : ℕ) (t : Term) → Lc-at i t → i ≻ t
\end{code}

We can also use this recrusive definition to show some other properties of the locally closed syntax
which will be very convenient in the future.
\begin{code}
bound-never-lc : ∀ (n : ℕ) → ¬ LocallyClosed (bound n)
free-lc : ∀ {x : List Char} → LocallyClosed (free x)
i≻ƛt⇒si≻t : ∀ {i : ℕ} {t : Term} → i ≻ (ƛ t) → suc i ≻ t
·-≻ : ∀ {t₁ t₂ : Term} {i : ℕ} → i ≻ (t₁ · t₂) → (i ≻ t₁) × (i ≻ t₂)
‵zero-≻ : ∀ {i : ℕ} → i ≻ ‵zero
‵suc-≻ : ∀ {t : Term} {i : ℕ} → i ≻ (‵suc t) → i ≻ t
\end{code}

\subsection{Substitution of terms}
We can substitute terms for free variables with this recursive definition.
\begin{code}
[_:=_]_ : List Char → Term → Term → Term
[ x := u ] (free y) with x ≟lchar y
... | yes _ = u
... | no  _ = free y
[ x := u ] (bound i) = bound i
[ x := u ] (ƛ t) = ƛ [ x := u ] t
[ x := u ] (t₁ · t₂) = [ x := u ] t₁ · [ x := u ] t₂
[ x := u ] (‵zero) = ‵zero
[ x := u ] (‵suc t) = ‵suc ([ x := u ] t)
\end{code}

While there are many interesting properties of substitution (and a few are omitted here and left in
the appendix in section \ref{appendix:substitution_proofs}), we only need this one which shows how
substitution interacts with term opening. It is named following what it's called in
\citet{chargueraud_locally_2012}.
\begin{code}
subst-open-var : ∀ {u : Term} {x y : List Char} {i : ℕ} (t : Term)
  → x ≢ y
  → i ≻ u
  → [ x := u ] ([ i —→ y ] t) ≡ [ i —→ y ] ([ x := u ] t)

subst-open-lc : ∀ {t u : Term} {x y : List Char}
  → x ≢ y
  → LocallyClosed u
  → [ x := u ] ([ 0 —→ y ] t) ≡ [ 0 —→ y ] ([ x := u ] t)
\end{code}

\subsection{Typing}
\label{section:typing_stlc}
\paragraph*{Types and contexts.} We will use \texttt{‵ℕ} as the base type to work together with the
\texttt{‵zero} and \texttt{‵suc} primitives. Other than the base type, we also have function (arrow)
types. We will closely follow what is done in \citet{wadler_programming_2022}.
\begin{code}
data Type : Set where
  ‵ℕ : Type
  _⇒_ : Type → Type → Type

data Context : Set where
  ∅ : Context
  _,_⦂_ : Context → List Char → Type → Context
\end{code}

\citet{aydemir_engineering_2008} and \citet{chargueraud_locally_2012} include a predicate to tell
when a context is `ok', that is, that there are no duplicate names. Instead of worrying about
keeping track of the strings in the context, we can use `shadowing' (always using the latest
matching variable in the context).

To access the context, we can use these accessors. We use H and T to mirror the \texttt{List.Any}
construct's `here' and `there'.
\begin{code}
data _∋_⦂_ : Context → List Char → Type → Set where
  H : ∀ {Γ x y A}
    → x ≡ y
      ------------------
    → Γ , x ⦂ A ∋ y ⦂ A

  T : ∀ {Γ x y A B}
    → x ≢ y
    → Γ ∋ x ⦂ A
      -----------------
    → Γ , y ⦂ B ∋ x ⦂ A
\end{code}

Like in \citet{wadler_programming_2022}, we can use some helper functions to try and use Agda's type
inference to find the required evidence itself.
\begin{code}
H′ : ∀ {Γ x A}
  → Γ , x ⦂ A ∋ x ⦂ A
H′ = H refl

T′ : ∀ {Γ x y A B}
   → {x≢y : False (x ≟lchar y)}
   → Γ ∋ x ⦂ A
     ------------------
   → Γ , y ⦂ B ∋ x ⦂ A
T′ {x≢y = x≢y} x = T (toWitnessFalse x≢y) x
\end{code}

We need to have a function to get all the variables in the context.
\begin{code}
domain : Context → List (List Char)
domain ∅ = []
domain (Γ , x ⦂ A) = x ∷ domain Γ
\end{code}

\paragraph*{Type judgements.} The type judgements are the same as in
\citet[chapter~Lambda]{wadler_programming_2022}, so we won't go into much detail here. The one
difference is how we define $\lambda$-abstraction, where we use a cofinite quantifier.

In \citet[chapter~Lambda]{wadler_programming_2022}, $\lambda$-abstractions are handled as follows:
the bound variable is added to the context and the expression is typechecked with the bound variable
now treated as if it were free. Here, we open the term to replace it with a free variable (and then
we add this free variable to the context). Thus, we need to find a \texttt{List Char} which isn't in
the context yet, otherwise we would shadow a previous variable with the same identifier. Since bound
variables become free, we don't have a typing judgement for bound variables.
\begin{code}
data _⊢_⦂_ : Context → Term → Type → Set where
  ⊢free : ∀ {Γ x A}
    → Γ ∋ x ⦂ A
      ---------
    → Γ ⊢ free x ⦂ A

  ⊢ƛ : ∀ {Γ t A B}
    → И x , ((Γ , x ⦂ A) ⊢ [ 0 —→ x ] t ⦂ B)
      ---------------------------
    → Γ ⊢ ƛ t ⦂ (A ⇒ B)

  ⊢· : ∀ {Γ t₁ t₂ A B}
    → Γ ⊢ t₁ ⦂ (A ⇒ B)
    → Γ ⊢ t₂ ⦂ A
      ---------
    → Γ ⊢ t₁ · t₂ ⦂ B

  ⊢zero : ∀ {Γ}
      -------
    → Γ ⊢ ‵zero ⦂ ‵ℕ

  ⊢suc : ∀ {Γ t}
    → Γ ⊢ t ⦂ ‵ℕ
      ----------------
    → Γ ⊢ ‵suc t ⦂ ‵ℕ

-- Apply term-equality within type judgements.
≡-with-⊢ : ∀ {Γ t u A}
  → Γ ⊢ t ⦂ A
  → t ≡ u
    ----------
  → Γ ⊢ u ⦂ A
≡-with-⊢ ⊢t refl = ⊢t
\end{code}

As a consequence of these type judgements, only locally closed terms are well-typed. As before, the
proof is in section \ref{appendix:types_proofs}.
\begin{code}
⊢⇒lc : ∀ {Γ t A} → Γ ⊢ t ⦂ A → LocallyClosed t
\end{code}

Using the type judgements, we can show that these two terms are well-typed. Using more familiar
notation, we would write this as $x \colon \nat \vdash (\lambda \colon \nat \to \nat. 0x) \colon \nat$
and $\vdash (\lambda \colon \nat. \lambda \colon \nat \to \nat. 01) \colon \nat \to (\nat
\to \nat) \to \nat$ respectively, or using only the named representation, $x \colon \nat \vdash
(\lambda a \colon \nat \to \nat. ax) \colon \nat$ and $\vdash (\lambda x \colon \nat. \lambda
f \colon \nat \to \nat. fx) \colon \nat \to (\nat \to \nat) \to \nat$.
\begin{code}
_ : (∅ , ⟪ "x" ⟫ ⦂ ‵ℕ) ⊢ (ƛ (bound 0)) · (free ⟪ "x" ⟫) ⦂ ‵ℕ
_ = ⊢· (⊢ƛ И⟨ ⟪ "x" ⟫ ∷ [] , (λ a → ⊢free H′) ⟩) (⊢free H′)

ex-for-all-contexts : ∀ {Γ} → Γ ⊢ ƛ ƛ (bound 0) · (bound 1) ⦂ (‵ℕ ⇒ (‵ℕ ⇒ ‵ℕ) ⇒ ‵ℕ)
ex-for-all-contexts {Γ} = ⊢ƛ (
  И⟨ [] , (λ a → ⊢ƛ (
    И⟨ a ∷ []
    , (λ b {b∉} → ⊢· (⊢free (H′)) (⊢free (T (∉⇒≢ (here refl) b∉) H′))) ⟩ )) ⟩)
\end{code}

\subsection{Typing properties}
Since the type judgements are very similar to those in named simply typed lambda calculus,
we have many of the same properties as in \citet[chapter~Lambda]{wadler_programming_2022}.
\begin{code}
-- Extending contexts.
ext : ∀ {Γ Δ}
  → (∀ {x A}     →         Γ ∋ x ⦂ A →         Δ ∋ x ⦂ A)
  → (∀ {x y A B} → Γ , y ⦂ B ∋ x ⦂ A → Δ , y ⦂ B ∋ x ⦂ A)

-- Renaming (aka. "rebasing") of contexts.
rename : ∀ {Γ Δ}
  → (∀ {x A} → Γ ∋ x ⦂ A → Δ ∋ x ⦂ A)
  → (∀ {M A} → Γ ⊢ M ⦂ A → Δ ⊢ M ⦂ A)

-- Weakening of contexts.
weaken : ∀ {Γ t A}
  → ∅ ⊢ t ⦂ A
  → Γ ⊢ t ⦂ A
weaken {Γ} ⊢A = rename (λ ()) ⊢A

-- Swapping variables in a context.
swap : ∀ {Γ x y t A B C}
  → x ≢ y
  → Γ , y ⦂ B , x ⦂ A ⊢ t ⦂ C
  → Γ , x ⦂ A , y ⦂ B ⊢ t ⦂ C

-- Dropping shadowed variables.
drop : ∀ {Γ x M A B C}
  → Γ , x ⦂ A , x ⦂ B ⊢ M ⦂ C
  → Γ , x ⦂ B ⊢ M ⦂ C

-- subst-open-var adapted to work with judgements.
subst-open-context : ∀ {Γ A} {t u : Term} {x y : List Char}
  → x ≢ y
  → LocallyClosed u
  → Γ ⊢ [ x := u ] ([ 0 —→ y ] t) ⦂ A
  → Γ ⊢ [ 0 —→ y ] ([ x := u ] t) ⦂ A
\end{code}

\chapter{Substitution and Evaluation in STLC}
The remaining properties of STLC, including creating an evaluator, were missing from my submission
to TSPL. Since it is a necessary prelude to System F, this new work is presented here. As explained
in section \ref{section:evaluation_strategy}, one evaluation strategy is weak-head reduction. We
follow the methods presented in \citet[chapter~Properties]{wadler_programming_2022} and
\citet[section~5]{chargueraud_locally_2012}, as they have also used weak-head reduction. Thus,
evaluation will be restricted to closed terms only (those without free variables).

\section{Substitution}
We need to show that substituting preserves types. As mentioned, we restrict ourselves to only
substituting closed terms.
\begin{code}
{-# TERMINATING #-}
subst : ∀ {Γ x t u A B}
  → ∅ ⊢ u ⦂ A
  → Γ , x ⦂ A ⊢ t ⦂ B
    --------------------
  → Γ ⊢ [ x := u ] t ⦂ B
subst {x = y} ⊢u (⊢free {x = x} (H refl)) with y ≟lchar y
... | yes _   = weaken ⊢u
... | no  y≢y = contradiction refl y≢y
subst {x = y} ⊢u (⊢free {x = x} (T x≢y ∋x)) with y ≟lchar x
... | yes y≡x = contradiction (sym y≡x) x≢y
... | no  _   = ⊢free ∋x
subst {x = x} {t = ƛ t} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
  ⊢ƛ И⟨ x ∷ Иe₁
      , (λ a {a∉} →
        let a≢y   = ∉∷[]⇒≢ (proj₁ (∉-++ a∉))
            a∉Иe₁ = proj₂ (∉-++ a∉)
        in subst-open-context
          {t = t}
          (sym-≢ a≢y)
          (⊢⇒lc ⊢u)
          (subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))) )
      ⟩
subst ⊢u (⊢· ⊢t₁ ⊢t₂) = ⊢· (subst ⊢u ⊢t₁) (subst ⊢u ⊢t₂)
subst ⊢u ⊢zero = ⊢zero
subst ⊢u (⊢suc ⊢t) = ⊢suc (subst ⊢u ⊢t)
\end{code}

The property is proven by induction on the type judgement of the term \texttt{M}. Agda cannot
determine the termination of this function, and the problematic call is when the type judgement is a
$\lambda$-abstraction \texttt{ƛ M}. Specifically, it highlights the problematic code to be
\texttt{subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))}. Thus, I will only detail that step (technically, Agda
also complains about a problematic call for the application case, but this is caused by the
problematic $\lambda$-abstraction case).

Since we are inducting on the type judgement, the inductive hypothesis for a term \texttt{ƛ M} of
type \texttt{A ⇒ A'} states that the property $P$ holds for $P(\texttt{И⟨ Иe₁ , Иe₂ ⟩})$. Let
\texttt{b} be an appropriate \texttt{List Char} to supply to \texttt{Иe₂}, then it will return a
proof that \texttt{Γ , x ⦂ A , b ⦂ A' ⊢ [ 0 —→ b ] t ⦂ B}. In this case, the \texttt{subst} function
is called on \texttt{Иe₂} (with a \texttt{swap} function applied, but since this function doesn't
call \texttt{subst} and only operates on the context, this call is irrelevant to this termination
issue). Since we are deconstructing the type judgement and are calling \texttt{subst} on the term
\texttt{Иe₂} which makes up the input type judgement, this function call corresponds to the
inductive hypothesis, and is thus valid.

Substituting a term for an index is similar to the definition of the other substitution. This is,
confusingly, also called `opening' by \citet{chargueraud_locally_2012}.
\begin{code}
[_:→_]_ : ℕ → Term → Term → Term
[ k :→ u ] (free x) = free x
[ k :→ u ] (bound i) with k ≟ℕ i
... | yes _ = u
... | no  _ = bound i
[ k :→ u ] (ƛ t) = ƛ [ (suc k) :→ u ] t
[ k :→ u ] (t₁ · t₂) = [ k :→ u ] t₁ · [ k :→ u ] t₂
[ k :→ u ] ‵zero = ‵zero
[ k :→ u ] (‵suc t) = ‵suc ([ k :→ u ] t)
\end{code}

Using an index $i$ to open with $x \in \texttt{List Char}$ is the same as using the index
substitution with the term \texttt{free $x$}.
\begin{code}
—→≡:→free : ∀ {i : ℕ} {x : List Char} (t : Term)
  → [ i —→ x ] t ≡ [ i :→ free x ] t
—→≡:→free {i} {x} (free y) = refl
—→≡:→free {i} {x} (bound k) with i ≟ℕ k
... | yes _ = refl
... | no  _ = refl
—→≡:→free {i} {x} (ƛ t) = cong ƛ_ (—→≡:→free t)
—→≡:→free {i} {x} (t₁ · t₂) =
  cong₂ _·_ (—→≡:→free t₁) (—→≡:→free t₂)
—→≡:→free {i} {x} ‵zero = refl
—→≡:→free {i} {x} (‵suc t) = cong ‵suc_ (—→≡:→free t)
\end{code}

There are quite a few more properties of index substitution which \citet{chargueraud_locally_2012}
proves, but the only relevant one for evaluation is \texttt{subst-intro}. It proves that
substituting a term for an index is the same as first opening the term with an $x \in \texttt{List
Char}$ and then using the free variable substitution using this $x$.
\begin{code}
subst-intro : ∀ {x : List Char} {i : ℕ} (t u : Term)
  → x # t
  → [ i :→ u ] t ≡ [ x := u ] ([ i —→ x ] t)
subst-intro {x} (free y) u x#t with x ≟lchar y
... | yes refl with () ← x#t
... | no  x≢y  = refl
subst-intro {x} {i} (bound j) u x#t with i ≟ℕ j
... | no  i≢j  = refl
... | yes refl with x ≟lchar x
...   | yes refl = refl
...   | no  x≢x  = contradiction refl x≢x
subst-intro (ƛ t) u x#ƛt = cong ƛ_ (subst-intro t u (#-ƛ t x#ƛt))
subst-intro {x} (t₁ · t₂) u x#t =
  let ⟨ x#t₁ , x#t₂ ⟩ = #-· t₁ t₂ x#t in
    cong₂ _·_ (subst-intro t₁ u x#t₁) (subst-intro t₂ u x#t₂)
subst-intro ‵zero u x#t = refl
subst-intro (‵suc t) u x#st =
  cong ‵suc_ (subst-intro t u (#-‵suc t x#st))
\end{code}

Since we need to replace bound variables for free ones to perform a $\beta$-reduction, we should
prove that this substitution preserves types.
\begin{code}
subst-op : ∀ {Γ t u A B}
  → ∅ ⊢ u ⦂ A
  → Γ ⊢ ƛ t ⦂ A ⇒ B
    --------------------
  → Γ ⊢ [ 0 :→ u ] t ⦂ B
subst-op {t = t} {u = u} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
  let x                  = fresh (fv t ++ Иe₁)
      ⟨ x∉fv-t , x∉Иe₁ ⟩ = ∉-++ {xs = fv t} {ys = Иe₁}
                              (fresh-correct (fv t ++ Иe₁))
  in ≡-with-⊢ (subst ⊢u (Иe₂ x {x∉Иe₁}))
    (sym (subst-intro t u (∉fv⇒# x t (x∉fv-t))))
\end{code}

\section{Evaluation}
Using weak-head reduction, only $\lambda$-abstractions are values, together with the two primitives
that were introduced.
\begin{code}
data Value : Term → Set where
  V-ƛ : ∀ {t} → Value (ƛ t)
  V-zero : Value ‵zero
  V-suc : ∀ {t} → Value t → Value (‵suc t)
\end{code}

\citet{chargueraud_locally_2012} adds another requirement for $\lambda$-abstractions: $1 \succ M$,
or in other words, that $\lambda M$ is locally closed. However since we are only evaluating
well-typed terms, and all well-typed terms are locally closed (see section
\ref{section:typing_stlc}). So this requirement isn't necessary here.

\citet{chargueraud_locally_2012} gives rules for reduction using locally closed terms. These are
encoded in Agda below.
\begin{code}
data _—→_ : Term → Term → Set where
  ξ₁ : ∀ {t₁ t₁' t₂}
    → t₁ —→ t₁'
    → LocallyClosed t₂
      -------------------
    → t₁ · t₂ —→ t₁' · t₂

  ξ₂ : ∀ {t₁ t₂ t₂'}
    → t₂ —→ t₂'
      ---------
    → t₁ · t₂ —→ t₁ · t₂'

  ξ-suc : ∀ {t t'}
    → t —→ t'
      ------------------
    → ‵suc t —→ ‵suc t'

  β : ∀ {t u}
    → 1 ≻ t
    → Value u
      -------
    → (ƛ t) · u —→ [ 0 :→ u ] t
\end{code}
Once again, the requirements for local closure could be removed, but I decided to keep them to
follow the rules presented in \citet{chargueraud_locally_2012}.

Following \citet{wadler_programming_2022}, we define some convenience functions, namely, reflexive
and transitive closure properties which will help reason about taking a reduction step. These follow
similar syntax to how equality reasoning is written in the Agda standard library
\citep{the_agda_community_agda_2024}.
\begin{code}
infix  2 _—↠_
infix  1 begin'_
infixr 2 _—→⟨_⟩_
infix  3 _∎'

data _—↠_ : Term → Term → Set where
  _∎' : ∀ M
      ---------
    → M —↠ M

  step—→ : ∀ L {M N}
    → M —↠ N
    → L —→ M
      ---------
    → L —↠ N

pattern _—→⟨_⟩_ L L—→M M—↠N = step—→ L M—↠N L—→M

begin'_ : ∀ {M N}
  → M —↠ N
    ------
  → M —↠ N
begin' M—↠N = M—↠N
\end{code}

There are two important properties which are required to implement evaluation. Progress, that terms
can always take a step, or are a value and are thus finished reducing, is presented below.
\begin{code}
data Progress (t : Term) : Set where
  step : ∀ {t'}
    → t —→ t'
      ----------
    → Progress t

  done :
      Value t
      ----------
    → Progress t

progress : ∀ {t A}
  → ∅ ⊢ t ⦂ A
    ----------
  → Progress t
progress (⊢ƛ x) = done V-ƛ
progress (⊢· ⊢t₁ ⊢t₂) with progress ⊢t₁
... | step t₁→t₁' = step (ξ₁ t₁→t₁' (⊢⇒lc ⊢t₂))
... | done V-ƛ with progress ⊢t₂
...   | step t₂→t₂' = step (ξ₂ t₂→t₂')
...   | done val    = step (β (i≻ƛt⇒si≻t (⊢⇒lc ⊢t₁)) val)
progress ⊢zero = done V-zero
progress (⊢suc ⊢t) with progress ⊢t
... | step t→t' = step (ξ-suc t→t')
... | done val  = done (V-suc val)
\end{code}

And preservation, that types are preserved when reducing.
\begin{code}
preserve : ∀ {t t' A}
  → ∅ ⊢ t ⦂ A
  → t —→ t'
    ----------
  → ∅ ⊢ t' ⦂ A
preserve (⊢· ⊢t₁ ⊢t₂) (ξ₁ t→t' _) = ⊢· (preserve ⊢t₁ t→t') ⊢t₂
preserve (⊢· ⊢t₁ ⊢t₂) (ξ₂ t→t') = ⊢· ⊢t₁  (preserve ⊢t₂ t→t')
preserve (⊢· ⊢t₁ ⊢t₂) (β x x₁) = subst-op ⊢t₂ ⊢t₁
preserve (⊢suc ⊢t) (ξ-suc t→t') = ⊢suc (preserve ⊢t t→t')
\end{code}

While STLC is not Turing complete \cite{church_formulation_1940}, we don't need to worry about the
halting problem. Still, we could try to evaluate a program that is very, very long. Rather than
reasoning about whether we can evaluate all programs, we can simply define a record which limits
evaluation to a certain number of reduction steps. Then we can use the preserve and progress
properties to make an \texttt{eval} function.
\begin{code}
record Gas : Set where
  eta-equality
  constructor gas
  field
    amount : ℕ

data Finished (t : Term) : Set where
  done : Value t → Finished t
  out-of-gas : Finished t

data Steps (t : Term) : Set where
  steps : ∀ {t'} → t —↠ t' → Finished t' → Steps t

eval : ∀ {t A} → Gas → ∅ ⊢ t ⦂ A → Steps t
eval {t} (gas zero) ⊢t = steps (t ∎') out-of-gas
eval {t} (gas (suc n)) ⊢t with progress ⊢t
... | done V-t = steps (t ∎') (done V-t)
... | step {t'} t→t' with eval (gas n) (preserve ⊢t t→t')
...   | steps t'→u fin-u = steps (t —→⟨ t→t' ⟩ t'→u) fin-u
\end{code}

We provide an example for evaluation. First, we require a a type derivation for $2+2$. We would show
that it evaluates to $4$, but because the evaluation proof requires more than eleven thousand lines
of code, it is omitted. But we encourage the reader to try it out for themselves. The proofs of
\texttt{⊢two} and \texttt{⊢plus} are long and are placed in section instead.

\begin{code}
two : Term
two = ƛ ƛ bound 1 · (bound 1 · bound 0)

plus : Term
plus = ƛ ƛ ƛ ƛ bound 3 · bound 1 · (bound 2 · bound 1 · bound 0)

suc' : Term
suc' = ƛ ‵suc (bound 0)

⊢two : ∅ ⊢ two ⦂ (‵ℕ ⇒ ‵ℕ) ⇒ ‵ℕ ⇒ ‵ℕ

⊢plus : ∀ {Γ A} → Γ ⊢ plus ⦂
  ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A)

⊢suc' : ∀ {Γ} → Γ ⊢ suc' ⦂ ‵ℕ ⇒ ‵ℕ
⊢suc' = ⊢ƛ И⟨ [] , (λ _ → ⊢suc (⊢free H′)) ⟩

⊢2+2 : ∅ ⊢ plus · two · two · suc' · ‵zero ⦂ ‵ℕ
⊢2+2 = ⊢· (⊢· (⊢· (⊢· ⊢plus  ⊢two) ⊢two) ⊢suc') ⊢zero

-- Using Emacs, normalise "eval (gas 100) ⊢2+2" by pressing C-c C-n.
\end{code}

\chapter{System F}
TODO.

\chapter{Conclusions}

\section{Final Reminder}

The body of your dissertation, before the references and any appendices,
\emph{must} finish by page~40. The introduction, after preliminary material,
should have started on page~1.

You may not change the dissertation format (e.g., reduce the font size, change
the margins, or reduce the line spacing from the default single spacing). Be
careful if you copy-paste packages into your document preamble from elsewhere.
Some \LaTeX{} packages, such as \texttt{fullpage} or \texttt{savetrees}, change
the margins of your document. Do not include them!

Over-length or incorrectly-formatted dissertations will not be accepted and you
would have to modify your dissertation and resubmit. You cannot assume we will
check your submission before the final deadline and if it requires resubmission
after the deadline to conform to the page and style requirements you will be
subject to the usual late penalties based on your final submission time.

\bibliographystyle{plainnat}
\bibliography{dissertation}


% You may delete everything from \appendix up to \end{document} if you don't need it.
\appendix

\chapter{Miscellaneous Proofs}
\label{appendix:misc_proofs}

Since some of these functions were already declared above, it would be an error to declare them
again. I decided to include the type signatures anyway for clarity.

\section{PLFA adaption}

These functions are closely adapted from PLFA [TODO: cite].

\begin{code}
All-++ : ∀ {A : Set} {P : A → Set} (xs ys : List A)
  → All P (xs ++ ys)
    ---------------------
  → (All P xs × All P ys)
All-++ [] ys Pys = ⟨ All.[] , Pys ⟩
All-++ (x ∷ xs) ys (Px All.∷ Pxs++ys) with All-++ xs ys Pxs++ys
... | ⟨ Pxs , Pys ⟩ = ⟨ Px All.∷ Pxs , Pys ⟩

-- All¬⇒¬Any : ∀ {A : Set} {P : A → Set} {xs : List A}
--   → All (¬_ ∘ P) xs
--     ---------------
--   → (¬_ ∘ Any P) xs
All¬⇒¬Any {xs = x ∷ xs} (¬Px All.∷ All¬P) (here Px) = ¬Px Px
All¬⇒¬Any {xs = x ∷ xs} (¬Px All.∷ All¬P) (there Pxs) =
  All¬⇒¬Any {xs = xs} All¬P Pxs

-- ¬Any⇒All¬ : ∀ {A : Set} {P : A → Set} {xs : List A}
--   → (¬_ ∘ Any P) xs
--     ---------------
--   → All (¬_ ∘ P) xs
¬Any⇒All¬ {xs = []} ¬∘AnyP = All.[]
¬Any⇒All¬ {xs = (x ∷ xs)} ¬AnyP =
  (λ Px → ¬AnyP (here Px))
    All.∷ ¬Any⇒All¬ {xs = xs} (λ Pxs → ¬AnyP (there Pxs))

-- We have to use ¬Any⇒All¬ and its inverse because ∉ is an
-- alias for "¬ Any (_≡ x) xs".  So we have to go through
-- the process of converting to "All ¬" to apply the
-- "All-++" lemma.
-- ∉-++ : ∀ {s : List Char} {xs ys : List (List Char)}
--   → s ∉ xs ++ ys
--     --------------------
--   → (s ∉ xs) × (s ∉ ys)
∉-++ {s} {xs} {ys} s∉xs++ys =
  let ⟨ all¬xs , all¬ys ⟩ = All-++ xs ys (¬Any⇒All¬ s∉xs++ys) in
    ⟨ All¬⇒¬Any {xs = xs} all¬xs
    , All¬⇒¬Any {xs = ys} all¬ys ⟩

++-All : ∀ {A : Set} {P : A → Set} (xs ys : List A)
  → All P xs × All P ys
    -------------------
  → All P (xs ++ ys)
++-All [] ys ⟨ All.[] , Pys ⟩ = Pys
++-All (x ∷ xs) ys ⟨ Px All.∷ Pxs , Pys ⟩ =
  Px All.∷ ++-All xs ys ⟨ Pxs , Pys ⟩

-- ++-∉ : ∀ {s : List Char} {xs ys : List (List Char)}
--   → s ∉ xs
--   → s ∉ ys
--     -------------
--   → s ∉ xs ++ ys
++-∉ {_} {xs} {ys} s∉xs s∉ys = All¬⇒¬Any
  (++-All xs ys ⟨ (¬Any⇒All¬ s∉xs) , (¬Any⇒All¬ s∉ys) ⟩)
\end{code}

\section{Prior work submitted for TSPL}

\subsection{Functions on lists and creating strings}
\label{appendix:list_functions}
\begin{code}
All≤⇒<⇒All< : ∀ {n m : ℕ} (xs : List ℕ)
  → n < m
  → All (_≤ n) xs
    -------------
  → All (_< m) xs
All≤⇒<⇒All< [] n<m All.[] = All.[]
All≤⇒<⇒All< (x ∷ xs) n<m (x≤n All.∷ all≤) =
  ≤-<-trans x≤n n<m All.∷ All≤⇒<⇒All< xs n<m all≤

-- sym-≢ : ∀ {A : Set} {x y : A}
--   → x ≢ y
--     -----
--   → y ≢ x
sym-≢ x≢y y≡x = x≢y (sym y≡x)

≡⇒<s : ∀ {n m : ℕ} → n ≡ m → n < suc m
≡⇒<s {zero} {m} n≡m = s≤s z≤n
≡⇒<s {suc n} {suc m} sn≡sm = s≤s (≡⇒<s (suc-injective sn≡sm))

-- ∉⇒≢ : ∀ {xs : List (List Char)} {x y : List Char}
--   → x ∈ xs
--   → y ∉ xs
--     -------
--   → x ≢ y
∉⇒≢ {xs} x∈ y∉ refl = y∉ x∈

len≠⇒≠ : ∀ {A : Set} (xs ys : List A)
  → length xs ≢ length ys → xs ≢ ys
len≠⇒≠ xs ys len≢ =
  λ xs≡ys → contradiction (cong length xs≡ys) len≢

-- ∉∷[]⇒≢ : {x y : List Char}
--   → x ∉ y ∷ []
--     -----------
--   → x ≢ y
∉∷[]⇒≢ x∉ with ¬Any⇒All¬ x∉
... | px All.∷ All.[] = px

len-replicate : ∀ {A : Set} (n : ℕ) (a : A)
  → length (replicate n a) ≡ n
len-replicate zero a = refl
len-replicate (suc n) a = cong suc (len-replicate n a)

len-new-list : ∀ {A : Set} (a : A) (xss : List (List A))
  → max 0 (map length xss) < length (new-list a xss)
len-new-list a xss =
  ≡⇒<s (sym (len-replicate (max 0 (map length xss)) a))

-- new-list-correct :
--   ∀ {A : Set} (xss : List (List A)) (a : A)
--   → ¬ Any ((new-list a xss) ≡_) xss
new-list-correct xss a = All¬⇒¬Any (go xss a)
  where
    go : ∀ {A : Set} (xss : List (List A)) (a : A)
      → All ((new-list a xss) ≢_) xss
    go xs a =
      helper
        xs
        (new-list a xs)
        (All≤⇒<⇒All<
          (map length xs)
          (len-new-list a xs)
          (xs≤max 0 (map length xs)))
      where
        helper : ∀ {A : Set} (xss : List (List A)) (ys : List A)
          → All (_< length ys) (map length xss)
          → All (ys ≢_) xss
        helper [] ys All.[] = All.[]
        helper (xs ∷ xss) ys (lenxs<lenys All.∷ all<) =
          sym-≢ (len≠⇒≠ xs ys (<⇒≢ lenxs<lenys))
            All.∷ helper xss ys all<
\end{code}

\subsection{Locally nameless set axioms}
\begin{code}
-- ax1 : ∀ (i : ℕ) (a b : List Char) (t : Term)
--   → [ i —→ a ] ([ i —→ b ] t) ≡ [ i —→ b ] t
ax1 i a b (free x) = refl
ax1 i a b (bound k) with i ≟ℕ k
... | yes _   = refl
... | no  i≢k with i ≟ℕ k
...   | yes i≡k = contradiction i≡k i≢k
...   | no  _   = refl
ax1 i a b (ƛ t) rewrite ax1 (suc i) a b t = refl
ax1 i a b (t₁ · t₂) rewrite ax1 i a b t₁ | ax1 i a b t₂ = refl
ax1 i a b ‵zero = refl
ax1 i a b (‵suc t) rewrite ax1 i a b t = refl

-- ax1-cor : ∀ (i k : ℕ) (a : List Char) (t : Term)
--   → i ≡ k
--   → [ k —→ a ] ([ i —→ a ] t) ≡ [ i —→ a ] t
ax1-cor i .i a t refl = ax1 i a a t

-- ax2 : ∀ (i j : ℕ) (x : List Char) (t : Term)
--   → [ i ←— x ] ([ j ←— x ] t) ≡ [ j ←— x ] t
ax2 i j x (free y) with x ≟lchar y
... | yes refl = refl
... | no  x≢y with x ≟lchar y
...   | yes x≡y = contradiction x≡y x≢y
...   | no  _   = refl
ax2 i j x (bound k) = refl
ax2 i j x (ƛ t) rewrite ax2 (suc i) (suc j) x t = refl
ax2 i j x (t₁ · t₂) rewrite ax2 i j x t₁ | ax2 i j x t₂ = refl
ax2 i j x ‵zero = refl
ax2 i j x (‵suc t) rewrite ax2 i j x t = refl

suc-preserves-≢ : ∀ {n m : ℕ} → n ≢ m → suc n ≢ suc m
suc-preserves-≢ {n} {m} n≢m sn≡sm = n≢m (helper n m sn≡sm)
  where
    helper : ∀ (n m : ℕ) → suc n ≡ suc m → n ≡ m
    helper n m refl = refl

-- ax5 : ∀ (i j : ℕ) (a b : List Char) (t : Term)
--   → (i≢j : i ≢ j)
--   → [ i —→ a ] ([ j —→ b ] t) ≡ [ j —→ b ] ([ i —→ a ] t)
ax5 i j a b (free x) _ = refl
ax5 i j a b (bound k) i≢j with j ≟ℕ k
... | no  j≢k with i ≟ℕ k
...   | yes i≡k = refl
...   | no  i≢k with j ≟ℕ k
...     | yes j≡k = contradiction j≡k j≢k
...     | no  j≢k = refl
ax5 i j a b (bound k) i≢j | yes j≡k with i ≟ℕ k
...   | yes i≡k = ⊥-elim (i≢j (trans i≡k (sym j≡k)))
...   | no  i≢k with j ≟ℕ k
...     | yes j≡k = refl
...     | no  j≢k = contradiction j≡k j≢k
ax5 i j a b (ƛ t) i≢j
  rewrite ax5 (suc i) (suc j) a b t (suc-preserves-≢ i≢j) = refl
ax5 i j a b (t₁ · t₂) i≢j
  rewrite ax5 i j a b t₁ (i≢j) | ax5 i j a b t₂ (i≢j) = refl
ax5 i j a b ‵zero i≢j = refl
ax5 i j a b (‵suc t) i≢j rewrite ax5 i j a b t i≢j = refl
\end{code}

\subsection{Fresh variables}
\begin{code}
-- #⇒∉fv : ∀ (x : List Char) (t : Term) → x # t → x ∉ fv t
#⇒∉fv x (free y) x#t with x ≟lchar y
... | yes x≡y with () ← x#t
... | no  x≢y = All¬⇒¬Any (x≢y All.∷ All.[])
#⇒∉fv x (bound i) x#t = λ ()
#⇒∉fv x (ƛ t) x#t = #⇒∉fv x t (
 begin
   [ 0 ←— x ] t
 ≡⟨ sym (cong ([ 0 ←— x ]_) (ƛ-inj x#t)) ⟩
   [ 0 ←— x ] ([ 1 ←— x ] t)
 ≡⟨ ax2 0 1 x t ⟩
   [ 1 ←— x ] t
 ≡⟨ ƛ-inj x#t ⟩
   t
 ∎)
#⇒∉fv x (t₁ · t₂) x#t = let ⟨ x#t₁ , x#t₂ ⟩ = ·-inj x#t in
  ++-∉
    (#⇒∉fv x t₁ x#t₁)
    (#⇒∉fv x t₂ x#t₂)
#⇒∉fv x (‵suc t) x#t = #⇒∉fv x t (‵suc-inj x#t)

-- ∉fv⇒# : ∀ (x : List Char) (t : Term) → x ∉ fv t → x # t
∉fv⇒# x (free y) x∉fv with x ≟lchar y
... | yes x≡y = ⊥-elim (x∉fv (here x≡y))
... | no  x≢y = refl
∉fv⇒# x (bound i) x∉fv = refl
∉fv⇒# x (ƛ t) x∉fv = cong ƛ_ (
  begin
    [ 1 ←— x ] t
  ≡⟨ sym (cong ([ 1 ←— x ]_) (∉fv⇒# x t x∉fv)) ⟩
    [ 1 ←— x ] ([ 0 ←— x ] t)
  ≡⟨ ax2 1 0 x t ⟩
    [ 0 ←— x ] t
  ≡⟨ ∉fv⇒# x t x∉fv ⟩
    t
  ∎)
∉fv⇒# x (t₁ · t₂) x∉fv =
  let ⟨ x∉fv-t₁ , x∉fv-t₂ ⟩ = (∉-++ x∉fv) in
    cong₂ _·_
      (∉fv⇒# x t₁ x∉fv-t₁)
      (∉fv⇒# x t₂ x∉fv-t₂)
∉fv⇒# x ‵zero x∉fv = refl
∉fv⇒# x (‵suc t) x∉fv rewrite ∉fv⇒# x t x∉fv = refl

-- #-ƛ : ∀ {x : List Char} (t : Term)
--   → x # (ƛ t)
--     -------
--   → x # t
#-ƛ {x} t x#ƛt =
  begin
    [ 0 ←— x ] t
  ≡⟨ sym (cong ([ 0 ←— x ]_) (ƛ-inj x#ƛt)) ⟩
    [ 0 ←— x ] ([ 1 ←— x ] t)
  ≡⟨ ax2 0 1 x t ⟩
    [ 1 ←— x ] t
  ≡⟨ ƛ-inj x#ƛt ⟩
    t
  ∎

-- #-· : ∀ {x : List Char} (t₁ t₂ : Term)
--   → x # (t₁ · t₂)
--     ---------------
--   → x # t₁ × x # t₂
#-· {x} t₁ t₂ x#t₁t₂ with ∉-++ (#⇒∉fv x (t₁ · t₂) x#t₁t₂)
... | ⟨ x∉fv-t₁ , x∉fv-t₂ ⟩
  = ⟨ (∉fv⇒# x t₁ x∉fv-t₁) , ∉fv⇒# x t₂ x∉fv-t₂ ⟩

-- #-‵suc : ∀ {x : List Char} (t : Term)
--   → x # (‵suc t)
--     -------
--   → x # t
#-‵suc {x} t x#‵suc-t = ∉fv⇒# x t (#⇒∉fv x (‵suc t) x#‵suc-t)
\end{code}

\subsection{Local closure}
\label{appendix:local_closure_proofs}
\begin{code}
-- lemma2·7-1 : ∀ {i : ℕ} {x y : List Char} {t : Term}
--   → [ i —→ x ] t ≡ t
--     ----------------
--   → [ i —→ y ] t ≡ t
lemma2·7-1 {i} {x} {y} {t} [i>x]t≡t =
  begin
    ([ i —→ y ] t)
  -- use the fact that t ≡ [ i —→ x ] t
  ≡⟨ sym (cong ([ i —→ y ]_) [i>x]t≡t) ⟩
    [ i —→ y ] ([ i —→ x ] t)
  ≡⟨ ax1 i y x t ⟩
    [ i —→ x ] t
  ≡⟨ [i>x]t≡t ⟩
    t
  ∎

-- lemma2·7-2 : ∀ {i j : ℕ} {x : List Char} {t : Term}
--   → j ≥ i
--   → i ≻ t
--     ----------------
--   → [ j —→ x ] t ≡ t
lemma2·7-2 {j = j} j≥i i≻t with (i≻t j ⦃ j≥i ⦄)
... | И⟨ Иe₁ , Иe₂ ⟩ =
  lemma2·7-1 (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
\end{code}

Note, in the paper \citep{chargueraud_locally_2012}, the assumption is written like so (with the
notation adapted):

\texttt{[ i —→ u ] ([ j —→ v ] t) ≡ [ i —→ u ] t}

However, in the Coq source code, the assumption is as below (notice that the right side of the
equality is \texttt{[ j —→ v ] t}). I decided to use the assumption as in the Coq source code. Link
to the source code:
\url{https://github.com/charguer/formalmetacoq/blob/ab4d006e468e352efd16d8e3fd89ad74a23d889d/ln/Lambda_JAR_paper.v#L321}

\begin{code}
-- open-rec-lc-lemma : ∀ {t : Term} {i j : ℕ} {u v : List Char}
--   → i ≢ j
--   → [ i —→ u ] ([ j —→ v ] t) ≡ [ j —→ v ] t
--   → [ i —→ u ] t ≡ t
open-rec-lc-lemma {free x} i≢j assump = refl
open-rec-lc-lemma {bound k} {i} {j} i≢j assump
  with i ≟ℕ j | i ≟ℕ k
... | yes i≡j | yes i≡k = contradiction i≡j i≢j
... | yes i≡j | no  i≢k = contradiction i≡j i≢j
... | no  _   | no  _   = refl
... | no i≢j' | yes i≡k with j ≟ℕ k
...   | yes j≡k = ⊥-elim (i≢j (trans i≡k (sym j≡k)))
...   | no  j≢k with i ≟ℕ k
...     | yes i≡k' with () ← assump
...     | no  i≢k  = contradiction i≡k i≢k
open-rec-lc-lemma {ƛ t} {i} {j} i≢j assump
  rewrite open-rec-lc-lemma {t} {suc i} {suc j}
      (suc-preserves-≢ i≢j)
      (ƛ-inj assump)
    = refl
open-rec-lc-lemma {t₁ · t₂} i≢j assump
  rewrite
    open-rec-lc-lemma {t₁} i≢j (proj₁ (·-inj assump))
   | open-rec-lc-lemma {t₂} i≢j (proj₂ (·-inj assump))
  = refl
open-rec-lc-lemma {‵zero} _ _ = refl
open-rec-lc-lemma {‵suc t} i≢j assump
  rewrite open-rec-lc-lemma {t} i≢j (‵suc-inj assump) = refl

-- lemma2·13 : ∀ {t : Term} {a : List Char} {i : ℕ} (j : ℕ)
--   → j ≥ i
--   → i ≻ t
--   → i ≻ ([ j —→ a ] t)
lemma2·13 {t} {a} {i} j j≥i i≻t k
  with j ≟ℕ k | Иe₁ (i≻t j ⦃ j≥i ⦄)
... | yes refl | l = И⟨ l , (λ b → ax1 j b a t) ⟩
... | no  j≢k  | l = И⟨ l , (λ b →
  begin
    [ k —→ b ] ([ j —→ a ] t)
  ≡⟨ ax5 k j b a t (sym-≢ j≢k) ⟩
    [ j —→ a ] ([ k —→ b ] t)
  ≡⟨ cong([ j —→ a ]_) (lemma2·7-2 it i≻t) ⟩
    [ j —→ a ] t
  ∎) ⟩

-- ≻⇒lc-at : ∀ (i : ℕ) (t : Term) → i ≻ t → Lc-at i t
≻⇒lc-at i (free x) i≻t = lc-at-free
≻⇒lc-at i (bound j) i≻t with j <? i
... | yes j<i = lc-at-bound ⦃ j<i ⦄
... | no  j≮i with
  (Иe₂ (i≻t j ⦃ ≮⇒≥ j≮i ⦄))
    (fresh (Иe₁ (i≻t j ⦃ ≮⇒≥ j≮i ⦄)))
    {fresh-correct (Иe₁ (i≻t j ⦃ ≮⇒≥ j≮i ⦄))}
...   | q with j ≟ℕ j
...     | yes refl with () ← q
...     | no  j≢j  = contradiction refl j≢j
≻⇒lc-at i (ƛ t) i≻t = lc-at-lam (≻⇒lc-at (suc i) t helper)
  where
    helper : suc i ≻ t
    helper (suc j) ⦃ s≤s j≥i ⦄ =
      И⟨ Иe₁ (i≻t j ⦃ j≥i ⦄)
      , (λ a {a∉} → ƛ-inj ((Иe₂ (i≻t j ⦃ j≥i ⦄)) a {a∉})) ⟩
≻⇒lc-at i (t₁ · t₂) i≻t =
  lc-at-app (≻⇒lc-at i t₁ i≻t₁) (≻⇒lc-at i t₂ i≻t₂)
  where
    i≻t₁ : i ≻ t₁
    i≻t₁ j ⦃ j≥i ⦄ =
      И⟨ Иe₁ (i≻t j ⦃ j≥i ⦄)
      , (λ a {a∉} → proj₁ (·-inj ((Иe₂ (i≻t j ⦃ j≥i ⦄)) a {a∉})))
      ⟩
    i≻t₂ : i ≻ t₂
    i≻t₂ j ⦃ j≥i ⦄ =
      И⟨ Иe₁ (i≻t j ⦃ j≥i ⦄)
      , (λ a {a∉} → proj₂ (·-inj ((Иe₂ (i≻t j ⦃ j≥i ⦄)) a {a∉})))
      ⟩
≻⇒lc-at _ ‵zero _ = lc-at-‵zero
≻⇒lc-at i (‵suc t) i≻t = lc-at-‵suc (≻⇒lc-at i t (λ j →
  И⟨ (Иe₁ (i≻t j ⦃ it ⦄))
  , (λ a {a∉} → ‵suc-inj ((Иe₂ (i≻t j ⦃ it ⦄)) a {a∉})) ⟩))

-- lc-at⇒≻ : ∀ (i : ℕ) (t : Term) → Lc-at i t → i ≻ t
-- Here we use "[]" because we don't really care what string
-- we use to test the locally closedness.
lc-at⇒≻ i (bound k) lc-at-bound j ⦃ i≤j ⦄ with j ≟ℕ k
... | yes j≡k = contradiction (sym j≡k) (<⇒≢ (≤-trans it i≤j))
... | no  j≢k = И⟨ [] , (λ a → refl) ⟩
lc-at⇒≻ i (free x) lc-at-free j = И⟨ [] , (λ a → refl) ⟩
lc-at⇒≻ i (ƛ t) (lc-at-lam lc-at) j
  with lc-at⇒≻ (suc i) t lc-at
... | si≻t = И⟨ [] , (λ a → cong ƛ_ (lemma2·7-2 (s≤s it) si≻t)) ⟩
lc-at⇒≻ i (t₁ · t₂) (lc-at-app lc-at₁ lc-at₂) j =
  И⟨ []
  , (λ a → cong₂ _·_
      (lemma2·7-2 it (lc-at⇒≻ i t₁ lc-at₁))
      (lemma2·7-2 it (lc-at⇒≻ i t₂ lc-at₂))) ⟩
lc-at⇒≻ _ (‵zero) (lc-at-‵zero) j = И⟨ [] , (λ _ → refl) ⟩
lc-at⇒≻ i (‵suc t) (lc-at-‵suc lc-at) j =
  И⟨ []
  , (λ _ → cong ‵suc_ (lemma2·7-2 it (lc-at⇒≻ i t lc-at))) ⟩

-- bound-never-lc : ∀ (n : ℕ) → ¬ LocallyClosed (bound n)
bound-never-lc n x with ≻⇒lc-at 0 (bound n) x
... | lc-at-bound ⦃ () ⦄ -- This implies that n < 0
                         -- which is never true.

-- free-lc : ∀ {x : List Char} → LocallyClosed (free x)
free-lc _ = И⟨ [] , (λ _ → refl) ⟩

-- i≻ƛt⇒si≻t : ∀ {i : ℕ} {t : Term}
--   → i ≻ ƛ t
--   → suc i ≻ t
i≻ƛt⇒si≻t {i} {t} lc-t with ≻⇒lc-at i (ƛ t) lc-t
... | lc-at-lam lc-at-si-t = lc-at⇒≻ (suc i) t lc-at-si-t

-- ·-≻ : ∀ {t₁ t₂ : Term} {i : ℕ}
--   → i ≻ (t₁ · t₂) → (i ≻ t₁) × (i ≻ t₂)
·-≻ {t₁} {t₂} {i} i≻· with ≻⇒lc-at i (t₁ · t₂) i≻·
... | lc-at-app t₁-at t₂-at =
  ⟨ lc-at⇒≻ i t₁ t₁-at
  , lc-at⇒≻ i t₂ t₂-at ⟩

-- ‵zero-≻ : ∀ {i : ℕ} → i ≻ ‵zero
‵zero-≻ j = И⟨ [] , (λ _ → refl) ⟩

-- ‵suc-≻ : ∀ {t : Term} {i : ℕ} → i ≻ (‵suc t) → i ≻ t
‵suc-≻ {t} {i} i≻‵suc-t with ≻⇒lc-at i (‵suc t) i≻‵suc-t
... | lc-at-‵suc lc-at-i = lc-at⇒≻ i t lc-at-i
\end{code}

\subsection{Substitution of terms}
\label{appendix:substitution_proofs}
During the development, I ended up proving more locally nameless substitution theorems than I
needed, so some haven't been referenced above. These aren't strictly needed.

\begin{code}
-- subst-open-var :
--   ∀ {u : Term} {x y : List Char} {i : ℕ} (t : Term)
--   → x ≢ y
--   → i ≻ u
--   → [ x := u ] ([ i —→ y ] t) ≡ [ i —→ y ] ([ x := u ] t)
subst-open-var {x = x} (free z) x≢y i≻u with x ≟lchar z
... | yes x≡z = sym (lemma2·7-2 ≤-refl i≻u)
... | no  x≢z = refl
subst-open-var {_} {x} {y} {i} (bound k) x≢y lc-u with i ≟ℕ k
... | no  i≢k = refl
... | yes i≡k with x ≟lchar y
...   | yes x≡y = contradiction x≡y x≢y
...   | no  x≢y = refl
subst-open-var (ƛ t) x≢y lc-u =
  cong ƛ_ (subst-open-var t x≢y (≻⇒s≻ lc-u))
subst-open-var (t₁ · t₂) x≢y lc-u =
  cong₂ _·_
    (subst-open-var t₁ x≢y lc-u)
    (subst-open-var t₂ x≢y lc-u)
subst-open-var (‵zero) x≢y lc-u = refl
subst-open-var (‵suc t) x≢y lc-u =
  cong ‵suc_ (subst-open-var t x≢y lc-u)

subst-fresh : ∀ {t u : Term} {x : List Char}
  → x # t
  → [ x := u ] t ≡ t
subst-fresh {free y} {u} {x} x#t with x ≟lchar y
... | yes _ with () ← x#t
... | no  _ = refl
subst-fresh {bound i} {u} {x} x#t = refl
subst-fresh {ƛ t} {u} x#t =
  cong ƛ_ (subst-fresh (#-ƛ t x#t))
subst-fresh {t₁ · t₂} {u} {x} x#· =
  let ⟨ x#t₁ , x#t₂ ⟩ = #-· t₁ t₂ x#· in
    cong₂ _·_ (subst-fresh x#t₁) (subst-fresh x#t₂)
subst-fresh {‵zero} {u} x#t = refl
subst-fresh {‵suc t} {u} x#t =
  cong ‵suc_ (subst-fresh (#-‵suc t x#t))

-- subst-open-lc : ∀ {t u : Term} {x y : List Char}
--   → x ≢ y
--   → LocallyClosed u
--   → [ x := u ] ([ 0 —→ y ] t) ≡ [ 0 —→ y ] ([ x := u ] t)
subst-open-lc {t} x≢y lc-u = subst-open-var t x≢y lc-u

subst-≻ : ∀ {t u : Term} {i : ℕ} (x : List Char)
  → i ≻ t
  → i ≻ u
    ----------------
  → i ≻ ([ x := u ] t)
subst-≻ {free y} x i≻t i≻u j with x ≟lchar y
... | yes _ = i≻u j
... | no  _ = И⟨ [] , (λ _ → refl) ⟩
subst-≻ {bound k} x i≻t i≻u j with j ≟ℕ k
... | no  _   = И⟨ [] , (λ _ → refl) ⟩
... | yes j≡k with i≻t j
...   | И⟨ Иe₁ , Иe₂ ⟩ with j ≟ℕ k
...     | no  j≢k = contradiction j≡k j≢k
...     | yes _   with () ← Иe₂ (fresh Иe₁) {fresh-correct Иe₁}
subst-≻ {ƛ t} {u} x i≻t i≻u j with i≻ƛt⇒si≻t i≻t
... | si≻t =
  И⟨ (x ∷ (Иe₁ (si≻t (suc j) ⦃ s≤s it ⦄)))
  , (λ a {a∉} → cong ƛ_ ((
    begin
      [ suc j —→ a ] ([ x := u ] t)
    ≡⟨ sym (subst-open-var
          t
          (sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ {xs = x ∷ []} a∉))))
          (lemma2·6 (m≤n⇒m≤1+n it) i≻u)) ⟩
      [ x := u ] ([ suc j —→ a ] t)
    ≡⟨ cong ([ x := u ]_)
        ((Иe₂ (si≻t (suc j) ⦃ s≤s it ⦄))
          a
          {proj₂ (∉-++ {xs = x ∷ []} a∉)}) ⟩
      [ x := u ] t
    ∎))) ⟩
subst-≻ {t₁ · t₂} {i = i} x i≻t i≻u j =
  let ⟨ i≻t₁ , i≻t₂ ⟩ = ·-≻ i≻t in
    И⟨ (Иe₁ ((subst-≻ x i≻t₁ i≻u) j)
      ++ Иe₁ ((subst-≻ x i≻t₂ i≻u) j))
    , (λ a {a∉} → cong₂ _·_
        (lemma2·7-2 it (subst-≻ x i≻t₁ i≻u))
        (lemma2·7-2 it (subst-≻ x i≻t₂ i≻u))) ⟩
subst-≻ {‵zero} {u} x i≻t i≻u j = И⟨ [] , (λ _ → refl) ⟩
subst-≻ {‵suc t} {u} x i≻t i≻u j =
  let И⟨ Иe₁ , Иe₂ ⟩ = (subst-≻ {t} x (‵suc-≻ i≻t) i≻u) j ⦃ it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩

subst-lc : ∀ {t u : Term} (x : List Char)
  → LocallyClosed t
  → LocallyClosed u
    --------------------------
  → LocallyClosed [ x := u ] t
subst-lc = subst-≻
\end{code}

\subsection{Types and typing properties}
\label{appendix:types_proofs}
\begin{code}
-- ⊢⇒lc : ∀ {Γ t A} → Γ ⊢ t ⦂ A → LocallyClosed t
⊢⇒lc {Γ} {t} {A} (⊢free Γ∋A) = free-lc
⊢⇒lc {Γ} {ƛ t} {A} (⊢ƛ И⟨ Иe₁ ,  Иe₂ ⟩) j =
  И⟨ Иe₁ , (λ a {a∉} → cong ƛ_
    (open-rec-lc-lemma
      (λ ())
      (open-rec-lc (⊢⇒lc (Иe₂ a {a∉}))))) ⟩
⊢⇒lc {Γ} {t₁ · t₂} (⊢· ⊢A⇒B ⊢A) _ =
  И⟨ domain Γ , (λ _ → cong₂ _·_
    (open-rec-lc (⊢⇒lc ⊢A⇒B)) (open-rec-lc (⊢⇒lc ⊢A))) ⟩
⊢⇒lc {Γ} {‵zero} ⊢zero = ‵zero-≻
⊢⇒lc {Γ} {‵suc t} (⊢suc ⊢t) j =
  И⟨ domain Γ , (λ a {a∉} →
    cong ‵suc_ (open-rec-lc (⊢⇒lc ⊢t))) ⟩

-- ext : ∀ {Γ Δ}
--   → (∀ {x A}     →         Γ ∋ x ⦂ A →         Δ ∋ x ⦂ A)
--   → (∀ {x y A B} → Γ , y ⦂ B ∋ x ⦂ A → Δ , y ⦂ B ∋ x ⦂ A)
ext ρ (H refl) = H refl
ext ρ (T x≢y ∋x) = T x≢y (ρ ∋x)

-- Renaming (aka. "rebasing") of contexts.
-- rename : ∀ {Γ Δ}
--   → (∀ {x A} → Γ ∋ x ⦂ A → Δ ∋ x ⦂ A)
--   → (∀ {M A} → Γ ⊢ M ⦂ A → Δ ⊢ M ⦂ A)
rename ρ (⊢free ∋A) = ⊢free (ρ ∋A)
rename {Δ = Δ} ρ (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩ ) =
  ⊢ƛ И⟨ (domain Δ ++ Иe₁) , (λ a {a∉} →
    rename (ext ρ) (Иe₂ a {proj₂ (∉-++ a∉)})) ⟩
rename ρ (⊢· ⊢A⇒B ⊢A) = ⊢· (rename ρ ⊢A⇒B) (rename ρ ⊢A)
rename {Δ = Δ} ρ ⊢zero = ⊢zero
rename {Δ = Δ} ρ (⊢suc ⊢t) = ⊢suc (rename ρ ⊢t)

-- Swapping variables in a context.
-- swap : ∀ {Γ x y t A B C}
--   → x ≢ y
--   → Γ , y ⦂ B , x ⦂ A ⊢ t ⦂ C
--   → Γ , x ⦂ A , y ⦂ B ⊢ t ⦂ C
swap {Γ} {x} {y} {M} {A} {B} {C} x≢y ⊢t = rename ρ ⊢t
  where
    ρ : ∀ {z C}
      → Γ , y ⦂ B , x ⦂ A ∋ z ⦂ C
        --------------------------
      → Γ , x ⦂ A , y ⦂ B ∋ z ⦂ C
    ρ (H refl) = T x≢y (H′)
    ρ (T z≢x (H refl)) = H′
    ρ (T z≢x (T z≢y ∋z)) = T z≢y (T z≢x ∋z)

-- Dropping shadowed variables.
-- drop : ∀ {Γ x M A B C}
--   → Γ , x ⦂ A , x ⦂ B ⊢ M ⦂ C
--   → Γ , x ⦂ B ⊢ M ⦂ C
drop {Γ} {x} {M} {A} {B} {C} ⊢M = rename ρ ⊢M
  where
    ρ : ∀ {z C}
      → Γ , x ⦂ A , x ⦂ B ∋ z ⦂ C
        -------------------------
      → Γ , x ⦂ B ∋ z ⦂ C
    ρ (H refl) = H refl
    ρ (T z≢x (H x≡z)) = contradiction (sym x≡z) z≢x
    ρ (T z≢x (T _ ∋z)) = T z≢x ∋z

-- subst-open-context : ∀ {Γ A} {t u : Term} {x y : List Char}
--   → x ≢ y
--   → LocallyClosed u
--   → Γ ⊢ [ x := u ] ([ 0 —→ y ] t) ⦂ A
--   → Γ ⊢ [ 0 —→ y ] ([ x := u ] t) ⦂ A
subst-open-context {t = t} x≢y lc-u sub-open =
  ≡-with-⊢ sub-open (subst-open-var t x≢y lc-u)
\end{code}

\subsection{Evaluation}
\label{appendix:evaluation_proofs}
\begin{code}
-- ⊢two : ∅ ⊢ two ⦂ (‵ℕ ⇒ ‵ℕ) ⇒ ‵ℕ ⇒ ‵ℕ
⊢two = ⊢ƛ
  И⟨ []
  , (λ a → ⊢ƛ
    И⟨ (a ∷ [])
    , (λ b {b∉} →
      ⊢·
      (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′))
      (⊢· (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′)) (⊢free (H′)))) ⟩) ⟩

-- ⊢plus : ∀ {Γ A} → Γ ⊢ plus ⦂
-- ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A)
⊢plus = ⊢ƛ
  И⟨ []
  , (λ a → ⊢ƛ
    И⟨ a ∷ []
    , (λ b {b∉} → ⊢ƛ
      И⟨ a ∷ b ∷ []
      , (λ c {c∉} → ⊢ƛ
        И⟨ a ∷ b ∷ c ∷ []
        , (λ d {d∉} →
        ⊢·
          (⊢·
            (⊢free (T (a≢d d∉) (T (a≢c c∉) (T (a≢b b∉) H′))))
            (⊢free (T (c≢d d∉) (H′))))
          (⊢·
            (⊢·
              (⊢free (T (b≢d d∉) (T (b≢c c∉) H′)))
              (⊢free (T (c≢d d∉) H′)))
            (⊢free H′))) ⟩) ⟩) ⟩) ⟩
  where
    a≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → a ≢ d
    a≢d d∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ d∉)))
    a≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → a ≢ c
    a≢c c∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ c∉)))
    a≢b : ∀ {a b} → b ∉ a ∷ [] → a ≢ b
    a≢b b∉ = sym-≢ (∉∷[]⇒≢ b∉)
    c≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → c ≢ d
    c≢d {a} {b} d∉ =
      sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ b ∷ []} d∉)))
    b≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → b ≢ d
    b≢d {a} {b} d∉ =
      sym-≢ (∉∷[]⇒≢ (proj₂ (
        ∉-++
          {xs = a ∷ []}
          (proj₁ (∉-++ {xs = a ∷ b ∷ []} d∉)))))
    b≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → b ≢ c
    b≢c {a} c∉ = sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ []} c∉)))
\end{code}

\chapter{Compilation instructions}
\label{appendix:compilation_instructions}

This document is a literate Agda file. It has been tested to work with
\begin{itemize}
  \item Agda 2.7.0,
  \item the Agda Standard Library 2.1 \citep{the_agda_community_agda_2024},
  \item XeLaTeX 3.141592653-2.6-0.999996 (TeX Live 2024/Arch Linux 2024.2-4).
\end{itemize}

The full source code is available at [TO BE MADE PUBLIC LATER].

Since this document uses the Minted package [TODO: cite], XeLaTeX needs to be run with the
\texttt{--shell-escape} option. While Agda does provide its own typesetting of Agda code, it uses a
sans-serif typeface. I decided to use the Minted package to provide a monospace typeface for the
code blocks.

To typecheck the document, run Agda with the \texttt{--latex} option. If successful, it will give no
output and return an exit code \texttt{0}.

\end{document}

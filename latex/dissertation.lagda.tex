% UG project example file, February 2024
%
%   Added the "online" option for equal margins, February 2024 [Hiroshi Shimodaira, Iain Murray]
%   A minor change in citation, September 2023 [Hiroshi Shimodaira]
%
% Do not change the first two lines of code, except you may delete "logo," if causing problems.
% Understand any problems and seek approval before assuming it's ok to remove ugcheck.
\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


% Include any packages you need below, but don't include any that change the page
% layout or style of the dissertation. By including the ugcheck package above,
% you should catch most accidental changes of page layout though.

\usepackage{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

% === Custom packages === %

% Syntax highlighting
\usepackage{minted}
% BNF
\usepackage{simplebnf}
% Inference rules
\usepackage{mathpartir}
% Agda
\usepackage{agda}
\AgdaNoSpaceAroundCode{}
% Hide in output
\usepackage{comment}
% Colour
\usepackage{xcolor}

% Unicode

\usepackage{fontspec}
\usepackage{newunicodechar}
\newfontface{\notoserif}{NotoSerif-VariableFont_wdth,wght.ttf}[Path = fonts/]
\newfontface{\ibmplexmath}{IBMPlexMath-Regular.otf}[Path = fonts/]
\newunicodechar{ℕ}{{\ibmplexmath{ℕ}}}
\newunicodechar{∀}{{\ibmplexmath{∀}}}
\newunicodechar{≡}{{\ibmplexmath{≡}}}
\newunicodechar{≥}{{\ibmplexmath{≥}}}
\newunicodechar{≤}{{\ibmplexmath{≤}}}
\newunicodechar{≰}{{\ibmplexmath{≰}}}
\newunicodechar{⊔}{{\ibmplexmath{⊔}}}
\newunicodechar{≟}{{\ibmplexmath{≟}}}
\newunicodechar{⇒}{{\ibmplexmath{⇒}}}
\newunicodechar{≢}{{\ibmplexmath{≢}}}
\newunicodechar{≮}{{\ibmplexmath{≮}}}
\newunicodechar{⟪}{{\ibmplexmath{⟪}}}
\newunicodechar{⟫}{{\ibmplexmath{⟫}}}
\newunicodechar{⊤}{{\ibmplexmath{⊤}}}
\newunicodechar{⊥}{{\ibmplexmath{⊥}}}
\newunicodechar{∣}{{\ibmplexmath{∣}}}
\newunicodechar{⟨}{{\ibmplexmath{⟨}}}
\newunicodechar{⟩}{{\ibmplexmath{⟩}}}
\newunicodechar{∎}{{\ibmplexmath{∎}}}
\newunicodechar{⌊}{{\ibmplexmath{⌊}}}
\newunicodechar{⌋}{{\ibmplexmath{⌋}}}
\newunicodechar{₁}{{\ibmplexmath{₁}}}
\newunicodechar{₂}{{\ibmplexmath{₂}}}
\newunicodechar{∃}{{\ibmplexmath{∃}}}
\newunicodechar{∷}{{\ibmplexmath{∷}}}
\newunicodechar{∈}{{\ibmplexmath{∈}}}
\newunicodechar{∉}{{\ibmplexmath{∉}}}
\newunicodechar{λ}{{\ibmplexmath{λ}}}
\newunicodechar{И}{{\ibmplexmath{И}}}
\newunicodechar{∘}{{\ibmplexmath{∘}}}
\newunicodechar{≠}{{\ibmplexmath{≠}}}
\newunicodechar{‵}{{\ibmplexmath{‵}}}
\newunicodechar{ƛ}{{\ibmplexmath{ƛ}}}
\newunicodechar{≻}{{\ibmplexmath{≻}}}
\newunicodechar{⦃}{{\ibmplexmath{⦃}}}
\newunicodechar{⦄}{{\ibmplexmath{⦄}}}
\newunicodechar{′}{{\ibmplexmath{′}}}
\newunicodechar{∋}{{\ibmplexmath{∋}}}
\newunicodechar{⦂}{{\ibmplexmath{⦂}}}
\newunicodechar{∅}{{\ibmplexmath{∅}}}
\newunicodechar{⊢}{{\ibmplexmath{⊢}}}
\newunicodechar{ξ}{{\ibmplexmath{ξ}}}
\newunicodechar{β}{{\ibmplexmath{β}}}
\newunicodechar{↠}{{\ibmplexmath{↠}}}
\newunicodechar{ρ}{{\ibmplexmath{ρ}}}
\newunicodechar{σ}{{\ibmplexmath{σ}}}
\newunicodechar{⊆}{{\ibmplexmath{⊆}}}
\newunicodechar{⊎}{{\ibmplexmath{⊎}}}
\newunicodechar{∧}{{\ibmplexmath{∧}}}
\newunicodechar{ʳ}{{\ibmplexmath{ʳ}}}
\newunicodechar{ˡ}{{\ibmplexmath{ˡ}}}
\newunicodechar{ᵀ}{{\notoserif{ᵀ}}}
\newunicodechar{✓}{{\ibmplexmath{✓}}}

% Maths:

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{xurl}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Real}{Re}
\DeclareMathOperator{\Imag}{Im}
\DeclareMathOperator{\complex}{\mathbb{C}}
\DeclareMathOperator{\reals}{\mathbb{R}}
\DeclareMathOperator{\nat}{\mathbb{N}}
\DeclareMathOperator{\integer}{\mathbb{Z}}
\DeclareMathOperator{\rational}{\mathbb{Q}}
\DeclareMathOperator{\Log}{Log}
\DeclareMathOperator{\Arg}{Arg}
\DeclareMathOperator{\cof}{\text{И}}
\DeclareMathOperator{\lambdabar}{\text{ƛ}}
\DeclareMathOperator{\fv}{\text{fv}}
\DeclareMathOperator{\ftv}{\text{ftv}}

% Use minted for Agda

% \let\oldcode\code
% \NewCommandCopy{\mintedcopy}{\minted}
% \NewCommandCopy{\endmintedcopy}{\endminted}
% % Adapted from https://tex.stackexchange.com/a/488451/202867
% \renewenvironment{code}{\mintedcopy[breaklines,breaksymbolleft=\;]{agda}}{\endmintedcopy}

\begin{document}
\begin{preliminary}

\title{System F in Agda via Pitts}

\author{Charlotte Ausel}

% CHOOSE YOUR DEGREE a):
% please leave just one of the following un-commented
% \course{Artificial Intelligence}
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Software Engineering}
%\course{Cognitive Science}
%\course{Computer Science}
%\course{Computer Science and Management Science}
\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}
%\course{Software Engineering}
%\course{Master of Informatics} % MInf students

% CHOOSE YOUR DEGREE b):
% please leave just one of the following un-commented
%\project{MInf Project (Part 1) Report}  % 4th year MInf students
%\project{MInf Project (Part 2) Report}  % 5th year MInf students
\project{4th Year Project Report}        % all other UG4 students


\date{\today}

\abstract{ Proofs of properties of programming languages are expected to be formally verified to
improve confidence in correctness of said proofs, yet the approaches to do so continue to be
difficult and tedious. One reason for this is the difficulty in dealing with the syntax of
\textit{binders}. The typed $\lambda$-calculus \textit{System F} is of particular interest due to
its mix of bound term and bound type variables. While typically \textit{fully named syntax} or
\textit{de Bruijn indices} are used for the syntax of System F, the two can be combined as
\textit{locally nameless representation}. Although this representation has been studied extensively,
most of the literature uses the proof-assistant Rocq, whereas few use Agda. I present the first
formalisation of System F in Agda using locally nameless representation that I am aware of. While
some properties were difficult to prove and to understand, this work demonstrates that both Agda and
locally nameless representation are viable options for future programming language formalisations. }

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
This project could not have been possible without the generous guidance of my supervisor Philip
Wadler, who has not only supported me throughout this project, but also inspired my passion for
theoretical computer science. For this, I thank him greatly.

The feedback and support of my friends, in particular Cosmo Bobak, Jacob Cochrane, Artemis
Livingstone, Ol Rushton, Aria Shrimpton, Jacob Walters, and Lucy Winters, has also helped me greatly.
To them, I would also like to express my gratitude.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

\textit{System F} is a theoretical model of computation first described independently by Jean
\citet{girard_interpretation_1972} and John \citet{goos_towards_1974} and is based on the
$\lambda$-calculus, first described by Alonzo \citet{church_set_1932}. Background to these is given
in Section \ref{background:lambda_calculus}.

Usually, $\lambda$-calculus is written using \textit{fully named} syntax: all variables are given
\textit{identifiers} (usually these are strings). An alternative representation uses \textit{de
Bruijn indices}, where a variable is referred to using a natural number representing how many
binders ago the variable was bound, first described by Nicolaas Govert
\citet{de_bruijn_lambda_1972}. By using identifiers for free variables and de Bruijn indices for
bound variables, we use a syntax called the \textit{locally nameless representation}, first used by
Andrew \citet{goos_mechanisation_1994}. More detail on this syntax is given in Section
\ref{background:locally_nameless}.

Most of the prior literature uses the proof-assistant Rocq for its formalisation of the locally
nameless representation. A generalisation of this representation, called \textit{locally nameless
sets}, has previously been explored in another proof assistant, Agda, by Andrew
\citet{pitts_locally_2023}. Some background to Agda is given in Section \ref{background:agda}. While
his work did not focus on the $\lambda$-calculus, it demonstrated that the syntax can effectively in
Agda. As such, I would like to explore formalising System F in Agda using locally nameless
representation using the methods shown in the work presented by Pitts. His work was essential in
helping develop crucial initial proofs of the syntax and informed future proof strategies.

In this work, I present the first formalisation of System F using the locally nameless
representation in Agda that I am aware of. Specifically, I successfully create a formalisation which
proves the following properties of System F using locally nameless representation:
\begin{itemize}
  \item System F terms and types can be represented and manipulated using locally nameless
  representation (sections \ref{chapter3:syntax} to \ref{chapter3:substitution_syntax}).
  \item Using the previously defined syntax, we can introduce typing rules to restrict ourselves to
  well-typed terms and prove some well-known properties such as renaming of type contexts (sections
  \ref{chapter3:contexts} to \ref{chapter3:typed_is_locally_closed}).
  \item Substitution preserves types \ref{chapter3:substitution_preserves_types}.
  \item An evaluator can be built by using the progress and preservation properties
  \ref{chapter3:evaluation}.
\end{itemize}
Since all code presented is checked to be correct by Agda, I have managed to accomplish each of
these points. A more detailed evaluation of my formalisation as well as future work will be
presented in chapter \ref{chapter4}.

To do so, I will follow the work of Arthur \citet{chargueraud_locally_2012}, where he describes a
formalisation of System F with subtyping in Rocq. Although I will closely follow him initially, from
Section \ref{chapter3:contexts} onwards, my proofs will diverge from his approach.

This document is a literate Agda file and uses {\color{violet}colour}. All Agda code typeset in
colour has been typechecked by Agda. Please see Appendix \ref{appendix:compilation_instructions} for
details.

\chapter{Background}

\section{Agda}
\label{background:agda}
Agda is a dependently-typed functional programming language based on Martin--Löf type theory, which
makes it suitable as a proof-assistant using intuitionistic logic \citep{norell_towards_2007}.

A brief overview of Agda is presented in Appendix \ref{appendix:agda_overview}. As described in said
Appendix, a correspondence between mathematical proofs and computer programs exist, where a
dependently typed program is equivalent to a proof of a mathematical claim
\citep{howard_formulae-as-types_1980}. Thus, we can rely on a computer to check that a proof is
correct. All code presented in this document, has been checked to be correct by Agda (with a single
exception where a regular proof has been provided, see page \pageref{chapter3:subst}). An in-depth
guide to Agda is presented in the excellent textbook \textit{Programming Language Foundations in
Agda} \citep{wadler_programming_2022}. Knowledge of Agda (or proof-assistants which are similar)
will be assumed henceforth.

In Agda, like many other programming languages, we need to declare a module for our program.
\begin{code}
module dissertation where
\end{code}

We will make use of the Agda standard library \citep{the_agda_community_agda_2024}. Specific imports
of standard library functions are omitted, but are included in the full source code (see Appendix
\ref{appendix:compilation_instructions}).
\begin{comment}
\begin{code}
-- Data types (naturals, strings, characters)
open import Data.Nat using (ℕ; zero; suc; _<_; _≥_; _≤_; _≤?_; _<?_; z≤n; s≤s; _⊔_)
  renaming (_≟_ to _≟ℕ_)
open import Data.Nat.Properties using (≤-refl; ≤-trans; ≤-<-trans; <-≤-trans;
  ≤-pred; +-mono-≤; <-trans; n≤1+n; m≤n⇒m≤1+n; n≮n; <⇒≢; ≰⇒>; ≮⇒≥; ≤∧≢⇒<; 1+n≢n)
open import Data.String using (String; fromList; toList) renaming (_≟_ to _≟str_;
  _++_ to _++str_; length to str-length)
open import Data.Char using (Char)
open import Data.Char.Properties using () renaming (_≟_ to _≟char_)

-- Function manipulation.
open import Function using (_∘_; flip; it)

-- Relations and predicates/decidability.
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; sym; trans; cong; cong-app; cong₂)
open Eq.≡-Reasoning using (begin_; step-≡-∣; step-≡-⟩; _∎)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Nullary.Decidable using (Dec; yes; no; True; False; toWitnessFalse;
  toWitness; fromWitness; ¬?; ⌊_⌋)
open import Relation.Nullary.Negation using (¬_; contradiction)
open import Data.Empty using (⊥-elim)

-- Products and exists quantifier.
open import Data.Product using (_×_; proj₁; proj₂; ∃-syntax) renaming (_,_ to ⟨_,_⟩)
open import Data.Sum using (_⊎_; inj₁; inj₂)

-- Lists.
open import Data.List using (List; []; _∷_; _++_; length)
open import Data.List.Properties using (≡-dec)
import Data.List.Membership.DecPropositional as DecPropMembership
open import Data.List.Relation.Unary.All using (All; all?; lookup)
  renaming (fromList to All-fromList; toList to All-toList; map to All-map)
open import Data.List.Relation.Unary.Any using (Any; here; there)
open import Data.List.Extrema Data.Nat.Properties.≤-totalOrder using (max; xs≤max)

-- Import list membership using List Char comparisons.
_≟lchar_ : ∀ (xs ys : List Char) → Dec (xs ≡ ys)
xs ≟lchar ys = ≡-dec (_≟char_) xs ys

open DecPropMembership _≟lchar_ using (_∈_; _∉_; _∈?_)
\end{code}
\end{comment}

\section{The Lambda Calculus and System F}
\label{background:lambda_calculus}
\input{background_lambda_calculus.tex}

\section{Cofinite Quantification}
\label{background:cofinite}
\input{cofinite.tex}

\section{Locally Nameless Representation}
\label{background:locally_nameless}
\input{background_locally_nameless.tex}

\section{Evaluation strategy}
\label{background:evaluation_strategy}
\input{background_evaluation_strategy.tex}

\section{Prior research}
System F was previously formalised in Agda by \citet{hutton_system_2019}. However, the authors
formalised a variant of System F with language extensions known as \textit{System F$_{\omega \mu}$}.
They also used a different approach, opting to make use of de Bruijn indices only. This paper will
use the locally nameless representation, which has not been used for System F in Agda before as far
as I am aware of.

As mentioned above, most of the literature has used Rocq for locally nameless representation, and
although \citet{pitts_locally_2023} used Agda, he explored a generalisation called \textit{locally
nameless sets}. The scope of his work was only to prove properties of the syntax and not of any
language in particular. By relying on only the definition of locally nameless sets, one cannot
manipulate language constructs enough to prove properties such as \texttt{subst-open}, as explained
by \citet{kiselyov_generic_2025}. Although they present a library which does prove properties such
as \texttt{subst-open} for another generalisation, their work is written in Rocq and so cannot be
used here.

I have previously submitted some work on the STLC using locally nameless representation for a course
called \textit{Types and Semantics of Programming Languages} (TSPL) \citep{ausel_simply_2025}. While
this was very helpful in preparing my formalisation of System F, it is not a prerequisite in
formalising System F, nor is it necessary to understand this formalisation. The only functions from
the work submitted for TSPL which will be reused here are those for generating fresh variables (see
Appendix \ref{appendix:tspl}).

\chapter{System F formalisation}
\label{chapter3}
Combining System F with the locally nameless representation was previously described by
\citet{chargueraud_locally_2012}. We first import the previously defined cofinite quantification and
various helper functions from appendices \ref{appendix:tspl} and \ref{appendix:plfa}.
\begin{code}
module chapter3 where
  open import cofinite
  open import plfa_adaptions
  open import tspl_prior_work
\end{code}

As the following code covers a lot of detail, and since I am limited by the page count of this
dissertation, I will present some proofs from this chapter in Appendix \ref{appendix:f} instead. I
will only do this in two cases:
\begin{itemize}
  \item If the proof is trivial (for example, an induction where each case is proven immediately
  using \texttt{refl} and each inductive step is a simple recursive call).
  \item The proof is near-identical to a previous proof. This will occur because some theorems need
  to be proven three times (see page \pageref{page:repeated_proofs}).
\end{itemize}

Even though the proofs are missing, the type signature of the function is still present, and since
we can use forward declarations, Agda still ensures that these are correct.

\section{Syntax of types and terms}
\label{chapter3:syntax}
To represent identifiers, we use \texttt{List Char}, and thus define a type alias. Functions to
generate new identifiers can be found in Appendix \ref{appendix:list_functions}. Namely,
\texttt{fresh} generates a new identifier and \texttt{fresh-correct} gives a proof that this
identifier does not exist in the given list.
\begin{code}
  Id : Set
  Id = List Char
\end{code}

First we need to define our syntax, we have types and terms.
\begin{code}
  data Type : Set where
    ‵ℕ      : Type                -- Base type.
    frᵀ     : Id → Type           -- Free type variables.
    #ᵀ      : ℕ → Type            -- Bound type variables.
    _⇒_     : Type → Type → Type  -- Arrow types.
    ∀ᵀ_     : Type → Type         -- "For all" type.

  data Term : Set where
    fr     : Id → Term
    #      : ℕ → Term
    ƛ_     : Term → Term
    _·_    : Term → Term → Term
    Λ_     : Term → Term
    _[_]   : Term → Type → Term
    ‵zero  : Term
    ‵suc_  : Term → Term
\end{code}

We also define some helper functions for reasoning about equality.
\begin{code}
  ⇒-inj : ∀ {A B A' B'}→ A ⇒ B ≡ A' ⇒ B' → (A ≡ A') × (B ≡ B')
  ⇒-inj refl = ⟨ refl , refl ⟩
  ∀-inj : ∀ {A B} → ∀ᵀ A ≡ ∀ᵀ B → A ≡ B
  ∀-inj refl = refl
  ƛ-inj : ∀ {L M} → ƛ L ≡ ƛ M → (L ≡ M)
  ƛ-inj refl = refl
  ·-inj : ∀ {L M L' M'} → L · M ≡ L' · M' → (L ≡ L') × (M ≡ M')
  ·-inj refl = ⟨ refl , refl ⟩
  Λ-inj : ∀ {L M} → Λ L ≡ Λ M → L ≡ M
  Λ-inj refl = refl
  []-inj : ∀ {L M A B} → L [ A ] ≡ M [ B ] → (L ≡ M) × (A ≡ B)
  []-inj refl = ⟨ refl , refl ⟩
  ‵suc-inj : ∀ {L M} → ‵suc L ≡ ‵suc M → L ≡ M
  ‵suc-inj refl = refl
\end{code}

Since there are now two different kinds of free and bound variables, outside Agda code, I shall
refer to free variables in lowercase and free type variables in UPPERCASE as I have before, and
bound variables using regular Arabic numerals ($0$) and bound type variables using bold Arabic
numerals ($\mathbf{0}$). So for example,

\begin{equation*}
  \text{id} \triangleq (\Lambda \lambda 0) \colon \forall \mathbf{0} \to \mathbf{0}
\end{equation*}

\section{Opening}
\label{chapter3:opening}
In System F, we only require the opening operation and will not need to define the closing operation
\citep{chargueraud_locally_2012}. There are three kinds of opening:
\begin{itemize}
  \item opening a type at an index by replacing the bound type variable at that index with a free
        type variable,
  \item opening a term at an index by replacing the bound type variable at that index in the term
        with a free type variable, and
  \item opening a term at an index by replacing the bound variable at that index with a free
        variable.
\end{itemize}

\begin{code}
  ty-ty[_—→_]_ : ℕ → Id → Type → Type
  ty-ty[ i —→ x ] ‵ℕ = ‵ℕ
  ty-ty[ i —→ x ] (frᵀ y) = frᵀ y
  ty-ty[ i —→ x ] (#ᵀ n) with i ≟ℕ n
  ... | yes _ = frᵀ x
  ... | no  _ = #ᵀ n
  ty-ty[ i —→ x ] (A ⇒ B) = (ty-ty[ i —→ x ] A) ⇒ (ty-ty[ i —→ x ] B)
  ty-ty[ i —→ x ] ∀ᵀ A = ∀ᵀ (ty-ty[ suc i —→ x ] A)

  ty-tm[_—→_]_ : ℕ → Id → Term → Term
  ty-tm[ i —→ x ] (fr y) = fr y
  ty-tm[ i —→ x ] (# n) = # n
  ty-tm[ i —→ x ] (ƛ L) = ƛ (ty-tm[ i —→ x ] L)
  ty-tm[ i —→ x ] (L · M) = (ty-tm[ i —→ x ] L) · (ty-tm[ i —→ x ] M)
  ty-tm[ i —→ x ] (Λ L) = Λ ty-tm[ suc i —→ x ] L
  ty-tm[ i —→ x ] (L [ A ]) = (ty-tm[ i —→ x ] L) [ (ty-ty[ i —→ x ] A) ]
  ty-tm[ i —→ x ] ‵zero = ‵zero
  ty-tm[ i —→ x ] (‵suc L) = ‵suc ty-tm[ i —→ x ] L

  tm-tm[_—→_]_ : ℕ → Id → Term → Term
  tm-tm[ i —→ x ] (fr y) = fr y
  tm-tm[ i —→ x ] (# n) with i ≟ℕ n
  ... | yes _ = fr x
  ... | no  _ = # n
  tm-tm[ i —→ x ] (ƛ L) = ƛ tm-tm[ (suc i) —→ x ] L
  tm-tm[ i —→ x ] (L · M) =
    (tm-tm[ i —→ x ] L) · (tm-tm[ i —→ x ] M)
  tm-tm[ i —→ x ] (Λ L) = Λ (tm-tm[ i —→ x ] L)
  tm-tm[ i —→ x ] (L [ A ]) = (tm-tm[ i —→ x ] L) [ A ]
  tm-tm[ i —→ x ] ‵zero = ‵zero
  tm-tm[ i —→ x ] (‵suc L) = ‵suc tm-tm[ i —→ x ] L
\end{code}

When \citet{pitts_locally_2023} defines locally nameless sets, he requires that they follow 9
axioms. In our development we will only need one of these, axiom 1. Proving the others is possible,
but not necessary, as our goal is not to prove that we are using locally nameless sets.

Axiom 1 states that applying two openings of the same index to a type is the same as applying the
first one only. The proof is done by induction on the structure of the type with each case being
trivial (proven using reflexivity).
\begin{code}
  ax1-ty : ∀ (i : ℕ) (a b : Id) (A : Type)
    → ty-ty[ i —→ a ] (ty-ty[ i —→ b ] A) ≡ ty-ty[ i —→ b ] A
  ax1-ty i a b ‵ℕ = refl
  ax1-ty i a b (frᵀ x) = refl
  ax1-ty i a b (#ᵀ k) with i ≟ℕ k
  ... | yes _   = refl
  ... | no  i≢k with i ≟ℕ k
  ...   | yes refl = contradiction refl i≢k
  ...   | no  _    = refl
  ax1-ty i a b (A ⇒ B)
    rewrite ax1-ty i a b A | ax1-ty i a b B = refl
  ax1-ty i a b (∀ᵀ A) rewrite ax1-ty (suc i) a b A = refl
\end{code}

The same can be said of the other kinds of opening. Repeating proofs for the three kinds of opening
will be a recurring theme \label{page:repeated_proofs}. The proofs for the other two opening
operations are very similar and left in Appendix \ref{appendix:f_local_closure}.
\begin{code}
  ax1-tm : ∀ (i : ℕ) (a b : Id) (L : Term)
    → tm-tm[ i —→ a ] (tm-tm[ i —→ b ] L) ≡ tm-tm[ i —→ b ] L
  ax1-ty-tm : ∀ (i : ℕ) (a b : Id) (L : Term)
    → ty-tm[ i —→ a ] (ty-tm[ i —→ b ] L) ≡ ty-tm[ i —→ b ] L
\end{code}

\section{Local closure}
\label{chapter3:local_closure}
Recall that a term is locally closed at level $i$ if it remains unchanged after opening it at $i$,
see equation \ref{equation:local_closure}. We will have three kinds of local closure, one for each
kind of opening. In Agda, we can make use of \textit{instance arguments} to automatically search for
a evidence that is in scope. In the below definitions, we try and automatically find evidence that
$j \geq i$. If Agda cannot find such evidence, it has to be provided using ⦃these Unicode curly
brackets⦄ or \{\{double curly brackets\}\}.

\begin{code}
  _≻ty_ : ℕ → Type → Set
  i ≻ty A = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И T , (ty-ty[ j —→ T ] A ≡ A)

  _≻tm_ : ℕ → Term → Set
  i ≻tm L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , (tm-tm[ j —→ a ] L ≡ L)

  _≻ty-tm_ : ℕ → Term → Set
  i ≻ty-tm L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И T , (ty-tm[ j —→ T ] L ≡ L)

  Ty-LocallyClosed : Type → Set
  Ty-LocallyClosed A = 0 ≻ty A

  Tm-LocallyClosed : Term → Set
  Tm-LocallyClosed L = 0 ≻tm L

  Ty-Tm-LocallyClosed : Term → Set
  Ty-Tm-LocallyClosed L = 0 ≻ty-tm L
\end{code}

\citet{pitts_locally_2023} proves three lemmas about local closure that we will make use of later.
As I simply adapted these proofs with the syntax of System F defined earlier, the proofs are
detailed in the Appendix \ref{appendix:f_local_closure}.

\textbf{Lemma 2.6} states that if a type is locally closed at level $i$, then it is also locally
closed at any level greater than $i$. The proof follows from the definition of local closure.
\begin{code}
  lemma2·6-ty : ∀ {i j L}
    → j ≥ i
    → i ≻ty L
    → j ≻ty L
\end{code}
The same can be said of the other kinds of local closure.
\begin{code}
  lemma2·6-tm : ∀ {i j L}
    → j ≥ i → i ≻tm L → j ≻tm L
  lemma2·6-ty-tm : ∀ {i j L}
    → j ≥ i → i ≻ty-tm L → j ≻ty-tm L
\end{code}

\textbf{Lemma 2.7-1} states that if opening a type with an identifier leaves it unchanged, then
opening it with any other identifier will also leave it unchanged. Once again, the same can be said
of the other local closure properties. The proofs follow from axiom 1.
\begin{code}
  lemma2·7-1-ty : ∀ {i x y L}
    → ty-ty[ i —→ x ] L ≡ L
    → ty-ty[ i —→ y ] L ≡ L

  lemma2·7-1-tm : ∀ {i x y L}
    → tm-tm[ i —→ x ] L ≡ L → tm-tm[ i —→ y ] L ≡ L
  lemma2·7-1-ty-tm : ∀ {i x y L}
    → ty-tm[ i —→ x ] L ≡ L → ty-tm[ i —→ y ] L ≡ L
\end{code}

And \textbf{Lemma 2.7-2} states that if a type is locally closed at level $i$, then opening it at
$i$ or any greater index will leave the type unchanged. And the same applies to the other local
closure properties. This is a corollary of Lemma 2.7-1.
\begin{code}
  lemma2·7-2-ty : ∀ {i j x A}
    → j ≥ i
    → i ≻ty A
    → ty-ty[ j —→ x ] A ≡ A

  lemma2·7-2-tm : ∀ {i j x L} → j ≥ i
    → i ≻tm L → tm-tm[ j —→ x ] L ≡ L
  lemma2·7-2-ty-tm : ∀ {i j x L} → j ≥ i
    → i ≻ty-tm L → ty-tm[ j —→ x ] L ≡ L
\end{code}

We also have some local closure properties of specific terms and types which will become useful in
later proofs. I would like to draw particular attention to the first property, that if a type
$\forall A$ is locally closed up to $i$, then $A$ is locally closed up to $i + 1$. The property does
not follow from Lemma 2.6 as that would prove $i \succ \forall A$ implies $i + 1 \succ \forall A$
without removing the $\forall$.
\begin{code}
  i≻∀A⇒si≻A : ∀ {A i} → i ≻ty (∀ᵀ A) → (suc i) ≻ty A
  i≻∀A⇒si≻A {A} i≻∀ (suc j) =
    -- "it" retrieves instance evidence that is not in scope.
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻∀ j ⦃ ≤-pred it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → ∀-inj (Иe₂ a {a∉})) ⟩
\end{code}
Recall the definition of local closure. To prove that something is locally closed up to $i$, we take
a $j \in \nat$ that is greater than $i$ as an argument, and then prove that the type remains
unchanged when opened at $j$ with a cofinite identifier. Since we need to prove that $A$ is locally
closed up to $i + 1$, we can deconstruct and write \texttt{suc j} instead. Using $j$ with the
hypothesis gives a proof that $\forall ([suc j \to a] A) = \forall A$. To obtain this proof, we need
to choose some identifier which is not in the list \texttt{Иe₁}. By constructing a cofinite
quantification ourselves, we can use the list \texttt{Иe₁} as our list of exceptions and choose
an identifier that isn't in \texttt{Иe₁}, which we give the variable name $a$. Then we can use the
injectivity of \texttt{∀ᵀ} to get a proof of $([suc j \to a] A) = A$, which is exactly what is
required.

We can prove similar properties for \texttt{ƛ} and \texttt{Λ} in the same way.
\begin{code}
  ≻ƛ⇒s≻ƛ : ∀ {L i} → i ≻tm (ƛ L) → (suc i) ≻tm L
  ≻ƛ⇒s≻ƛ ≻ƛ (suc j) = let И⟨ Иe₁ , Иe₂ ⟩ = ≻ƛ j ⦃ ≤-pred it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → ƛ-inj (Иe₂ a {a∉})) ⟩

  ≻Λ⇒s≻Λ : ∀ {L i} → i ≻ty-tm (Λ L) → (suc i) ≻ty-tm L
  ≻Λ⇒s≻Λ i≻Λ (suc j) = let И⟨ Иe₁ , Иe₂ ⟩ = i≻Λ j ⦃ ≤-pred it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → Λ-inj (Иe₂ a {a∉})) ⟩
\end{code}

For some terms, opening will not increment the index, and so the proof is even simpler. We follow
the same procedure as above, but miss out the steps involving manipulating \texttt{suc}.
\begin{code}
  Λ-≻ : ∀ {L i} → i ≻tm (Λ L) → i ≻tm L
  Λ-≻ i≻ j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻ j
    in И⟨ Иe₁ , (λ a {a∉} → Λ-inj (Иe₂ a {a∉})) ⟩

  ‵suc-≻ : ∀ {L i} → i ≻tm (‵suc L) → i ≻tm L
  ‵suc-≻ i≻ j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻ j
    in И⟨ Иe₁ , (λ a {a∉} → ‵suc-inj (Иe₂ a {a∉})) ⟩

  []-≻ : ∀ {L A i} → i ≻tm (L [ A ]) → i ≻tm L
  []-≻ {L} {A} {i} i≻ j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻ j
    in И⟨ Иe₁ , (λ a {a∉} → proj₁ ([]-inj (Иe₂ a {a∉}))) ⟩
\end{code}

The two below properties are trivial, since the opening operation will do nothing as there are no
indices in the types.
\begin{code}
  n≻‵ℕ : ∀ {n : ℕ} → n ≻ty ‵ℕ
  n≻‵ℕ j = И⟨ [] , (λ _ → refl) ⟩

  ty-fr-lc : ∀ {A} → Ty-LocallyClosed (frᵀ A)
  ty-fr-lc j = И⟨ [] , (λ _ → refl) ⟩
\end{code}

And finally, we have a proof that for syntax which consists of two subexpressions, local closure can
be moved between the main expression and the subexpressions. This follows the same method of using
the hypothesis and injectivity.
\begin{code}
  ⇒-≻ : ∀ {A B i} → i ≻ty (A ⇒ B) → (i ≻ty A) × (i ≻ty B)
  ⇒-≻ {A} {B} {i} i≻A⇒B = ⟨ i≻A , i≻B ⟩
    where
      i≻A : i ≻ty A
      i≻A j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻A⇒B j
        in И⟨ Иe₁ , (λ a {a∉} → proj₁ (⇒-inj (Иe₂ a {a∉}))) ⟩
      i≻B : i ≻ty B
      i≻B j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻A⇒B j
        in И⟨ Иe₁ , (λ a {a∉} → proj₂ (⇒-inj (Иe₂ a {a∉}))) ⟩

  ≻-⇒ : ∀ {A B i} → i ≻ty A → i ≻ty B → i ≻ty (A ⇒ B)
  ≻-⇒ i≻A i≻B j =
    let И⟨ A-Иe₁ , A-Иe₂ ⟩ = i≻A j
        И⟨ B-Иe₁ , B-Иe₂ ⟩ = i≻B j
    in И⟨ A-Иe₁ ++ B-Иe₁ , (λ a {a∉} →
      let ⟨ a∉A , a∉B ⟩ = ∉-++ a∉
      in cong₂ _⇒_ (A-Иe₂ a {a∉A}) (B-Иe₂ a {a∉B})) ⟩

  ·-≻ : ∀ {L M i} → i ≻tm (L · M) → (i ≻tm L) × (i ≻tm M)
  ·-≻ {L} {M} {i} i≻ = ⟨ i≻L , i≻M ⟩
    where
      i≻L : i ≻tm L
      i≻L j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻ j
        in И⟨ Иe₁ , (λ a {a∉} → proj₁ (·-inj (Иe₂ a {a∉}))) ⟩
      i≻M : i ≻tm M
      i≻M j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻ j
        in И⟨ Иe₁ , (λ a {a∉} → proj₂ (·-inj (Иe₂ a {a∉}))) ⟩
\end{code}

One important lemma which will be used later is called \texttt{open-rec-lc-lemma} by
\citet{chargueraud_locally_2012} (his \texttt{open-rec-lc} is in fact Pitts Lemma 2.6 proven above).
It states that if applying an opening to an opened term leaves it unchanged, then the opening will
have no effect on the term.

The lemma is proven by induction on the structure of the term (or type for the other proofs). For
the base cases, the proof is immediate by reflexivity, and for the inductive cases, the inductive
hypothesis immediately gives the result, so the proof is left in Appendix
\ref{appendix:f_local_closure}.
\begin{code}
  open-rec-lc-lemma : ∀ {L : Term} {i j u v} → i ≢ j
    → tm-tm[ i —→ u ] (tm-tm[ j —→ v ] L) ≡ tm-tm[ j —→ v ] L
    → tm-tm[ i —→ u ] L ≡ L
\end{code}

As before, \texttt{open-rec-lc-lemma} holds true for combinations of other openings. The proofs of
the related versions of this lemma are also left in Appendix \ref{appendix:f_local_closure}.
\begin{code}
  open-rec-lc-lemma-ty : ∀ {A : Type} {i j u v} → i ≢ j
    → ty-ty[ i —→ u ] (ty-ty[ j —→ v ] A) ≡ ty-ty[ j —→ v ] A
    → ty-ty[ i —→ u ] A ≡ A
  open-rec-lc-lemma-ty-tm : ∀ {L : Term} {i j u v} → i ≢ j
    → ty-tm[ i —→ u ] (ty-tm[ j —→ v ] L) ≡ ty-tm[ j —→ v ] L
    → ty-tm[ i —→ u ] L ≡ L
  open-rec-lc-lemma-ty-tm-tm-tm : ∀ {L : Term} {i j u v}
    → ty-tm[ i —→ u ] (tm-tm[ j —→ v ] L) ≡ tm-tm[ j —→ v ] L
    → ty-tm[ i —→ u ] L ≡ L
\end{code}

\section{Free variables}
\label{chapter3:free_variables}
We want to collect free variables in terms and free type variables in terms and types. As before,
there are three such functions we need to define. The full definitions of the other two functions is
left in Appendix \ref{appendix:f_free_variables}.
\begin{code}
  fv-tm : Term → List Id
  fv-tm (fr x) = x ∷ []
  fv-tm (# i) = []
  fv-tm (ƛ L) = fv-tm L
  fv-tm (L · M) = fv-tm L ++ fv-tm M
  fv-tm (Λ L) = fv-tm L
  fv-tm (L [ A ]) = fv-tm L
  fv-tm ‵zero = []
  fv-tm (‵suc L) = fv-tm L

  ftv-ty : Type → List Id
  ftv-tm : Term → List Id
\end{code}
\begin{comment}
\begin{code}
  -- We're actually gonna something really sneaky here.
  -- We're including the full body here because Agda needs it to
  -- be defined so that it can use the definition in later proofs.
  -- So I'm just gonna copy-paste the body as non-Agda code later.

  ftv-ty ‵ℕ = []
  ftv-ty (frᵀ x) = x ∷ []
  ftv-ty (#ᵀ i) = []
  ftv-ty (A ⇒ B) = ftv-ty A ++ ftv-ty B
  ftv-ty (∀ᵀ A) = ftv-ty A

  ftv-tm (fr x) = []
  ftv-tm (# i) = []
  ftv-tm (ƛ L) = ftv-tm L
  ftv-tm (L · M) = ftv-tm L ++ ftv-tm M
  ftv-tm (Λ L) = ftv-tm L
  ftv-tm (L [ A ]) = ftv-tm L ++ ftv-ty A
  ftv-tm ‵zero = []
  ftv-tm (‵suc L) = ftv-tm L
\end{code}
\end{comment}

\section{Substitution of types and terms}
\label{chapter3:substitution_syntax}
We can substitute a term for a free variable in a term, and a type for a free type variable in a
term and a type. Thus, we have three functions. We define them recursively.
\begin{code}
  tm-tm[_:=_]_ : Id → Term → Term → Term
  tm-tm[ x := N ] (fr y) with x ≟lchar y
  ... | yes refl = N
  ... | no  _    = fr y
  tm-tm[ x := N ] (# k) = # k
  tm-tm[ x := N ] (ƛ L) = ƛ tm-tm[ x := N ] L
  tm-tm[ x := N ] (L · M) = (tm-tm[ x := N ] L) · (tm-tm[ x := N ] M)
  tm-tm[ x := T ] (Λ L) = Λ (tm-tm[ x := T ] L)
  tm-tm[ x := T ] (L [ A ]) = (tm-tm[ x := T ] L) [ A ]
  tm-tm[ x := N ] ‵zero = ‵zero
  tm-tm[ x := N ] (‵suc L) = ‵suc tm-tm[ x := N ] L
\end{code}
The definition of the other two substitution functions is in Appendix
\ref{appendix:f_substitution_of_terms}.
\begin{code}
  ty-ty[_:=_]_ : Id → Type → Type → Type
  ty-tm[_:=_]_ : Id → Type → Term → Term
\end{code}
\begin{comment}
\begin{code}
  ty-ty[ X := T ] ‵ℕ = ‵ℕ
  ty-ty[ X := T ] (frᵀ Y) with X ≟lchar Y
  ... | yes refl = T
  ... | no  _    = frᵀ Y
  ty-ty[ X := T ] (#ᵀ k) = #ᵀ k
  ty-ty[ X := T ] (A ⇒ B) = (ty-ty[ X := T ] A) ⇒ (ty-ty[ X := T ] B)
  ty-ty[ X := T ] (∀ᵀ A) = ∀ᵀ (ty-ty[ X := T ] A)

  ty-tm[ X := T ] (fr x) = fr x
  ty-tm[ X := T ] (# k) = # k
  ty-tm[ X := T ] (ƛ L) = ƛ (ty-tm[ X := T ] L)
  ty-tm[ X := T ] (L · M) = (ty-tm[ X := T ] L) · (ty-tm[ X := T ] M)
  ty-tm[ X := T ] (Λ L) = Λ (ty-tm[ X := T ] L)
  ty-tm[ X := T ] (L [ A ]) = (ty-tm[ X := T ] L) [ ty-ty[ X := T ] A ]
  ty-tm[ X := T ] ‵zero = ‵zero
  ty-tm[ X := T ] (‵suc L) = ‵suc ty-tm[ X := T ] L
\end{code}
\end{comment}

This substitution is central to proving evaluation properties, so we require two lemmas about its
interaction with local closure. The first proves that if types $A$ and $C$ are locally closed up to
$i$, then the substitution $[X := C] A$ is locally closed up to $i$ too. The proof is a consequence
of Lemma 2.6 and is done by induction on the structure of types. Since the proof is a
straight-forward induction, it has been detailed in Appendix \ref{appendix:f_substitution_of_terms}.
We only need the type-in-type opening version of this property.
\begin{code}
  :=-≻ : ∀ {A X C i j} → j ≥ i → i ≻ty A → i ≻ty C
    → j ≻ty (ty-ty[ X := C ] A)
\end{code}

The second is how types are invariant under substitution if the free type variable that is being
substituted for is absent in the type. We once again only require the result for type-in-type
substitution. The proof is a trivial induction and detailed in Appendix
\ref{appendix:f_substitution_of_terms}.
\begin{code}
  :=-∉-invariant : ∀ {A X B} → X ∉ ftv-ty A
    → (ty-ty[ X := B ] A) ≡ A
\end{code}

We also have an alternative substitution; substituting a term for a bound variable.
\citet{chargueraud_locally_2012} also calls this operation opening, since it is the same as opening
but instead of replacing the index with a free (type) variable, it is replaced with a term. I see
this operation closer to substitution than opening, and thus will call it substitution. Note how we
still increase the index when going under a $\lambda$-abstraction.
\begin{code}
  tm-tm[_:→_]_ : ℕ → Term → Term → Term
  tm-tm[ k :→ N ] (fr x) = fr x
  tm-tm[ k :→ N ] (# i) with k ≟ℕ i
  ... | yes refl = N
  ... | no  _    = # i
  tm-tm[ k :→ N ] (ƛ L) = ƛ tm-tm[ suc k :→ N ] L
  tm-tm[ k :→ N ] (L · M) =
    (tm-tm[ k :→ N ] L) · (tm-tm[ k :→ N ] M)
  tm-tm[ k :→ N ] (Λ L) = Λ tm-tm[ k :→ N ] L
  tm-tm[ k :→ N ] (L [ A ]) = (tm-tm[ k :→ N ] L) [ A ]
  tm-tm[ k :→ N ] ‵zero = ‵zero
  tm-tm[ k :→ N ] (‵suc L) = ‵suc tm-tm[ k :→ N ] L
\end{code}
The definition of the other two substitution functions is in Appendix
\ref{appendix:f_substitution_of_terms}.
\begin{code}
  ty-ty[_:→_]_ : ℕ → Type → Type → Type
  ty-tm[_:→_]_ : ℕ → Type → Term → Term
\end{code}
\begin{comment}
\begin{code}
  ty-ty[ k :→ T ] ‵ℕ = ‵ℕ
  ty-ty[ k :→ T ] (frᵀ x) = frᵀ x
  ty-ty[ k :→ T ] (#ᵀ i) with k ≟ℕ i
  ... | yes refl = T
  ... | no  _    = #ᵀ i
  ty-ty[ k :→ T ] (A ⇒ B) = (ty-ty[ k :→ T ] A) ⇒ (ty-ty[ k :→ T ] B)
  ty-ty[ k :→ T ] (∀ᵀ A) = ∀ᵀ (ty-ty[ (suc k) :→ T ] A)

  ty-tm[ k :→ T ] (fr x) = fr x
  ty-tm[ k :→ T ] (# i) = # i
  ty-tm[ k :→ T ] (ƛ L) = ƛ ty-tm[ k :→ T ] L
  ty-tm[ k :→ T ] (L · M) = (ty-tm[ k :→ T ] L) · (ty-tm[ k :→ T ] M)
  ty-tm[ k :→ T ] (Λ L) = Λ ty-tm[ suc k :→ T ] L
  ty-tm[ k :→ T ] (L [ A ]) = (ty-tm[ k :→ T ] L) [ ty-ty[ k :→ T ] A ]
  ty-tm[ k :→ T ] ‵zero = ‵zero
  ty-tm[ k :→ T ] (‵suc L) = ‵suc ty-tm[ k :→ T ] L
\end{code}
\end{comment}

Similar to before, we want to prove that if an index doesn't occur in a type, then substituting for
that index will leave the type unchanged. The proof once again is a trivial induction and so left in
Appendix \ref{appendix:f_substitution_of_terms}.
\begin{code}
  ≻⇒:→-invariant : ∀ {C i j} (A : Type) → j ≥ i
    → i ≻ty A
    → ty-ty[ j :→ C ] A ≡ A
\end{code}

\section{Type contexts}
\label{chapter3:contexts}
As previously described, type contexts keep track of free type variables and the type of free
variables. We shall refer to the last added (i.e. right-most) variable as being on the `top' of the
context. We can have an empty context, add a free variable of some type, or add a free type
variable.
\begin{code}
  data Context : Set where
    ∅ : Context
    _,_⦂_ : Context → Id → Type → Context
    _,_ : Context → Id → Context
\end{code}

As contexts
are isomorphic to lists \citep{wadler_programming_2022}, we can concatenate them and map over the
types of free variables.
\begin{code}
  _+_ : Context → Context → Context
  Γ + ∅ = Γ
  Γ + (Δ , x ⦂ A) = (Γ + Δ) , x ⦂ A
  Γ + (Δ , X) = (Γ + Δ) , X

  map : (Type → Type) → Context → Context
  map f ∅ = ∅
  map f (Γ , x ⦂ A) = (map f Γ) , x ⦂ f A
  map f (Γ , X) = (map f Γ) , X
\end{code}

\paragraph*{Domains.} The \textit{domain} of a context is a list of all the identifiers used. We
only interest ourselves with the free type variables that are contained in a context
(\texttt{domain-ftv}), and the free type variables in a context together with those contained in the
types of the free variables in the context (\texttt{domain-all-ftv}).
\begin{code}
  domain-ftv : Context → List Id
  domain-ftv ∅ = []
  domain-ftv (ctx , x ⦂ A) = domain-ftv ctx
  domain-ftv (ctx , X) = X ∷ domain-ftv ctx

  domain-all-ftv : Context → List Id
  domain-all-ftv ∅ = []
  domain-all-ftv (ctx , x ⦂ A) = (ftv-ty A) ++ domain-all-ftv ctx
  domain-all-ftv (ctx , X) = X ∷ domain-all-ftv ctx
\end{code}

We also have a few properties of concatenation and mapping. Since applying a map to a context
$\Gamma$ will only change the type of free variables, the free type variables will not change after
the map is applied. The proof is a simple induction on the structure of $\Gamma$ and so left in
Appendix \ref{appendix:f_contexts}.
\begin{code}
  domain-ftv-map-invariant : ∀ {Γ f}
    → domain-ftv Γ ≡ (domain-ftv (map f Γ))
\end{code}

We require two further lemmas about concatenation in the future. We can switch between context and
list concatenation, the proof of which is a simple induction on one of the contexts ($\Delta$ in the
below code block) and so left in Appendix \ref{appendix:f_contexts}.
\begin{code}
  domain-++ : ∀ (Γ Δ : Context)
    → (domain-ftv Δ) ++ (domain-ftv Γ) ≡ domain-ftv (Γ + Δ)
\end{code}

If $X \in \texttt{domain-ftv}(\Delta)$, then $X \in \texttt{domain-ftv}(\Gamma + \Delta)$.
\begin{code}
  domain-ftv-++ʳ : ∀ {X} (Γ Δ : Context)
    → X ∈ (domain-ftv Δ) → X ∈ domain-ftv (Γ + Δ)
  domain-ftv-++ʳ {X} Γ Δ X∈Δ = ∈-≡ (∈-++ˡ X∈Δ) (domain-++ Γ Δ)
\end{code}

\paragraph*{Ok environments.} We need a predicate to tell when an environment is well-formed, or
`Ok'. Any context where the following three rules hold is `Ok'.
\begin{itemize}
  \item An empty context is always `Ok'.
  \item Let $x$ be a free variable. If $x$'s type contains a free type variable, then $x$ must be
  added to the context after the free type variable (or in other words, the free type variable must
  be \textit{in scope}). We also restrict ourselves to locally closed types; we do not add any bound
  variables to the context, so we should not add any free variables whose type contains bound type
  variables either.
  \item There are no duplicate free type variables.
\end{itemize}
\begin{code}
  data Ok : Context → Set where
    ok-∅ : Ok ∅
    ok-∷fv : ∀ {Γ A x} → Ok Γ → Ty-LocallyClosed A
      → ftv-ty A ⊆ domain-ftv Γ → Ok (Γ , x ⦂ A)
    ok-∷ftv : ∀ {Γ X} → Ok Γ → X ∉ domain-all-ftv Γ → Ok (Γ , X)
\end{code}

Examples of proving that a context is `Ok' can be found below equation
(\ref{equation:twice_big_omega}).

We also have two convenience functions which are simple consequences of the definition of `Ok'.
\begin{code}
  ok-+ : ∀ {Γ Δ} → Ok (Γ + Δ) → Ok Γ
  ok-+ {Γ} {∅} okΓ = okΓ
  ok-+ {Γ} {Δ , x ⦂ A} (ok-∷fv ok+ _ _) = ok-+ ok+
  ok-+ {Γ} {Δ , X} (ok-∷ftv ok+ _) = ok-+ ok+

  extract-⊆ : ∀ {Γ x A} → Ok (Γ , x ⦂ A) → ftv-ty A ⊆ domain-ftv Γ
  extract-⊆ (ok-∷fv okΓ lc-A A⊆Γ) = A⊆Γ
\end{code}

\paragraph*{Accessing variables in the context.} We have two ways of accessing the context:
\begin{itemize}
  \item If a free variable is required, then the accessor is \texttt{\_∋\_⦂\_}.
  \item If a free type variable is required, then the accessor is \texttt{\_∋\_}.
\end{itemize}

Each accessor has three constructors; one for getting the variable at the top of the context, one
for going deeper with a free variable at the top, and one for going deeper with a free type variable
at the top.
\begin{code}
  data _∋_ : Context → Id → Set where
    Z : ∀ {Γ X} → (Γ , X) ∋ X
    S : ∀ {Γ X Y} → Γ ∋ X → (Γ , Y) ∋ X
    S⦂ : ∀ {Γ X y B} → Γ ∋ X → (Γ , y ⦂ B) ∋ X

  infix 4 _∋_⦂_
  data _∋_⦂_ : Context → Id → Type → Set where
    H : ∀ {Γ x y A} → x ≡ y → (Γ , x ⦂ A) ∋ y ⦂ A
    T : ∀ {Γ x y A B} → x ≢ y → (Γ ∋ x ⦂ A) → (Γ , y ⦂ B) ∋ x ⦂ A
    T⦂ : ∀ {Γ x Y A} → (Γ ∋ x ⦂ A) → (Γ , Y) ∋ x ⦂ A
\end{code}

We define two convenience functions to find the relevant evidence automatically. These are adapted
from \citet[chapter~Lambda]{wadler_programming_2022}.
\begin{code}
  H′ : ∀ {Γ x A} → (Γ , x ⦂ A) ∋ x ⦂ A
  H′ = H refl

  T′ : ∀ {Γ x y A B} {x≢y : False (x ≟lchar y)}
    → Γ ∋ x ⦂ A → (Γ , y ⦂ B) ∋ x ⦂ A
  T′ { x≢y = x≢y } x = T (toWitnessFalse x≢y) x
\end{code}

We also need some functions for switching between evidence that a variable is in the context and
evidence that a variable is in the domain of the context.
\begin{code}
  ∋⇒∈ : ∀ {Γ X} → Γ ∋ X → X ∈ domain-ftv Γ
  ∋⇒∈ Z = here refl
  ∋⇒∈ (S ∋X) = there (∋⇒∈ ∋X)
  ∋⇒∈ (S⦂ ∋X) = ∋⇒∈ ∋X

  ∈⇒∋ : ∀ {Γ X} → X ∈ domain-ftv Γ → Γ ∋ X
  ∈⇒∋ {Γ , x ⦂ A} X∈Γ = S⦂ (∈⇒∋ X∈Γ)
  ∈⇒∋ {Γ , Y} {X = X} (here X≡Y) with X ≟lchar Y
  ... | yes refl = Z
  ... | no  X≢Y  = contradiction X≡Y X≢Y
  ∈⇒∋ {Γ , Y} (there X∈Γ) = S (∈⇒∋ X∈Γ)

  ∉-domain-all-∋ : ∀ {Γ X x A} → X ∉ domain-all-ftv Γ → Γ ∋ x ⦂ A
    → X ∉ ftv-ty A
  ∉-domain-all-∋ X∉Γ (H refl) = proj₁ (∉-++ X∉Γ)
  ∉-domain-all-∋ X∉Γ (T _ ∋x) = ∉-domain-all-∋ (proj₂ (∉-++ X∉Γ)) ∋x
  ∉-domain-all-∋ X∉Γ (T⦂ ∋x) = ∉-domain-all-∋ (proj₂ (∉-++ X∉Γ)) ∋x

  ⊆-change-ctx : ∀ {Γ A Δ} → ftv-ty A ⊆ domain-ftv Γ
    → (∀ {X} → Γ ∋ X → Δ ∋ X)
    → ftv-ty A ⊆ domain-ftv Δ
  ⊆-change-ctx {Γ} {A} A⊆Γ ρ =
    All-map (λ px → ∋⇒∈ (ρ (∈⇒∋ px))) A⊆Γ
\end{code}

We would like to apply an equality in a context accessor. Specifically, if types $A$ and $B$ are
equal, then $\Gamma \ni x \colon A$ ought to be equal to $\Gamma \ni x \colon B$.
\begin{code}
  ≡-with-∋-ty : ∀ {Γ x A B} → Γ ∋ x ⦂ A → A ≡ B → Γ ∋ x ⦂ B
  ≡-with-∋-ty ∋x refl = ∋x
\end{code}

We also want to prove that (for an `Ok' context) removing a free type variable from the context can
be done by applying a substitution, and importantly, that this changes the type of a free variable.
We express the context as $\Gamma, X, \Delta$ and induct on the structure of $\Delta$.
\begin{code}
  ∋-map-ftv : ∀ {Γ X x A C} (Δ : Context)
    → Ok ((Γ , X) + Δ)
    → ((Γ , X) + Δ) ∋ x ⦂ A
    → Γ + (map (ty-ty[ X := C ]_) Δ) ∋ x ⦂ (ty-ty[ X := C ] A)
  ∋-map-ftv ∅ (ok-∷ftv okΓ X∉Γ) (T⦂ ∋x) = ≡-with-∋-ty
    ∋x
    (sym (:=-∉-invariant (∉-domain-all-∋ X∉Γ ∋x)))
\end{code}
If $\Delta$ is empty, then $X$ cannot occur in the type of $x$, as $X$ hasn't been bound when $x$
was added to the context.
\begin{code}
  ∋-map-ftv (Δ , y ⦂ B) _ (H refl) = H′
\end{code}
If the free variable is at the top of $\Delta$, then the map is applied and the variable has the
type we want, so we can simply use \texttt{H′}.
\begin{code}
  ∋-map-ftv (Δ , y ⦂ B) (ok-∷fv okΓ+Δ _ _) (T x≢y ∋x) =
    T x≢y (∋-map-ftv Δ okΓ+Δ ∋x)
  ∋-map-ftv (Δ , Y) (ok-∷ftv okΓ,X+Δ Y∉) (T⦂ ∋x) =
    T⦂ (∋-map-ftv Δ okΓ,X+Δ ∋x)
\end{code}
In the other cases, we use \texttt{T} \texttt{T⦂} together with the induction hypothesis.

The other proof we need is that if the free type variables of $A$ are in $\Gamma, X, \Delta$, then
after applying a substitution, they will still be in the new context. We prove this by inducting on
the structure of the type $A$.
\begin{code}
  ftv⊆dom-:= : ∀ {X A C} (Γ Δ : Context)
     → Ty-LocallyClosed C
     → ftv-ty C ⊆ domain-ftv Δ
     → Ok (Γ + (map (ty-ty[ X := C ]_) Δ))
     → ftv-ty A ⊆ domain-ftv ((Γ , X) + Δ)
       -------------------------------------------
     → ftv-ty (ty-ty[ X := C ] A)
         ⊆ domain-ftv (Γ + map (ty-ty[ X := C ]_) Δ)
  ftv⊆dom-:= {X} {‵ℕ} Γ Δ lc-C C⊆Δ okΓ+map A⊆dom = All.[]
\end{code}
If the type is $\nat$, then it's vacuously true.
\begin{code}
  ftv⊆dom-:= {X} {frᵀ Y} {C} Γ Δ _ C⊆Δ _ (Y∈ All.∷ All.[])
    with X ≟lchar Y
  ... | yes refl = All-map
    (λ x∈ → domain-ftv-++ʳ Γ (map (ty-ty[ X := C ]_) Δ)
      (∈-≡ x∈ (domain-ftv-map-invariant {Δ} {ty-ty[ X := C ]_})))
    C⊆Δ
  ... | no  X≢Y  = (helper Δ Y∈ (sym-≢ X≢Y)) All.∷ All.[]
    where
      helper : ∀ {Γ X Y} (Δ : Context)
        → Y ∈ domain-ftv ((Γ , X) + Δ)
        → Y ≢ X
        → Y ∈ domain-ftv (Γ + map (ty-ty[_:=_]_ X C) Δ)
      helper ∅ (here refl) Y≢X = contradiction refl Y≢X
      helper ∅ (there Y∈) Y≢X = Y∈
      helper (Δ , z ⦂ C) Y∈ Y≢X = helper Δ Y∈ Y≢X
      helper (Δ , W) (here refl) Y≢X = here refl
      helper (Δ , W) (there Y∈) Y≢X = there (helper Δ Y∈ Y≢X)
\end{code}
If it is a free type variable $Y$, then we need to check whether it is equal to $X$. If it is, we
use the assumption \texttt{ftv-ty C ⊆ domain-ftv Δ} and apply the mapping to the context. If not, we
need to prove that $Y$ will still be in the context after the map. This is proven using
\texttt{helper}, which itself is proven by a trivial induction.
\begin{code}
  ftv⊆dom-:= {X} {#ᵀ n} Γ Δ lc-C C⊆Δ okΓ+map A⊆dom = All.[]
\end{code}
If it's a bound type variable, it is again vacuously true.
\begin{code}
  ftv⊆dom-:= {X} {A ⇒ B} Γ Δ lc-C C⊆Δ okΓ+map ⊆dom =
    let ⟨ A⊆ , B⊆ ⟩ = ⊆-++ ⊆dom
    in ++-⊆
      (ftv⊆dom-:= {A = A} Γ Δ lc-C C⊆Δ okΓ+map A⊆)
      (ftv⊆dom-:= {A = B} Γ Δ lc-C C⊆Δ okΓ+map B⊆)
  ftv⊆dom-:= {X} {∀ᵀ A} Γ Δ lc-C C⊆Δ okΓ+map A⊆dom =
    ftv⊆dom-:= {X} {A} Γ Δ lc-C C⊆Δ okΓ+map A⊆dom
\end{code}
The last cases are the inductive steps and are trivial.

\section{Type judgements}
\label{chapter3:type_judgements}
Modifying the ones presented in \citet{chargueraud_locally_2012}, since he uses subtyping, System F
has these type judgements (a version with more familiar mathematical notation is given in Appendix \ref{appendix:f_type_judgements}):
\begin{code}
  infix  4 _⊢_⦂_
  data _⊢_⦂_ : Context → Term → Type → Set where
    ⊢free : ∀ {Γ x A}
      → Ok Γ
      → Ty-LocallyClosed A
      → Γ ∋ x ⦂ A
        ----------------
      → Γ ⊢ fr x ⦂ A

    ⊢ƛ : ∀ {Γ L A B}
      → Ty-LocallyClosed A
      → И x , (Γ , x ⦂ A ⊢ tm-tm[ 0 —→ x ] L ⦂ B)
        ------------------------------------
      → Γ ⊢ ƛ L ⦂ (A ⇒ B)

    ⊢· : ∀ {Γ L M A B}
      → Γ ⊢ L ⦂ (A ⇒ B)
      → Γ ⊢ M ⦂ A
        ---------------
      → Γ ⊢ L · M ⦂ B

    ⊢Λ : ∀ {Γ L B}
      → И T , ((Γ , T) ⊢ ty-tm[ 0 —→ T ] L ⦂ (ty-ty[ 0 —→ T ] B))
        ----------------------------------------------------
      → Γ ⊢ Λ L ⦂ ∀ᵀ B

    ⊢[] : ∀ {Γ L A B}
      → Ty-LocallyClosed A
      → ftv-ty A ⊆ domain-ftv Γ
      → Γ ⊢ L ⦂ ∀ᵀ B
        ---------------------------
      → Γ ⊢ L [ A ] ⦂ ty-ty[ 0 :→ A ] B

    ⊢zero : ∀ {Γ}
      → Ok Γ
        -----------
      → Γ ⊢ ‵zero ⦂ ‵ℕ

    ⊢suc : ∀ {Γ L}
      → Γ ⊢ L ⦂ ‵ℕ
        -------------
      → Γ ⊢ ‵suc L ⦂ ‵ℕ
\end{code}

Observe there is a rule for typing a free variable but not a bound variable. Now consider the
$\vdash\lambdabar$ rule. Since the term $L$ will contain bound variables, we will open the term to
replace these with a free variable. We use cofinite quantification to choose an identifier for the
free variable which does not cause accidental shadowing. Since we will replace all bound variables
with free variables using this opening operation, we only require a type rule for free variables.

The only real difference between these and the rules presented by \citet{chargueraud_locally_2012}
(besides the subtyping) is in $\vdash[]$. We add an explicit rule to only allow a type-application
for types where the free variables are entirely contained in the context. Recall that we restrict
our metalanguage to closed terms, those without free (type) variables. Thus, all free (type)
variables must be contained in the context. We did not need this explicit rule for free variables as
their presence in the context is guaranteed by the $\vdash\text{free}$ rule. But as free type
variables are eliminated in the $\vdash[]$ rule, we need to put this guarantee here.

We can give a type to \textit{twice} and $\omega$ now.
\begin{align}
\label{equation:twice_big_omega}
  \text{twice} &\triangleq (\Lambda \lambda \colon \mathbf{0} \to \mathbf{0}. \lambda \colon \mathbf{0}. 1(10))
    \colon \forall (\mathbf{0} \to \mathbf{0}) \to \mathbf{0} \to \mathbf{0}\\
  \omega &\triangleq (\lambda \colon (\forall \mathbf{0} \to \mathbf{0}). (0 [\forall \mathbf{0} \to \mathbf{0}]) 0)
    \colon (\forall \mathbf{0} \to \mathbf{0}) \to (\forall \mathbf{0} \to \mathbf{0}) \notag
\end{align}
\begin{code}
  twice : ∅ ⊢ (Λ ƛ (ƛ ((# 1) · ((# 1) · (# 0)))))
      ⦂ ∀ᵀ (((#ᵀ 0) ⇒ (#ᵀ 0)) ⇒ ((#ᵀ 0) ⇒ (#ᵀ 0)))
  twice = ⊢Λ И⟨ [] , (λ X {X∉} → ⊢ƛ fr⇒fr-lc И⟨ [] , (λ f {f∉} →
    ⊢ƛ ty-fr-lc И⟨ (f ∷ []) , (λ x {x∉} → ⊢·
      (⊢free ok-ctx fr⇒fr-lc (T (f≢x x∉) H′))
      (⊢·
        (⊢free ok-ctx fr⇒fr-lc (T (f≢x x∉) H′))
        (⊢free ok-ctx ty-fr-lc H′))) ⟩) ⟩) ⟩
    where
      fr⇒fr-lc : ∀ {A} → Ty-LocallyClosed (frᵀ A ⇒ frᵀ A)
      fr⇒fr-lc j = И⟨ [] , (λ _ → refl) ⟩
      f≢x : ∀ {f x} → x ∉ f ∷ [] → f ≢ x
      f≢x x∉ = sym-≢ (∉∷[]⇒≢ x∉)
      ok-ctx : ∀ {f X x}
        → Ok (((∅ , X) , f ⦂ (frᵀ X ⇒ frᵀ X)) , x ⦂ frᵀ X)
      ok-ctx = ok-∷fv
                  (ok-∷fv (ok-∷ftv ok-∅ (λ ()))
                    fr⇒fr-lc
                    (here refl All.∷ here refl All.∷ All.[]))
                  ty-fr-lc
                  ((here refl) All.∷ All.[])

  Ω : ∅ ⊢ (ƛ (((# 0) [ ∀ᵀ ((#ᵀ 0) ⇒ (#ᵀ 0)) ]) · (# 0)))
      ⦂ (∀ᵀ ((#ᵀ 0) ⇒ (#ᵀ 0))) ⇒ (∀ᵀ ((#ᵀ 0) ⇒ (#ᵀ 0)))
  Ω = ⊢ƛ lc-forall И⟨ [] , (λ x {x∉} →
    ⊢·
      (⊢[] lc-forall All.[] (⊢free ok-ctx lc-forall H′))
      (⊢free ok-ctx lc-forall H′)) ⟩
    where
      lc-forall : Ty-LocallyClosed (∀ᵀ (#ᵀ 0 ⇒ #ᵀ 0))
      lc-forall j = И⟨ [] , (λ _ → refl) ⟩
      ok-ctx : ∀ {x} →  Ok (∅ , x ⦂ (∀ᵀ (#ᵀ 0 ⇒ #ᵀ 0)))
      ok-ctx = ok-∷fv ok-∅ lc-forall All.[]
\end{code}

We want to apply an equality in a type judgement, so we define helper functions as we have before.
\begin{code}
  ≡-with-⊢-tm : ∀ {Γ L M A} → Γ ⊢ L ⦂ A → L ≡ M → Γ ⊢ M ⦂ A
  ≡-with-⊢-tm ⊢L refl = ⊢L
  ≡-with-⊢-ty : ∀ {Γ L A B} → Γ ⊢ L ⦂ A → A ≡ B → Γ ⊢ L ⦂ B
  ≡-with-⊢-ty ⊢L refl = ⊢L
  ≡-with-⊢-ctx : ∀ {Γ Δ L A} → Γ ⊢ L ⦂ A → Γ ≡ Δ → Δ ⊢ L ⦂ A
  ≡-with-⊢-ctx ⊢L refl = ⊢L
\end{code}

\section{Typing properties}
\label{chapter3:typing_properties}
We first would like to show that all well-typed terms have an `Ok' environment. This is proven with
a simple induction on the type judgement.
\begin{code}
  ⊢⇒Ok : ∀ {Γ L A} → Γ ⊢ L ⦂ A → Ok Γ
  ⊢⇒Ok (⊢free okΓ lc-A ∋x) = okΓ
  ⊢⇒Ok (⊢ƛ lc-A И⟨ Иe₁ , Иe₂ ⟩)
    with ⊢⇒Ok (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
  ... | ok-∷fv OkΓ _ _ = OkΓ
  ⊢⇒Ok (⊢· ⊢L ⊢LM) = ⊢⇒Ok ⊢L
  ⊢⇒Ok (⊢Λ И⟨ Иe₁ , Иe₂ ⟩)
    with ⊢⇒Ok (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
  ... | ok-∷ftv OkΓ _ = OkΓ
  ⊢⇒Ok (⊢[] lc-A _ ⊢L) = ⊢⇒Ok ⊢L
  ⊢⇒Ok (⊢zero OkΓ) = OkΓ
  ⊢⇒Ok (⊢suc ⊢L) = ⊢⇒Ok ⊢L
\end{code}

If we have a map which takes evidence that a context contains a free variable to a different
context, then we can extend the two contexts with another free variable.
\begin{code}
  ext-tm : ∀ {Γ Δ}
    → (∀ {x A}     →        Γ ∋ x ⦂ A →         Δ ∋ x ⦂ A)
    → (∀ {x y A B} → Γ , y ⦂ B ∋ x ⦂ A → Δ , y ⦂ B ∋ x ⦂ A)
  ext-tm ρ (H refl) = H′
  ext-tm ρ (T x≢y ∋x) = T x≢y (ρ ∋x)

  ext-ty : ∀ {Γ Δ}
    → (∀ {X}   →       Γ ∋ X →       Δ ∋ X)
    → (∀ {X Y} → (Γ , Y) ∋ X → (Δ , Y) ∋ X)
  ext-ty ρ Z = Z
  ext-ty ρ (S ∋X) = S (ρ ∋X)

  ext-tm-ty : ∀ {Γ Δ}
    → (∀ {x A}   →       Γ ∋ x ⦂ A →       Δ ∋ x ⦂ A)
    → (∀ {x Y A} → (Γ , Y) ∋ x ⦂ A → (Δ , Y) ∋ x ⦂ A)
  ext-tm-ty ρ (T⦂ ∋x) = T⦂ (ρ ∋x)

  ext-ty-tm : ∀ {Γ Δ}
    → (∀ {X}     →          Γ ∋ X →           Δ ∋ X)
    → (∀ {X y A} → (Γ , y ⦂ A) ∋ X → (Δ , y ⦂ A) ∋ X)
  ext-ty-tm ρ (S⦂ ∋X) = S⦂ (ρ ∋X)
\end{code}
Let $x$ be a variable identifier and $y$ be the identifier of the new variable to be added to the
context. In each instance of the lemma, if $y = x$, then we are already done and simply return $x$.
Otherwise, we use the relevant constructor to go one step deeper into the context and then apply the
mapping.

The renaming property is a good example to explain the inductive hypothesis when dealing with
cofinite quantification. The proof is by induction on the evidence that $L$ is well-typed in
$\Gamma$.
\begin{code}
  rename : ∀ {Γ Δ}
    → Ok Δ
    → (∀ {x A} → Γ ∋ x ⦂ A → Δ ∋ x ⦂ A)
    → (∀ {X} → Γ ∋ X → Δ ∋ X)
      ---------------------------------
    → (∀ {L A} → Γ ⊢ L ⦂ A → Δ ⊢ L ⦂ A)
  rename okΔ ρ-tm ρ-ty (⊢free okΓ lc-A x) = ⊢free okΔ lc-A (ρ-tm x)
\end{code}
We use \texttt{ρ-tm} to refer to the map that takes evidence that a free variable is in $\Gamma$ to
evidence that the free variable is in $\Delta$, and \texttt{ρ-ty} for the same using free type
variables. The case for a free variable is a simple use \texttt{ρ-tm}.
\begin{code}
  rename okΔ ρ-tm ρ-ty (⊢· ⊢A⇒B ⊢A) =
    ⊢· (rename okΔ ρ-tm ρ-ty ⊢A⇒B) (rename okΔ ρ-tm ρ-ty ⊢A)
\end{code}
The $\vdash\cdot$ case is simply an application of the inductive hypothesis.
\begin{code}
  rename {Γ} {Δ} okΔ ρ-tm ρ-ty (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢Λ И⟨ Иe₁ ++ domain-all-ftv Δ , (λ T {T∉} →
      let ⟨ T∉Иe₁ , T∉Δ ⟩ = ∉-++ T∉
      in rename
        (ok-∷ftv okΔ T∉Δ)
        (ext-tm-ty ρ-tm)
        (ext-ty ρ-ty)
        (Иe₂ T {T∉Иe₁}) ) ⟩
\end{code}
The $\vdash\Lambda$ case is more complex. First, the type judgement is deconstructed: \texttt{⊢Λ И⟨
Иe₁ , Иe₂ ⟩}. The function \texttt{Иe₂} will give evidence of the type judgement $\Gamma , T \vdash
[0 \to T] L \colon [0 \to T] B$ for some identifier $T \notin \texttt{Иe₁}$.

We need to create our own $\vdash\Lambda$ type judgement and then create our own cofinite
quantification. We will use the list the assumption's \texttt{Иe₁} for the identifiers we will
disallow but also append all identifiers used for the free type variables in the types of free
variables in $\Delta$ (\texttt{domain-all-ftv Δ}). Then we use a lambda function to receive a $T$
that is not in the list we just defined.

We can then call \texttt{Иe₂} with our newly created $T$. We induct by calling \texttt{rename} on
the evidence given be \texttt{Иe₂} (along with the other necessary arguments).

Notice that if we did not use cofinite quantification, we could not create a $T$ which is both not
in \texttt{Иe₁} and not in \texttt{domain-all-ftv Δ}.
\begin{code}
  rename {Γ} {Δ} okΔ ρ-tm ρ-ty {_} {A ⇒ B} (⊢ƛ lc-A И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢ƛ lc-A И⟨ Иe₁ , (λ a {a∉} →
      rename
        (OkΔ,x a a∉)
        (ext-tm ρ-tm)
        (ext-ty-tm ρ-ty)
        (Иe₂ a {a∉})) ⟩
    where
      OkΔ,x : (x : Id) → x ∉ Иe₁ → Ok (Δ , x ⦂ A)
      OkΔ,x x x∉ with ⊢⇒Ok (Иe₂ x {x∉})
      ... | ok-∷fv OkΓ lc-A ftvA⊆Γ =
        ok-∷fv okΔ lc-A (⊆-change-ctx {Γ} {A} ftvA⊆Γ ρ-ty)
\end{code}
The case for $\vdash\lambdabar$ is very similar, except that we do not need to append any other list
to \texttt{Иe₁} in our own cofinite quantification.
\begin{code}
  rename okΔ ρ-tm ρ-ty (⊢[] lc A⊆Γ ⊢L) = ⊢[]
    lc
    (All-map (λ px → ∋⇒∈ (ρ-ty (∈⇒∋ px))) A⊆Γ)
    (rename okΔ ρ-tm ρ-ty ⊢L)
\end{code}
For a type application $\vdash[]$, we need to transform the evidence of $\ftv(A) \subseteq \Gamma$
to the new context $\ftv(A) \subseteq \Delta$. We do this by applying the \texttt{ρ-ty} assumption
on each of the free type variables, using \texttt{∈⇒∋} and \texttt{∋⇒∈} to help switch between
context and list inclusion. The rest is just an application of the inductive hypothesis.
\begin{code}
  rename okΔ ρ-tm ρ-ty (⊢zero okΓ) = ⊢zero okΔ
  rename okΔ ρ-tm ρ-ty (⊢suc ⊢L) = ⊢suc (rename okΔ ρ-tm ρ-ty ⊢L)
\end{code}
The $\vdash\text{zero}$ case is trivial and $\vdash\text{suc}$ is a simple application of the
inductive hypothesis.

We have a few remaining properties. If a term is well-typed in the empty context, it is well-typed
in any context. This is proven using \texttt{rename} where the mappings are constructed using the
absurd pattern since there are no variables in the empty context.
\begin{code}
  weaken : ∀ {Γ L A} → Ok Γ → ∅ ⊢ L ⦂ A → Γ ⊢ L ⦂ A
  weaken okΓ ⊢L = rename okΓ (λ ()) (λ ()) ⊢L
\end{code}

We want to swap variables at the top of the context and drop shadowed ones. As these are a corollary
of the \texttt{rename} lemma, their proof is left in Appendix \ref{appendix:f_type_properties}.
\begin{code}
  swap : ∀ {Γ x y L A B C}
    → x ≢ y
    → (Γ , y ⦂ B) , x ⦂ A ⊢ L ⦂ C
    → (Γ , x ⦂ A) , y ⦂ B ⊢ L ⦂ C

  swap-tm-ty : ∀ {Γ X y L B C}
    → ((Γ , y ⦂ B) , X) ⊢ L ⦂ C
    → (Γ , X) , y ⦂ B ⊢ L ⦂ C

  drop : ∀ {Γ x L A B C}
    → (Γ , x ⦂ A) , x ⦂ B ⊢ L ⦂ C
    → Γ , x ⦂ B ⊢ L ⦂ C
\end{code}

Note, the proofs of \texttt{ext-*}, \texttt{weaken}, \texttt{swap-*}, and \texttt{drop} are closely
adapted from \citep[chapter~Properties]{wadler_programming_2022}.

The next lemma is called \texttt{subst-open} by \citet{chargueraud_locally_2012}. This will be used
in the main substitution properties later (\texttt{subst} and \texttt{subst-ty}). The proof is a
trivial induction on the structure of the term. Note that this is for a term-in-term
substitution.
\begin{code}
  subst-open : ∀ {N x y i} (L : Term)
    → x ≢ y → (i ≻tm N)
    → tm-tm[ x := N ] (tm-tm[ i —→ y ] L)
      ≡ tm-tm[ i —→ y ] (tm-tm[ x := N ] L)
  subst-open {x = x} (fr z) x≢y i≻u with x ≟lchar z
  ... | yes refl = sym (lemma2·7-2-tm ≤-refl i≻u)
  ... | no  _    = refl
  subst-open {_} {x} {y} {i} (# k) x≢y i≻u with i ≟ℕ k
  ... | no  _ = refl
  ... | yes refl with x ≟lchar y
  ...    | yes refl = contradiction refl x≢y
  ...    | no  _    = refl
  subst-open {i = i} (ƛ L) x≢y i≻u = cong ƛ_
    (subst-open L x≢y (lemma2·6-tm (n≤1+n i) i≻u))
  subst-open (L · M) x≢y i≻u = cong₂ _·_
    (subst-open L x≢y i≻u) (subst-open M x≢y i≻u)
  subst-open (Λ L) x≢y i≻u = cong Λ_ (subst-open L x≢y i≻u)
  subst-open (L [ A ]) x≢y i≻u =
    cong₂ _[_] (subst-open L x≢y i≻u) refl
  subst-open ‵zero x≢y i≻u = refl
  subst-open (‵suc L) x≢y i≻u = cong ‵suc_ (subst-open L x≢y i≻u)
\end{code}

We want to apply this to a term in a type judgement, so we define this helper function.
\begin{code}
  subst-open-ctx : ∀ {Γ A N x y i} (L : Term)
    → x ≢ y → (i ≻tm N)
    → Γ ⊢ tm-tm[ x := N ] (tm-tm[ i —→ y ] L) ⦂ A
    → Γ ⊢ tm-tm[ i —→ y ] (tm-tm[ x := N ] L) ⦂ A
  subst-open-ctx L x≢y i≻N assump =
    ≡-with-⊢-tm assump (subst-open L x≢y i≻N)
\end{code}

We now prove \texttt{subst-open} for the other kinds of substitution. As their proofs are similarly
a trivial induction, their proofs are placed in Appendix \ref{appendix:f_type_properties}.
\begin{code}
  subst-open-ty-tm : ∀ {N x y i j} (L : Term)
    → x ≢ y → j ≥ i → (i ≻ty-tm N)
    → tm-tm[ x := N ] (ty-tm[ j —→ y ] L)
      ≡ ty-tm[ j —→ y ] (tm-tm[ x := N ] L)
  subst-open-ty-tm-ctx : ∀ {Γ A N x y i j} (L : Term)
    → x ≢ y → j ≥ i → (i ≻ty-tm N)
    → Γ ⊢ tm-tm[ x := N ] (ty-tm[ j —→ y ] L) ⦂ A
    → Γ ⊢ ty-tm[ j —→ y ] (tm-tm[ x := N ] L) ⦂ A

  subst-open-ty-tm-tm-tm : ∀ {C x y i j} (L : Term)
    → j ≥ i → (i ≻ty C)
    → ty-tm[ x := C ] (tm-tm[ j —→ y ] L)
      ≡ tm-tm[ j —→ y ] (ty-tm[ x := C ] L)
  subst-open-ty-tm-tm-tm-ctx : ∀ {Γ A C x y i j} (L : Term)
    → j ≥ i → (i ≻ty C)
    → Γ ⊢ ty-tm[ x := C ] (tm-tm[ j —→ y ] L) ⦂ A
    → Γ ⊢ tm-tm[ j —→ y ] (ty-tm[ x := C ] L) ⦂ A

  subst-open-ty-ty-ty-ty : ∀ {C x y i j} (A : Type)
    → x ≢ y → j ≥ i → (i ≻ty C)
    → ty-ty[ x := C ] (ty-ty[ j —→ y ] A)
      ≡ ty-ty[ j —→ y ] (ty-ty[ x := C ] A)
  subst-open-ty-ty-ty-ty-ctx : ∀ {Γ L C A x y i j}
    → x ≢ y → j ≥ i → (i ≻ty C)
    → Γ ⊢ L ⦂ ty-ty[ x := C ] (ty-ty[ j —→ y ] A)
    → Γ ⊢ L ⦂ ty-ty[ j —→ y ] (ty-ty[ x := C ] A)

  subst-open-ty-tm-ty-tm : ∀ {C x y i j} (L : Term)
    → x ≢ y → j ≥ i → (i ≻ty C)
    → ty-tm[ x := C ] (ty-tm[ j —→ y ] L)
      ≡ ty-tm[ j —→ y ] (ty-tm[ x := C ] L)
  subst-open-ty-tm-ty-tm-ctx : ∀ {Γ L A C x y i j}
    → x ≢ y → j ≥ i → (i ≻ty C)
    → Γ ⊢ ty-tm[ x := C ] (ty-tm[ j —→ y ] L) ⦂ A
    → Γ ⊢ ty-tm[ j —→ y ] (ty-tm[ x := C ] L) ⦂ A
\end{code}

To swap between the two substitutions, we have a lemma called \texttt{subst-intro} by
\citet{chargueraud_locally_2012}. It says that, so long as we choose a fresh identifier $x$, we can
swap between \texttt{:=} with opening and \texttt{:→}. The proof is a trivial induction, and so is
detailed in Appendix \ref{appendix:f_type_properties}.
\begin{code}
  subst-intro : ∀ {x i} (L N : Term) → x ∉ fv-tm L
    → tm-tm[ i :→ N ] L ≡ tm-tm[ x := N ] (tm-tm[ i —→ x ] L)
  subst-intro-ty-ty : ∀ {x i B} (A : Type) → x ∉ ftv-ty A
    → ty-ty[ i :→ B ] A ≡ ty-ty[ x := B ] (ty-ty[ i —→ x ] A)
  subst-intro-ty-tm : ∀ {x i B} (L : Term) → x ∉ ftv-tm L
    → ty-tm[ i :→ B ] L ≡ ty-tm[ x := B ] (ty-tm[ i —→ x ] L)
\end{code}

\section{Well-typed terms are locally closed}
\label{chapter3:typed_is_locally_closed}
If the typing rules are correct, then all well-typed terms are locally closed. Intuitively, this is
because we only allow closed terms in our language. We prove this by inducting on the type
judgement.
\begin{code}
  ⊢⇒lc : ∀ {Γ L A} → Γ ⊢ L ⦂ A → Tm-LocallyClosed L
  ⊢⇒lc (⊢free okΓ lc-A ∋x) j = И⟨ [] , (λ _ → refl) ⟩
  ⊢⇒lc (⊢ƛ lc-A И⟨ Иe₁ , Иe₂ ⟩) j = И⟨ Иe₁ , (λ a {a∉} → cong ƛ_
    (open-rec-lc-lemma (λ ())
      (lemma2·7-2-tm z≤n (⊢⇒lc (Иe₂ a {a∉}))))) ⟩
\end{code}
The $\vdash\text{free}$ case is trivial. For the $\vdash\lambda$ case, since the type judgement is
in the form of a cofinite quantification, we need to create a cofinite quantification ourselves and
use the same finite set for our exceptions. Then the lambda function gives an identifier $a$ which
is not in \texttt{Иe₁}. We can use this $a$ with the inductive hypothesis, which is called using
\texttt{⊢⇒lc (Иe₂ a {a∉})}. Then we simply apply \texttt{open-rec-lc-lemma} to complete the proof
for this case.
\begin{code}
  ⊢⇒lc {Γ} (⊢· ⊢A⇒B ⊢A) _ = И⟨ [] , (λ _ → cong₂ _·_
    (lemma2·7-2-tm z≤n (⊢⇒lc ⊢A⇒B))
    (lemma2·7-2-tm z≤n (⊢⇒lc ⊢A))) ⟩
  ⊢⇒lc {Γ} (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) j =
    И⟨ Иe₁ , (λ a {a∉} →
      cong Λ_ (lemma2·7-2-tm z≤n
        (helper z≤n (⊢⇒lc (Иe₂ a {a∉}))))) ⟩
    where
      helper : ∀ {N i k q x} → k ≥ i → i ≻tm (ty-tm[ q —→ x ] N)
        → k ≻tm N
      helper {fr x} {k = k} k≥i i≻ty j = i≻ty k ⦃ k≥i ⦄
      helper {# n} k≥i i≻ty = lemma2·6-tm k≥i i≻ty
      helper {ƛ N} {i} {k} {q} {x} k≥i i≻ty j =
        let induc-hypo = helper {k = suc i} (≤-refl) (≻ƛ⇒s≻ƛ i≻ty)
            И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo (suc j) ⦃ s≤s (≤-trans k≥i it) ⦄
        in И⟨ Иe₁ , (λ a {a∉} → cong ƛ_ (Иe₂ a {a∉})) ⟩
      helper {N · N₁} k≥i i≻ty j =
        let ⟨ i≻L  , i≻M ⟩ = ·-≻ i≻ty
            И⟨ L-Иe₁ , L-Иe₂ ⟩ = (helper k≥i i≻L) j
            И⟨ M-Иe₁ , M-Иe₂ ⟩ = (helper k≥i i≻M) j
          in И⟨ (L-Иe₁ ++ M-Иe₁) , (λ a {a∉} → cong₂ _·_
            (L-Иe₂ a {proj₁ (∉-++ a∉)})
            (M-Иe₂ a {proj₂ (∉-++ {xs = L-Иe₁} a∉)})) ⟩
      helper {Λ N} k≥i i≻ty j =
        let И⟨ Иe₁ , Иe₂ ⟩ = (helper k≥i (Λ-≻ i≻ty)) j
        in И⟨ Иe₁ , (λ a {a∉} → cong Λ_ (Иe₂ a {a∉})) ⟩
      helper {N [ A ]} k≥i i≻ty j =
        let И⟨ Иe₁ , Иe₂ ⟩ = (helper k≥i ([]-≻ i≻ty)) j
        in И⟨ Иe₁ , (λ a {a∉} → cong _[ A ] (Иe₂ a {a∉})) ⟩
      helper {‵zero} k≥i i≻ty j = И⟨ [] , (λ _ → refl) ⟩
      helper {‵suc N} k≥i i≻ty j =
        let И⟨ Иe₁ , Иe₂ ⟩ = (helper k≥i (‵suc-≻ i≻ty)) j
        in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩
\end{code}
For the $\vdash\Lambda$ case, we need a helper function which is very similar to Lemma 2.6. It says
that, if a term is locally closed at $i$ after opening, it will also be locally closed at $i$ (and
any greater number) for the unopened term. This is itself proven by induction on the term. The rest
is proven using Lemma 2.7-2.
\begin{code}
  ⊢⇒lc {L = L [ A ]} (⊢[] _ _ ⊢L) j =
    let И⟨ Иe₁ , Иe₂ ⟩ = (⊢⇒lc ⊢L) j
    in И⟨ Иe₁ , (λ a {a∉} → cong _[ A ]  (Иe₂ a {a∉})) ⟩
  ⊢⇒lc (⊢zero _) j = И⟨ [] , (λ _ → refl) ⟩
  ⊢⇒lc (⊢suc ⊢L) j = let И⟨ Иe₁ , Иe₂ ⟩ = (⊢⇒lc ⊢L) j
    in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩
\end{code}
The remaining cases are a simple induction, once again, using cofinite quantification by reusing the
same list of exceptions.

The proofs for the other two local closure predicates are in Appendix
\ref{appendix:f_well_typed_lc}.
\begin{code}
  ⊢⇒lc-ty : ∀ {Γ L A} → Γ ⊢ L ⦂ A → Ty-LocallyClosed A
  ⊢⇒lc-ty-tm : ∀ {Γ L A} → Γ ⊢ L ⦂ A → Ty-Tm-LocallyClosed L
\end{code}

\section{Substitution preserves types}
\label{chapter3:substitution_preserves_types}
Before proving the main substitution theorem, we need a lemma for extracting one kind of
substitution out of another. We only need the type substitution version of this property. The proof
is a simple induction and a consequence of the previously proven \texttt{≻⇒:→-invariant}.
\begin{code}
  extract-subst : ∀ {X C A i j}
    (B : Type)
    → j ≥ i
    → i ≻ty C
    → ty-ty[ j :→ ty-ty[ X := C ] A ] (ty-ty[ X := C ] B)
        ≡ ty-ty[ X := C ] (ty-ty[ j :→ A ] B)
  extract-subst ‵ℕ j≥i i≻C = refl
  extract-subst {X} {C} (frᵀ Y) j≥i i≻C with X ≟lchar Y
  ... | yes refl = ≻⇒:→-invariant C j≥i i≻C
  ... | no  X≢Y  = refl
  extract-subst {i = i} {j = j} (#ᵀ n) j≥i i≻C with j ≟ℕ n
  ... | yes refl = refl
  ... | no  j≢n  = refl
  extract-subst (B ⇒ B') j≥i i≻C = cong₂ _⇒_
    (extract-subst B j≥i i≻C) (extract-subst B' j≥i i≻C)
  extract-subst (∀ᵀ B) j≥i i≻C =
    cong ∀ᵀ_ (extract-subst B (m≤n⇒m≤1+n j≥i) i≻C)

  extract-subst-ctx : ∀ {Γ L X C B A i j}
    → j ≥ i
    → i ≻ty C
    → Γ ⊢ L ⦂ ty-ty[ j :→ ty-ty[ X := C ] A ] (ty-ty[ X := C ] B)
    → Γ ⊢ L ⦂ ty-ty[ X := C ] (ty-ty[ j :→ A ] B)
  extract-subst-ctx {B = B} j≥i i≻C assump =
    ≡-with-⊢-ty assump (extract-subst B j≥i i≻C)
\end{code}

\texttt{subst-ty} shows that we can substitute a free type variable and have the type of the term
affected accordingly, and \texttt{subst} shows that we can apply a substitution to eliminate a
function type of a term.

This first proof is done by inducting on the type judgement.
\begin{code}
  subst-ty : ∀ {Γ Δ X L B C}
    → Ty-LocallyClosed C
    → ftv-ty C ⊆ domain-ftv Δ
    → Ok (Γ + (map (ty-ty[ X := C ]_) Δ))
    → ((Γ , X) + Δ) ⊢ L ⦂ B
      --------------------
    → (Γ + (map (ty-ty[ X := C ]_) Δ))
        ⊢ ty-tm[ X := C ] L ⦂ ty-ty[ X := C ] B
  subst-ty {Γ} {Δ} {X} lc-C C⊆Δ okΓ+map (⊢free okΓ+Δ lc-B ∋x)
    with ok-+ {Γ = Γ , X} okΓ+Δ
  ... | ok-∷ftv okΓ X∉Γ =
    ⊢free okΓ+map (:=-≻ z≤n lc-B lc-C) (∋-map-ftv Δ okΓ+Δ ∋x)
\end{code}
In the $\vdash\text{free}$ case, we use the previously proven \texttt{∋-map-ftv} lemma to apply the
substitution to the type of the free variable.
\begin{code}
  subst-ty lc-C C⊆Δ okΓ+map (⊢· ⊢L ⊢M) = ⊢·
    (subst-ty lc-C C⊆Δ okΓ+map ⊢L)
    (subst-ty lc-C C⊆Δ okΓ+map ⊢M)
  subst-ty {Γ} {Δ} {X} {B = ∀ᵀ B} {C = C}
      lc-C C⊆Δ okΓ+map (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢Λ
      И⟨ (X ∷ Иe₁) ++ domain-all-ftv (Γ + map (ty-ty[_:=_]_ X C) Δ)
      , (λ a {a∉} →
        let ⟨ a∉X∷Иe₁ , a∉dom-all-ftv ⟩ = ∉-++ a∉
            ⟨ a∉X∷[] , a∉Иe₁ ⟩ = ∉-++ a∉X∷Иe₁
            X≢a = sym-≢ (∉∷[]⇒≢ a∉X∷[])
            hypo = subst-ty {Δ = Δ , a} lc-C (⊆⇒⊆∷ C⊆Δ)
                (ok-∷ftv okΓ+map a∉dom-all-ftv) (Иe₂ a {a∉Иe₁})
        in subst-open-ty-tm-ty-tm-ctx X≢a z≤n lc-C
          (subst-open-ty-ty-ty-ty-ctx {A = B} {j = 0} X≢a z≤n lc-C hypo) ) ⟩
\end{code}
The $\vdash\cdot$ case is simple. For $\vdash\Lambda$, after application of the inductive
hypothesis, we end up with a term which is of the form $\vdash [Y := C] ([i \to a] L) \colon [...]$.
But to type a $\Lambda$-abstraction, we need the opening operation to be on the outside. Luckily we
can use \texttt{subst-open} to swap these two around.
\begin{code}
  subst-ty {Γ} {Δ} {L = ƛ L}
      lc-C C⊆Δ okΓ+map (⊢ƛ {A = A} lc-A И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢ƛ (:=-≻ z≤n lc-A lc-C) И⟨ Иe₁ , (λ a {a∉} →
      let ⊢tm-tm[0→]L = Иe₂ a {a∉}
          ok = ⊢⇒Ok ⊢tm-tm[0→]L
      in subst-open-ty-tm-tm-tm-ctx L z≤n lc-C
        (subst-ty lc-C C⊆Δ (ok-∷fv
            okΓ+map
            (:=-≻ z≤n lc-A lc-C)
            (ftv⊆dom-:= {A = A} Γ Δ lc-C C⊆Δ okΓ+map (extract-⊆ ok)))
          ⊢tm-tm[0→]L)) ⟩
\end{code}
In the $\vdash\lambda$ case, we need to use the inductive hypothesis together with
\texttt{subst-open} to swap the opening and substitution operations around. The only tricky part
comes in proving that the context is still okay when adding the new free variable to it. Luckily, we
have already done the hard work when we proved \texttt{ftv⊆dom-:=} earlier.
\begin{code}
  subst-ty {Γ} {Δ} {X = Y} {L = L [ A ]} {B = D}
      lc-C C⊆Δ okΓ+map (⊢[] {B = B} lc-A A⊆ ⊢L)
    = extract-subst-ctx {X = Y} {B = B} {A = A} {j = 0} z≤n lc-C
      (⊢[]
        (:=-≻ {X = Y} z≤n lc-A lc-C)
        (ftv⊆dom-:= {A = A} Γ Δ lc-C C⊆Δ okΓ+map A⊆)
        (subst-ty lc-C C⊆Δ okΓ+map ⊢L))
\end{code}
For $\vdash[]$, after applying the inductive hypothesis and the $\vdash[]$ type judgement, we get an
expression of the type $\text{ty-ty}[ 0 \texttt{:→} \text{ty-ty}[ Y := C ] A ] (\text{ty-ty}[ Y := C
] B)$. Extracting the \texttt{:=} substitution out of the \texttt{:→} one is exactly the reason why
we need to call \texttt{extract-subst-ctx}.
\begin{code}
  subst-ty lc-C C⊆Δ okΓ+map (⊢zero okΓ+Δ) = ⊢zero okΓ+map
  subst-ty lc-C C⊆Δ okΓ+map (⊢suc ⊢L) =
    ⊢suc (subst-ty lc-C C⊆Δ okΓ+map ⊢L)
\end{code}
The last two cases are a simple application of the inductive hypothesis.

\label{chapter3:subst}
For \texttt{subst}, our proof is very similar to how it is in \citet{wadler_programming_2022}, with
cofinite induction and \texttt{subst-open} being the only notable additions. Agda believes that the
$\vdash\lambda$ case doesn't terminate. However, as we're recursing on the deconstructed type
judgement, we are ensuring that the recursive call uses a strict subexpression of the argument,
which is exactly the requirement for termination that Agda uses
\citep{the_agda_community_termination_2024}.
\begin{code}
  {-# TERMINATING #-}
  subst : ∀ {Γ x L N A B}
    → ∅ ⊢ N ⦂ A
    → Γ , x ⦂ A ⊢ L ⦂ B
      -----------------------
    → Γ ⊢ tm-tm[ x := N ] L ⦂ B
  subst {x = y} ⊢N (⊢free (ok-∷fv okΓ _ A⊆Γ) lc-A (H refl))
    with y ≟lchar y
  ... | yes refl = weaken okΓ ⊢N
  ... | no  y≢y  = contradiction refl y≢y
  subst {x = y} ⊢N (⊢free {x = x} (ok-∷fv okΓ _ A⊆Γ) lc-A (T x≢y ∋x))
    with y ≟lchar x
  ... | yes refl = contradiction refl x≢y
  ... | no  _    = ⊢free okΓ lc-A ∋x
  subst {x = y} {L = ƛ L} ⊢N (⊢ƛ lc-A И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢ƛ lc-A И⟨ (y ∷ Иe₁) , (λ a {a∉} →
      let a∉Иe₁ = proj₂ (∉-++ {xs = y ∷ []} a∉)
          y≢a = sym-≢ (∉y∷ys⇒≢y a∉)
          ⊢tm-tm[]L = swap (sym-≢ y≢a) (Иe₂ a {a∉Иe₁})
      in subst-open-ctx L y≢a (⊢⇒lc ⊢N) (subst ⊢N ⊢tm-tm[]L)) ⟩
  subst ⊢N (⊢· ⊢L ⊢M) = ⊢· (subst ⊢N ⊢L) (subst ⊢N ⊢M)
  subst {x = y} {L = Λ L} ⊢N (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢Λ И⟨ y ∷ Иe₁ , (λ A {A∉} →
      let A∉Иe₁ = proj₂ (∉-++ {xs = y ∷ []} A∉)
          y≢A = sym-≢ (∉y∷ys⇒≢y A∉)
          ⊢ty-tm[]L = Иe₂ A {A∉Иe₁}
          induc-hypo = subst ⊢N (swap-tm-ty ⊢ty-tm[]L)
      in subst-open-ty-tm-ctx L y≢A z≤n (⊢⇒lc-ty-tm ⊢N) induc-hypo ) ⟩
  subst ⊢N (⊢[] lc ⊆[] ⊢L) = ⊢[] lc ⊆[] (subst ⊢N ⊢L)
  subst ⊢N (⊢zero (ok-∷fv okΓ _ _)) = ⊢zero okΓ
  subst ⊢N (⊢suc ⊢L) = ⊢suc (subst ⊢N ⊢L)
\end{code}

And to put these two properties to use, we need to replace the \texttt{:→} substitution with the
\texttt{:=} substitution. To do this, we combine the above proofs and the previously proven
\texttt{subst-intro} lemma.
\begin{code}
  subst-op : ∀ {Γ L N A B}
    → ∅ ⊢ N ⦂ A
    → Γ ⊢ ƛ L ⦂ A ⇒ B
      -----------------------
    → Γ ⊢ tm-tm[ 0 :→ N ] L ⦂ B
  subst-op {Γ} {L} {N} ⊢N (⊢ƛ lc-A И⟨ Иe₁ , Иe₂ ⟩) =
    let x                  = fresh (fv-tm L ++ Иe₁)
        ⟨ x∉fv-L , x∉Иe₁ ⟩ = ∉-++ {xs = fv-tm L}
                                (fresh-correct (fv-tm L ++ Иe₁))
    in ≡-with-⊢-tm (subst ⊢N (Иe₂ x {x∉Иe₁}))
      (sym (subst-intro L N (x∉fv-L)))

  subst-op-ty : ∀ {L B C}
    → Ty-LocallyClosed C
    → ftv-ty C ⊆ []
    → ∅ ⊢ Λ L ⦂ ∀ᵀ B
      -----------------------------
    → ∅ ⊢ ty-tm[ 0 :→ C ] L ⦂ ty-ty[ 0 :→ C ] B
  subst-op-ty {L} {B} {C} lc-C C⊆[] (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) =
    let x = fresh (fv-tm L ++ ftv-ty B ++ ftv-tm L ++ Иe₁)
        ⟨ x∉fv-L , x∉ ⟩ = ∉-++ {xs = fv-tm L}
          (fresh-correct (fv-tm L ++ ftv-ty B ++ ftv-tm L ++ Иe₁))
        ⟨ x∉ftv-B , x∉ ⟩ = ∉-++ {xs = ftv-ty B} x∉
        ⟨ x∉ftv-L , x∉Иe₁ ⟩ = ∉-++ {xs = ftv-tm L} x∉
    in ≡-with-⊢-ty (≡-with-⊢-tm
          (subst-ty {Δ = ∅} lc-C C⊆[] ok-∅ (Иe₂ x {x∉Иe₁}))
          (sym (subst-intro-ty-tm L x∉ftv-L)))
      (sym (subst-intro-ty-ty B x∉ftv-B))
\end{code}

\section{Evaluation}
\label{chapter3:evaluation}
As mentioned in Section \ref{background:evaluation_strategy}, we will stop evaluating at
abstractions.
\begin{code}
  data Value : Term → Set where
    V-ƛ : ∀ {L} → Value (ƛ L)
    V-Λ : ∀ {L} → Value (Λ L)
    V-zero : Value ‵zero
    V-suc : ∀ {L} → Value L → Value (‵suc L)
\end{code}

We have the following evaluation rules, adapted from \citet{chargueraud_locally_2012}.
\begin{code}
  infix 4 _—→_
  data _—→_ : Term → Term → Set where
    ξ₁ : ∀ {L L' M}
      → L —→ L'
        -------------------
      → L · M —→ L' · M

    ξ₂ : ∀ {L M M'}
      → M —→ M'
        ---------
      → L · M —→ L · M'

    ξ-[] : ∀ {L L' A}
      → L —→ L'
        ------------------
      → L [ A ] —→ L' [ A ]

    ξ-suc : ∀ {L L'}
      → L —→ L'
        ------------------
      → ‵suc L —→ ‵suc L'

    β-ƛ : ∀ {L M}
      → 1 ≻tm L              → Value M
        ------------------------------
      → (ƛ L) · M —→ tm-tm[ 0 :→ M ] L

    β-Λ : ∀ {L A}
      → 1 ≻ty-tm L  → Ty-LocallyClosed A
      → ftv-ty A ⊆ []
        --------------------------------
      → (Λ L) [ A ] —→ ty-tm[ 0 :→ A ] L
\end{code}
The only difference in our version is that we only allow type applications which do not have any
free type variables. This is because in our language, the only way to receive a free type variable
is in the type judgement of a $\Lambda$-abstraction---evaluation will only work on empty contexts.

We have transitivity and reflexivity of evaluation.
\begin{code}
  data _—↠_ : Term → Term → Set where
    _∎' : ∀ M → M —↠ M
    step—→ : ∀ L {M N} → M —↠ N → L —→ M → L —↠ N
  pattern _—→⟨_⟩_ L L—→M M—↠N = step—→ L M—↠N L—→M

  begin'_ : ∀ {M N} → M —↠ N → M —↠ N
  begin' M—↠N = M—↠N
\end{code}

The proof of progress is quite straight-forward. Compared to the proof for the STLC as presented in
\citet[chapter~Properties]{wadler_programming_2022}, we only need to add some properties about local
closure, which is easily obtained by \texttt{⊢⇒lc}, and $\vdash[]$, which works the same as
$\vdash\cdot$, except that we only need to evaluate one term instead of two.
\begin{code}
  data Progress (L : Term) : Set where
    done : Value L → Progress L
    step : ∀ {L'} → L —→ L' → Progress L

  progress : ∀ {L A} → ∅ ⊢ L ⦂ A → Progress L
  progress (⊢ƛ lc-A cof) = done V-ƛ
  progress (⊢· ⊢L ⊢M) with progress ⊢L
  ... | step L→L' = step (ξ₁ L→L')
  ... | done V-ƛ with progress ⊢M
  ...   | step M→M' = step (ξ₂ M→M')
  ...   | done val  = step (β-ƛ (≻ƛ⇒s≻ƛ (⊢⇒lc ⊢L)) val)
  progress (⊢Λ x) = done V-Λ
  progress (⊢[] lc-A A⊆[] ⊢L) with progress ⊢L
  ... | step L→L' = step (ξ-[] L→L')
  ... | done V-Λ = step (β-Λ (≻Λ⇒s≻Λ (⊢⇒lc-ty-tm ⊢L)) lc-A A⊆[])
  progress (⊢zero ok-∅) = done V-zero
  progress (⊢suc ⊢L) with progress ⊢L
  ... | step L→L'  = step (ξ-suc L→L')
  ... | done val-L = done (V-suc val-L)
\end{code}

The proof of preservation, however, proves difficult. Luckily, we already did the hard work when we
proved \texttt{subst-ty}, \texttt{subst}, \texttt{subst-op}, and \texttt{subst-op-ty} earlier.
\begin{code}
  preserve : ∀ {L L' A} → ∅ ⊢ L ⦂ A → L —→ L' → ∅ ⊢ L' ⦂ A
  preserve (⊢· ⊢L ⊢M) (ξ₁ L→L') = ⊢· (preserve ⊢L L→L') ⊢M
  preserve (⊢· ⊢L ⊢M) (ξ₂ M→M') = ⊢· ⊢L (preserve ⊢M M→M')
  preserve (⊢· ⊢L ⊢M) (β-ƛ 1≻L val-M) = subst-op ⊢M ⊢L
  preserve (⊢[] lc-A A⊆[] ⊢L) (ξ-[] L→L') =
    ⊢[] lc-A A⊆[] (preserve ⊢L L→L')
  preserve (⊢[] lc-A A⊆[] ⊢L) (β-Λ 1≻L _ C⊆[]) =
    subst-op-ty lc-A C⊆[] ⊢L
  preserve (⊢suc ⊢L) (ξ-suc L→L') = ⊢suc (preserve ⊢L L→L')
\end{code}

Now we can make an evaluation function. We follow \citet{wadler_programming_2022} and define
\texttt{Gas}: the number of evaluation steps we will take before giving up evaluation (we have `run
out of gas'). We can either be finished when we are out of gas, or when we have reached a value. We
keep track of the reduction steps using \texttt{Steps}.
\begin{code}
  record Gas : Set where
    pattern
    constructor gas
    field
      amount : ℕ

  data Finished (N : Term) : Set where
    out-of-gas : Finished N
    done : Value N → Finished N

  data Steps (L : Term) : Set where
    steps : ∀ {N} → L —↠ N → Finished N → Steps L
\end{code}

Finally, the evaluation function is defined by repeatedly applying the progress and preservation
Lemmas as long as we have `gas' left.
\begin{code}
  eval : ∀ {L A} → Gas → ∅ ⊢ L ⦂ A → Steps L
  eval {L} (gas zero) ⊢L = steps (L ∎') out-of-gas
  eval {L} (gas (suc n)) ⊢L with progress ⊢L
  ... | done val = steps (L ∎') (done val)
  ... | step {M} L→M with eval (gas n) (preserve ⊢L L→M)
  ...   | steps M→N fin = steps (L —→⟨ L→M ⟩ M→N) fin
\end{code}

As an example, we can use the earlier defined \texttt{twice} function to apply $\lambda \;
\texttt{‵suc} \; 0$ twice to \texttt{‵zero} to get \texttt{‵suc (‵suc ‵zero)}.
\begin{code}
  ⊢twice-suc-zero :
    ∅ ⊢ (((Λ ƛ (ƛ ((# 1) · ((# 1) · (# 0))))) [ ‵ℕ ])
          · (ƛ ‵suc (# 0))) · ‵zero
        ⦂ ‵ℕ
  ⊢twice-suc-zero = ⊢·
    (⊢· (⊢[] n≻‵ℕ All.[] twice)
      (⊢ƛ n≻‵ℕ И⟨ [] , (λ a →
        ⊢suc (⊢free (ok-∷fv ok-∅ n≻‵ℕ All.[]) n≻‵ℕ H′)) ⟩))
    (⊢zero ok-∅)
\end{code}

One could evaluate this expression by using Agda's normalise feature. For example, in Emacs, one can
press \texttt{C-c} \texttt{C-n} and type \texttt{eval (gas 10) ⊢twice-suc-zero} to see the
derivation being automatically generated.

\chapter{Conclusions}
\label{chapter4}
We have successfully developed an evaluator for System F using the locally nameless representation
and have proven many important properties of the language, culminating in progress and preservation.
However, to do so, we required lemmas which were very difficult to prove and to explain.
Additionally, despite following Agda's requirements for termination, the compiler still complains
that \texttt{subst} does not terminate. Of course, termination-checking is undecidable, but a proof
of \texttt{subst} without the \texttt{\{\#- TERMINATING -\#\}} pragma would be desirable.

\paragraph*{Future work} Most, if not all, of the prior literature on locally nameless
representation, including the work presented here, uses an extrinsically typed approach. This means
that we defined the syntax of the langauge first and then restricted ourselves to only work with
well-typed terms. Using intrinsic typing, we instead first define the typing rules and immediately
restrict ourselves to only well-typed terms. For the STLC,
\citet[chapter~De~Bruijn]{wadler_programming_2022} found that this results in some theorems becoming
trivial, such as preservation, and the overall code being more concise. As preservation
(specifically \texttt{subst} and \texttt{subst-ty}) proved to be the most difficult theorem in this
work, this would certainly be welcome. The main problem with an intrinsically typed approach is that
the locally nameless representation requires infrastructure (opening, closing, local closure, etc.).
Since bound variables outside of a $\lambda$-abstraction are ill-typed, it would prove difficult to
combine an intrinsically typed approach with the infrastructure required.

The language we presented here is plain System F, but often the literature studies more complex
systems. The \textsc{PoplMark} challenge asks for an implementation of System F with subtyping
\citep{hutchison_mechanized_2005}; implementing this would only require extending the formalisation
with a few extra type judgements for subtyping, extra evaluation rules, and some further
restrictions on the `Ok' predicate. As mentioned above, System F$_\omega$ has been formalised by
\citet{hutton_system_2019} in Agda, and a locally nameless approach has been used for System
F$_\omega^\ast$ by \citet{rendel_typed_2009}, an extension of System F$_\omega$ which allows typed
self-representation. He used Rocq, and as far as I am aware, an Agda development has not yet been
published.

\bibliographystyle{plainnat}
\bibliography{dissertation}

\appendix

\chapter{A brief overiew of Agda}
\label{appendix:agda_overview}
\input{agda_example.tex}

\chapter{PLFA adaptions}
\label{appendix:plfa}

These functions are adapted from the PLFA textbook \citep{wadler_programming_2022}.

\input{plfa_adaptions.tex}

\chapter{Miscellaneous System F proofs}
\label{appendix:f}
\section{Local Closure}
\label{appendix:f_local_closure}
\begin{code}
  -- ax1-tm : ∀ (i : ℕ) (a b : Id) (L : Term)
  --   → tm-tm[ i —→ a ] (tm-tm[ i —→ b ] L)
  --     ≡ tm-tm[ i —→ b ] L
  ax1-tm i a b (fr x) = refl
  ax1-tm i a b (# k) with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k  with i ≟ℕ k
  ... |   yes refl = contradiction refl i≢k
  ... |   no  _    = refl
  ax1-tm i a b (ƛ L) rewrite ax1-tm (suc i) a b L = refl
  ax1-tm i a b (L · M)
    rewrite ax1-tm i a b L | ax1-tm i a b M = refl
  ax1-tm i a b (Λ L) rewrite ax1-tm i a b L = refl
  ax1-tm i a b (L [ A ]) rewrite ax1-tm i a b L = refl
  ax1-tm i a b ‵zero = refl
  ax1-tm i a b (‵suc L) rewrite ax1-tm i a b L = refl

  -- ax1-ty-tm : ∀ (i : ℕ) (a b : Id) (L : Term)
  --   → ty-tm[ i —→ a ] (ty-tm[ i —→ b ] L)
  --     ≡ ty-tm[ i —→ b ] L
  ax1-ty-tm i a b (fr x) = refl
  ax1-ty-tm i a b (# k) = refl
  ax1-ty-tm i a b (ƛ L) rewrite
    ax1-ty-tm i a b L = refl
  ax1-ty-tm i a b (L · M) rewrite
    ax1-ty-tm i a b L | ax1-ty-tm i a b M = refl
  ax1-ty-tm i a b (Λ L)
    rewrite ax1-ty-tm (suc i) a b L = refl
  ax1-ty-tm i a b (L [ A ])
    rewrite ax1-ty i a b A | ax1-ty-tm i a b L = refl
  ax1-ty-tm i a b ‵zero = refl
  ax1-ty-tm i a b (‵suc L)
    rewrite ax1-ty-tm i a b L = refl
\end{code}

\begin{code}
  -- lemma2·6-ty : ∀ {i j A}
  --   → j ≥ i
  --   → i ≻ty A
  --     -------
  --   → j ≻ty A
  lemma2·6-ty j≥i i≻A k =
    i≻A k ⦃ ≤-trans j≥i it ⦄

  -- lemma2·6-tm : ∀ {i j L}
  --   → j ≥ i → i ≻tm L → j ≻tm L
  lemma2·6-tm j≥i i≻L k =
    i≻L k ⦃ ≤-trans j≥i it ⦄

  -- lemma2·6-ty-tm : ∀ {i j L}
  --   → j ≥ i → i ≻ty-tm L → j ≻ty-tm L
  lemma2·6-ty-tm j≥i i≻L k =
    i≻L k ⦃ ≤-trans j≥i it ⦄

  -- lemma2·7-1-ty : ∀ {i x y A}
  --   → ty-ty[ i —→ x ] A ≡ A
  --   → ty-ty[ i —→ y ] A ≡ A
  lemma2·7-1-ty {i} {x} {y} {A} assump =
    begin
      ty-ty[ i —→ y ] A
    ≡⟨ sym (cong (ty-ty[ i —→ y ]_) assump) ⟩
      ty-ty[ i —→ y ] (ty-ty[ i —→ x ] A)
    ≡⟨ ax1-ty i y x A ⟩
      ty-ty[ i —→ x ] A
    ≡⟨ assump ⟩
      A
    ∎

  -- lemma2·7-1-tm : ∀ {i x y L}
  --   → tm-tm[ i —→ x ] L ≡ L → tm-tm[ i —→ y ] L ≡ L
  lemma2·7-1-tm {i} {x} {y} {L} assump =
    begin
      tm-tm[ i —→ y ] L
    ≡⟨ sym (cong (tm-tm[ i —→ y ]_) assump) ⟩
      tm-tm[ i —→ y ] (tm-tm[ i —→ x ] L)
    ≡⟨ ax1-tm i y x L ⟩
      tm-tm[ i —→ x ] L
    ≡⟨ assump ⟩
      L
    ∎

  -- lemma2·7-1-ty-tm : ∀ {i x y L}
  --   → ty-tm[ i —→ x ] L ≡ L → ty-tm[ i —→ y ] L ≡ L
  lemma2·7-1-ty-tm {i} {x} {y} {L} assump =
    begin
      ty-tm[ i —→ y ] L
    ≡⟨ sym (cong (ty-tm[ i —→ y ]_) assump) ⟩
      ty-tm[ i —→ y ] (ty-tm[ i —→ x ] L)
    ≡⟨ ax1-ty-tm i y x L ⟩
      ty-tm[ i —→ x ] L
    ≡⟨ assump ⟩
      L
    ∎

  -- lemma2·7-2-ty : ∀ {i j x A}
  --   → j ≥ i       → i ≻ty A
  --     ---------------------
  --   → ty-ty[ j —→ x ] L ≡ A
  lemma2·7-2-ty {j = j} j≥i i≻A =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻A j ⦃ j≥i ⦄ in
      lemma2·7-1-ty (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})

  -- lemma2·7-2-tm : ∀ {i j x L} → j ≥ i
  --   → i ≻tm L → tm-tm[ j —→ x ] L ≡ L
  lemma2·7-2-tm {j = j} j≥i i≻L =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻L j ⦃ j≥i ⦄ in
      lemma2·7-1-tm (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})

  -- lemma2·7-2-ty-tm : ∀ {i j x L} → j ≥ i
  --   → i ≻ty-tm L → ty-tm[ j —→ x ] L ≡ L
  lemma2·7-2-ty-tm {j = j} j≥i i≻L =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻L j ⦃ j≥i ⦄ in
      lemma2·7-1-ty-tm (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
\end{code}

\begin{code}
  -- open-rec-lc-lemma : ∀ {L : Term} {i j u v} → i ≢ j
  --   → tm-tm[ i —→ u ] (tm-tm[ j —→ v ] L)
  --     ≡ tm-tm[ j —→ v ] L
  --   → tm-tm[ i —→ u ] L ≡ L
  open-rec-lc-lemma {fr x} i≢j assump = refl
  open-rec-lc-lemma {# k} {i} {j} i≢j assump
    with i ≟ℕ j | i ≟ℕ k
  ... | yes refl | _ = contradiction refl i≢j
  ... | no _     | no _ = refl
  ... | no _     | yes refl with j ≟ℕ k
  ...   | yes refl = contradiction refl i≢j
  ...   | no j≢k with k ≟ℕ k
  ...     | yes refl with () ← assump
  ...     | no  k≢k  = contradiction refl k≢k
  open-rec-lc-lemma {ƛ L} {i} {j} i≢j assump
    rewrite open-rec-lc-lemma {L} {suc i} {suc j}
      (suc-preserves-≢ i≢j)
      (ƛ-inj assump) = refl
  open-rec-lc-lemma {L · M} i≢j assump rewrite
      open-rec-lc-lemma {L} i≢j (proj₁ (·-inj assump))
    | open-rec-lc-lemma {M} i≢j (proj₂ (·-inj assump)) = refl
  open-rec-lc-lemma {Λ L} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (Λ-inj assump) = refl
  open-rec-lc-lemma {L [ x ]} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (proj₁ ([]-inj assump)) = refl
  open-rec-lc-lemma {‵zero} i≢j assump = refl
  open-rec-lc-lemma {‵suc L} i≢j assump
    rewrite open-rec-lc-lemma {L} i≢j (‵suc-inj assump) = refl

  -- open-rec-lc-lemma-ty : ∀ {A i j u v}
  --   → i ≢ j
  --   → ty-ty[ i —→ u ] (ty-ty[ j —→ v ] A)
  --     ≡ ty-ty[ j —→ v ] A
  --   → ty-ty[ i —→ u ] A ≡ A
  open-rec-lc-lemma-ty {‵ℕ} i≢j assump = refl
  open-rec-lc-lemma-ty {frᵀ x} i≢j assump = refl
  open-rec-lc-lemma-ty {#ᵀ k} {i} {j} i≢j assump with i ≟ℕ k
  ... | no  i≢k  = refl
  ... | yes refl with j ≟ℕ k
  ...   | yes refl = contradiction refl i≢j
  ...   | no  j≢k with k ≟ℕ k
  ...     | yes refl with () ← assump
  ...     | no  k≢k = contradiction refl k≢k
  open-rec-lc-lemma-ty {A ⇒ B} i≢j assump rewrite
      open-rec-lc-lemma-ty {A} i≢j (proj₁ (⇒-inj assump))
    | open-rec-lc-lemma-ty {B} i≢j (proj₂ (⇒-inj assump))
    = refl
  open-rec-lc-lemma-ty {∀ᵀ A} {i} {j} i≢j assump
    rewrite open-rec-lc-lemma-ty {A} {suc i} {suc j}
      (suc-preserves-≢ i≢j)
      (∀-inj assump)
        = refl

  -- open-rec-lc-lemma-ty-tm : ∀ {L i j u v}
  --   → i ≢ j
  --   → ty-tm[ i —→ u ] (ty-tm[ j —→ v ] L)
  --     ≡ ty-tm[ j —→ v ] L
  --   → ty-tm[ i —→ u ] L ≡ L
  open-rec-lc-lemma-ty-tm {fr x} i≢j assump = refl
  open-rec-lc-lemma-ty-tm {# k} i≢j assump = refl
  open-rec-lc-lemma-ty-tm {ƛ L} i≢j assump rewrite
    open-rec-lc-lemma-ty-tm {L} i≢j (ƛ-inj assump) = refl
  open-rec-lc-lemma-ty-tm {L · M} i≢j assump rewrite
      open-rec-lc-lemma-ty-tm {L} i≢j (proj₁ (·-inj assump))
    | open-rec-lc-lemma-ty-tm {M} i≢j (proj₂ (·-inj assump)) = refl
  open-rec-lc-lemma-ty-tm {Λ L} i≢j assump rewrite
    open-rec-lc-lemma-ty-tm {L} (suc-preserves-≢ i≢j) (Λ-inj assump) = refl
  open-rec-lc-lemma-ty-tm {L [ A ]} i≢j assump rewrite
      open-rec-lc-lemma-ty-tm {L} i≢j (proj₁ ([]-inj assump))
    | open-rec-lc-lemma-ty {A} i≢j (proj₂ ([]-inj assump)) = refl
  open-rec-lc-lemma-ty-tm {‵zero} i≢j assump = refl
  open-rec-lc-lemma-ty-tm {‵suc L} i≢j assump rewrite
    open-rec-lc-lemma-ty-tm {L} i≢j (‵suc-inj assump) = refl

  -- open-rec-lc-lemma-ty-tm-tm-tm : ∀ {L i j u v}
  --   → ty-tm[ i —→ u ] (tm-tm[ j —→ v ] L)
  --     ≡ tm-tm[ j —→ v ] L
  --   → ty-tm[ i —→ u ] L ≡ L
  open-rec-lc-lemma-ty-tm-tm-tm {fr x} assump = refl
  open-rec-lc-lemma-ty-tm-tm-tm {# k} assump = refl
  open-rec-lc-lemma-ty-tm-tm-tm {ƛ L} assump rewrite
    open-rec-lc-lemma-ty-tm-tm-tm {L} (ƛ-inj assump) = refl
  open-rec-lc-lemma-ty-tm-tm-tm {L · M} assump rewrite
      open-rec-lc-lemma-ty-tm-tm-tm {L} (proj₁ (·-inj assump))
    | open-rec-lc-lemma-ty-tm-tm-tm {M} (proj₂ (·-inj assump))
    = refl
  open-rec-lc-lemma-ty-tm-tm-tm {Λ L} assump rewrite
    open-rec-lc-lemma-ty-tm-tm-tm {L} (Λ-inj assump) = refl
  open-rec-lc-lemma-ty-tm-tm-tm {L [ A ]} assump rewrite
      proj₂ ([]-inj assump)
    | open-rec-lc-lemma-ty-tm-tm-tm {L} (proj₁ ([]-inj assump))
    = refl
  open-rec-lc-lemma-ty-tm-tm-tm {‵zero} assump = refl
  open-rec-lc-lemma-ty-tm-tm-tm {‵suc L} assump rewrite
    open-rec-lc-lemma-ty-tm-tm-tm {L} (‵suc-inj assump) = refl
\end{code}

\section{Free variables}
\label{appendix:f_free_variables}
\begin{minted}{agda}
  -- ftv-ty : Term → List Id
  ftv-ty ‵ℕ = []
  ftv-ty (frᵀ x) = x ∷ []
  ftv-ty (#ᵀ i) = []
  ftv-ty (A ⇒ B) = ftv-ty A ++ ftv-ty B
  ftv-ty (∀ᵀ A) = ftv-ty A

  -- ftv-tm : Term → List Id
  ftv-tm (fr x) = []
  ftv-tm (# i) = []
  ftv-tm (ƛ L) = ftv-tm L
  ftv-tm (L · M) = ftv-tm L ++ ftv-tm M
  ftv-tm (Λ L) = ftv-tm L
  ftv-tm (L [ A ]) = ftv-tm L ++ ftv-ty A
  ftv-tm ‵zero = []
  ftv-tm (‵suc L) = ftv-tm L
\end{minted}

\section{Substitution of types and terms}
\label{appendix:f_substitution_of_terms}
Note, for technical reasons, the real Agda code for these functions had to be included immediately
after their function declarations and hidden. Nonetheless, the hidden code is typechecked by the
compiler and is identical to the code below.
\begin{minted}{agda}
  -- ty-ty[_:=_]_ : Id → Type → Type → Type
  ty-ty[ X := T ] ‵ℕ = ‵ℕ
  ty-ty[ X := T ] (frᵀ Y) with X ≟lchar Y
  ... | yes refl = T
  ... | no  _    = frᵀ Y
  ty-ty[ X := T ] (#ᵀ k) = #ᵀ k
  ty-ty[ X := T ] (A ⇒ B) =
    (ty-ty[ X := T ] A) ⇒ (ty-ty[ X := T ] B)
  ty-ty[ X := T ] (∀ᵀ A) = ∀ᵀ (ty-ty[ X := T ] A)

  -- ty-tm[_:=_]_ : Id → Type → Term → Term
  ty-tm[ X := T ] (fr x) = fr x
  ty-tm[ X := T ] (# k) = # k
  ty-tm[ X := T ] (ƛ L) = ƛ (ty-tm[ X := T ] L)
  ty-tm[ X := T ] (L · M) =
    (ty-tm[ X := T ] L) · (ty-tm[ X := T ] M)
  ty-tm[ X := T ] (Λ L) = Λ (ty-tm[ X := T ] L)
  ty-tm[ X := T ] (L [ A ]) =
    (ty-tm[ X := T ] L) [ ty-ty[ X := T ] A ]
  ty-tm[ X := T ] ‵zero = ‵zero
  ty-tm[ X := T ] (‵suc L) = ‵suc ty-tm[ X := T ] L
\end{minted}

\begin{code}
  -- :=-≻ : ∀ {A X C i j} → j ≥ i → i ≻ty A → i ≻ty C
  --   → j ≻ty (ty-ty[ X := C ] A)
  :=-≻ {‵ℕ} j≥i i≻A i≻C = n≻‵ℕ
  :=-≻ {frᵀ Y} {X} j≥i i≻A i≻C with X ≟lchar Y
  ... | yes refl = lemma2·6-ty j≥i i≻C
  ... | no  X≢Y  = lemma2·6-ty j≥i i≻A
  :=-≻ {#ᵀ k} j≥i i≻A i≻C = lemma2·6-ty j≥i i≻A
  :=-≻ {A ⇒ B} j≥i i≻ i≻C k =
    let ⟨ i≻A , i≻B ⟩ = ⇒-≻ i≻
        И⟨ A-Иe₁ , A-Иe₂ ⟩ = (:=-≻ j≥i i≻A i≻C) k
        И⟨ B-Иe₁ , B-Иe₂ ⟩ = (:=-≻ j≥i i≻B i≻C) k
    in И⟨ A-Иe₁ ++ B-Иe₁ , (λ a {a∉} →
      let ⟨ a∉A , a∉B ⟩ = ∉-++ a∉
      in cong₂ _⇒_ (A-Иe₂ a {a∉A}) (B-Иe₂ a {a∉B})) ⟩
  :=-≻ {∀ᵀ A} {C = C} {i = i} j≥i i≻∀A i≻C k =
    let И⟨ Иe₁ , Иe₂ ⟩ = (:=-≻ (s≤s j≥i) si≻A si≻C) (suc k) ⦃ s≤s it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → cong ∀ᵀ_ (Иe₂ a {a∉})) ⟩
    where
      si≻A : suc i ≻ty A
      si≻A = i≻∀A⇒si≻A i≻∀A
      si≻C : suc i ≻ty C
      si≻C = lemma2·6-ty (n≤1+n i) i≻C

  -- :=-∉-invariant : ∀ {A X B} → X ∉ ftv-ty A
  --   → (ty-ty[ X := B ] A) ≡ A
  :=-∉-invariant {‵ℕ} X∉A = refl
  :=-∉-invariant {frᵀ Y} {X} X∉A with X ≟lchar Y
  ... | yes refl = contradiction refl (∉∷[]⇒≢ X∉A)
  ... | no  X≢Y  = refl
  :=-∉-invariant {#ᵀ k} X∉A = refl
  :=-∉-invariant {A ⇒ B} {X} {B = C} X∉ = cong₂ _⇒_
    (:=-∉-invariant {A} (proj₁ (∉-++ X∉)))
    (:=-∉-invariant {B} (proj₂ (∉-++ X∉)))
  :=-∉-invariant {∀ᵀ A} X∉A = cong ∀ᵀ_ (:=-∉-invariant {A} X∉A)
\end{code}

\begin{code}
  -- ≻⇒:→-invariant : ∀ {C i j} (A : Type)
  --   → j ≥ i       → i ≻ty A
  --     ---------------------
  --   → ty-ty[ j :→ C ] A ≡ A
  ≻⇒:→-invariant ‵ℕ j≥i i≻A = refl
  ≻⇒:→-invariant (frᵀ x) j≥i i≻A = refl
  ≻⇒:→-invariant {C} {i} {j} (#ᵀ n) j≥i i≻A with j ≟ℕ n
  ... | no  j≢n  = refl
  ... | yes refl with i≻A j ⦃ j≥i ⦄
  ...   | И⟨ Иe₁ , Иe₂ ⟩ with n ≟ℕ n
  ...     | yes refl with () ← Иe₂ (fresh Иe₁) {fresh-correct Иe₁}
  ...     | no  n≢n  = contradiction refl n≢n
  ≻⇒:→-invariant (A ⇒ B) j≥i i≻ = let ⟨ i≻A , i≻B ⟩ = ⇒-≻ i≻
    in cong₂ _⇒_ (≻⇒:→-invariant A j≥i i≻A) (≻⇒:→-invariant B j≥i i≻B)
  ≻⇒:→-invariant {i = i} {j = j} (∀ᵀ A) j≥i i≻ = cong ∀ᵀ_
    (≻⇒:→-invariant A (s≤s j≥i) (i≻∀A⇒si≻A i≻))
\end{code}

As mentioned above, for technical reasons, the real Agda code for these functions had to be included
immediately after their function declarations and hidden. Nonetheless, the hidden code is
typechecked by the compiler and is identical to the code below.
\begin{minted}{agda}
  -- ty-ty[_:→_]_ : ℕ → Type → Type → Type
  ty-ty[ k :→ T ] ‵ℕ = ‵ℕ
  ty-ty[ k :→ T ] (frᵀ x) = frᵀ x
  ty-ty[ k :→ T ] (#ᵀ i) with k ≟ℕ i
  ... | yes refl = T
  ... | no  _    = #ᵀ i
  ty-ty[ k :→ T ] (A ⇒ B) =
    (ty-ty[ k :→ T ] A) ⇒ (ty-ty[ k :→ T ] B)
  ty-ty[ k :→ T ] (∀ᵀ A) =
    ∀ᵀ (ty-ty[ (suc k) :→ T ] A)

  -- ty-tm[_:→_]_ : ℕ → Type → Term → Term
  ty-tm[ k :→ T ] (fr x) = fr x
  ty-tm[ k :→ T ] (# i) = # i
  ty-tm[ k :→ T ] (ƛ L) = ƛ ty-tm[ k :→ T ] L
  ty-tm[ k :→ T ] (L · M) =
    (ty-tm[ k :→ T ] L) · (ty-tm[ k :→ T ] M)
  ty-tm[ k :→ T ] (Λ L) = Λ ty-tm[ suc k :→ T ] L
  ty-tm[ k :→ T ] (L [ A ]) =
    (ty-tm[ k :→ T ] L) [ ty-ty[ k :→ T ] A ]
  ty-tm[ k :→ T ] ‵zero = ‵zero
  ty-tm[ k :→ T ] (‵suc L) = ‵suc ty-tm[ k :→ T ] L
\end{minted}

\section{Type contexts}
\label{appendix:f_contexts}
\begin{code}
  -- domain-ftv-map-invariant : ∀ {Γ f}
  --   → domain-ftv Γ ≡ (domain-ftv (map f Γ))
  domain-ftv-map-invariant {∅} = refl
  domain-ftv-map-invariant {Γ , x ⦂ A} =
    domain-ftv-map-invariant {Γ}
  domain-ftv-map-invariant {Γ , X} =
    cong (X ∷_) (domain-ftv-map-invariant {Γ})

  -- domain-++ : ∀ (Γ Δ : Context)
  --   → (domain-ftv Δ) ++ (domain-ftv Γ)
  --     ≡ domain-ftv (Γ + Δ)
  domain-++ Γ ∅ = refl
  domain-++ Γ (Δ , x ⦂ A) = domain-++ Γ Δ
  domain-++ Γ (Δ , Y) = cong (Y ∷_) (domain-++ Γ Δ)
\end{code}

\section{Type judgements}
\label{appendix:f_type_judgements}
\begin{equation}
\begin{gathered}
  \inferrule
    {\text{Ok} \, \Gamma}
    {\Gamma \vdash \texttt{‵zero} \colon \nat}
    \; (\vdash\texttt{zero})\quad
  \inferrule
    {\Gamma \vdash L \colon \nat}
    {\Gamma \vdash \texttt{‵suc} \, L \colon \nat}
    \; (\vdash\texttt{suc})\quad
  \\
  \inferrule
    {\text{Ok} \, \Gamma\\0 \succ A\\x \colon A \in \Gamma}
    {\Gamma \vdash x \colon A}
    \; (\vdash\text{free})
  \\
  \inferrule
    {0 \succ A\\\cof x , \; (\Gamma , \, x \colon A \vdash [0 \to x] L \colon B)}
    {\Gamma \vdash (\lambda \colon A. L) \colon A \to B}
    \; (\vdash\lambda)
  \\
  \inferrule
    {\Gamma \vdash L \colon A \to B\\\Gamma \vdash M \colon A}
    {\Gamma \vdash L M \colon B}
    \; (\vdash\text{app})
  \\
  \inferrule
    {\cof T, \; (\Gamma \vdash ([0 \to T] L) \colon [0 \to T] B)}
    {\Gamma \vdash (\Lambda \, L) \colon \forall B}
    \; (\vdash\Lambda)
  \\
  \inferrule
    {0 \succ A\\\text{ftv}(A) \subseteq \text{dom-ftv}(\Gamma)\\\Gamma \vdash L \colon \forall B}
    {\Gamma \vdash L [ A ] \colon [0 \to A] B}
    \; (\vdash[])
\end{gathered}
\end{equation}

\section{Typing properties}
\label{appendix:f_type_properties}
\begin{code}
  -- swap : ∀ {Γ x y L A B C}
  --   → x ≢ y
  --   → (Γ , y ⦂ B) , x ⦂ A ⊢ L ⦂ C
  --     -------------------------
  --   → (Γ , x ⦂ A) , y ⦂ B ⊢ L ⦂ C
  swap {Γ} {x} {y} {L} {A} {B} {C} x≢y ⊢L with ⊢⇒Ok ⊢L
  ... | ok-∷fv (ok-∷fv okΓ lc-B B⊆Γ) lc-A A⊆Γ =
    rename (ok-∷fv (ok-∷fv okΓ lc-A A⊆Γ) lc-B B⊆Γ) ρ₁ ρ₂ ⊢L
    where
      ρ₁ : ∀ {z C}
        → (Γ , y ⦂ B) , x ⦂ A ∋ z ⦂ C
          -------------------------
        → (Γ , x ⦂ A) , y ⦂ B ∋ z ⦂ C
      ρ₁ (H refl) = T x≢y H′
      ρ₁ (T z≢x (H refl)) = H′
      ρ₁ (T z≢x (T z≢y ∋z)) = T z≢y (T z≢x ∋z)
      ρ₂ : ∀ {X}
        → ((Γ , y ⦂ B) , x ⦂ A) ∋ X
          -------------------------
        → ((Γ , x ⦂ A) , y ⦂ B) ∋ X
      ρ₂ (S⦂ (S⦂ ∋X)) = S⦂ (S⦂ ∋X)

  -- swap-tm-ty : ∀ {Γ X y L B C}
  --   → ((Γ , y ⦂ B) , X) ⊢ L ⦂ C
  --     -------------------------
  --   → (Γ , X) , y ⦂ B ⊢ L ⦂ C
  swap-tm-ty {Γ} {X} {y} {L} {B} {C} ⊢L with ⊢⇒Ok ⊢L
  ... | ok-∷ftv (ok-∷fv okΓ lc-B B⊆Γ) X∉Γ =
    rename
      (ok-∷fv (ok-∷ftv okΓ (proj₂ (∉-++ X∉Γ))) lc-B (⊆⇒⊆∷ B⊆Γ))
      ρ₁
      ρ₂
      ⊢L
    where
      ρ₁ : ∀ {x A}
        → ((Γ , y ⦂ B) , X) ∋ x ⦂ A
          -------------------------
        → ((Γ , X) , y ⦂ B) ∋ x ⦂ A
      ρ₁ (T⦂ (H refl)) = H′
      ρ₁ (T⦂ (T x≢y ∋x)) = T x≢y (T⦂ ∋x)
      ρ₂ : ∀ {Z : Id}
        → ((Γ , y ⦂ B) , X) ∋ Z
        → ((Γ , X) , y ⦂ B) ∋ Z
      ρ₂ Z = S⦂ Z
      ρ₂ (S (S⦂ ∋Z)) = S⦂ (S ∋Z)

  -- drop : ∀ {Γ x L A B C}
  --   → (Γ , x ⦂ A) , x ⦂ B ⊢ L ⦂ C
  --     --------------------------
  --   → Γ , x ⦂ B ⊢ L ⦂ C
  drop {Γ} {x} {L} {A} {B} {C} ⊢L with ⊢⇒Ok ⊢L
  ... | ok-∷fv (ok-∷fv okΓ lc-A A⊆Γ) lc-B B⊆Γ =
    rename (ok-∷fv okΓ lc-B B⊆Γ) ρ₁ ρ₂ ⊢L
    where
      ρ₁ : ∀ {z C}
        → (Γ , x ⦂ A) , x ⦂ B ∋ z ⦂ C
          -------------------------
        → Γ , x ⦂ B ∋ z ⦂ C
      ρ₁ (H refl) = H′
      ρ₁ (T z≢x (H refl)) = contradiction refl z≢x
      ρ₁ (T z≢x (T .z≢x ∋z)) = T z≢x ∋z
      ρ₂ : ∀ {X}
        → ((Γ , x ⦂ A) , x ⦂ B) ∋ X
          -------------------------
        → (Γ , x ⦂ B) ∋ X
      ρ₂ (S⦂ (S⦂ ∋X)) = S⦂ ∋X

\end{code}

\begin{code}
  subst-open-ty-tm {N} {x} {y} {i} {j} (fr z) x≢y j≥i i≻N
    with x ≟lchar z
  ... | yes refl =
    begin
      N
    ≡⟨ sym (lemma2·7-2-ty-tm ≤-refl (lemma2·6-ty-tm j≥i i≻N)) ⟩
      ty-tm[ j —→ y ] N
    ∎
  ... | no  x≢z  = refl
  subst-open-ty-tm (# k) x≢y j≥i i≻N = refl
  subst-open-ty-tm (ƛ L) x≢y j≥i i≻N
    rewrite subst-open-ty-tm L x≢y j≥i i≻N = refl
  subst-open-ty-tm (L · M) x≢y j≥i i≻N
    rewrite subst-open-ty-tm L x≢y j≥i i≻N
    | subst-open-ty-tm M x≢y j≥i i≻N
    = refl
  subst-open-ty-tm (Λ L) x≢y j≥i i≻N
    rewrite subst-open-ty-tm L x≢y (m≤n⇒m≤1+n j≥i) i≻N = refl
  subst-open-ty-tm (L [ A ]) x≢y j≥i i≻N
    rewrite subst-open-ty-tm L x≢y j≥i i≻N = refl
  subst-open-ty-tm ‵zero x≢y j≥i i≻N = refl
  subst-open-ty-tm (‵suc L) x≢y j≥i i≻N rewrite
    subst-open-ty-tm L x≢y j≥i i≻N = refl

  subst-open-ty-tm-ctx L x≢y j≥i i≻N assump =
    ≡-with-⊢-tm assump (subst-open-ty-tm L x≢y j≥i i≻N)

  subst-open-ty-tm-tm-tm (fr y) j≥i i≻C = refl
  subst-open-ty-tm-tm-tm {j = j} (# k) j≥i i≻C with j ≟ℕ k
  ... | yes refl = refl
  ... | no  j≢k  = refl
  subst-open-ty-tm-tm-tm (ƛ L) j≥i i≻C = cong ƛ_
    (subst-open-ty-tm-tm-tm L (m≤n⇒m≤1+n j≥i) i≻C)
  subst-open-ty-tm-tm-tm (L · M) j≥i i≻C = cong₂ _·_
    (subst-open-ty-tm-tm-tm L j≥i i≻C)
    (subst-open-ty-tm-tm-tm M j≥i i≻C)
  subst-open-ty-tm-tm-tm (Λ L) j≥i i≻C = cong Λ_
    (subst-open-ty-tm-tm-tm L j≥i i≻C)
  subst-open-ty-tm-tm-tm (L [ A ]) j≥i i≻C = cong₂ _[_]
    (subst-open-ty-tm-tm-tm L j≥i i≻C)
    refl
  subst-open-ty-tm-tm-tm ‵zero j≥i i≻C = refl
  subst-open-ty-tm-tm-tm (‵suc L) j≥i i≻C = cong ‵suc_
    (subst-open-ty-tm-tm-tm L j≥i i≻C)

  subst-open-ty-tm-tm-tm-ctx L j≥i i≻C assump =
    ≡-with-⊢-tm assump (subst-open-ty-tm-tm-tm L j≥i i≻C)

  subst-open-ty-ty-ty-ty ‵ℕ x≢y j≥i i≻C = refl
  subst-open-ty-ty-ty-ty {x = x} {j = j} (frᵀ z) x≢y j≥i i≻C
    with x ≟lchar z
  ... | yes refl = sym (lemma2·7-2-ty j≥i i≻C)
  ... | no  x≢z  = refl
  subst-open-ty-ty-ty-ty {x = x} {y = y} {j = j}
      (#ᵀ k) x≢y j≥i i≻C with j ≟ℕ k
  ... | no  j≢k  = refl
  ... | yes refl with x ≟lchar y
  ...   | yes refl = contradiction refl x≢y
  ...   | no  _    = refl
  subst-open-ty-ty-ty-ty (A ⇒ B) x≢y j≥i i≻C rewrite
      subst-open-ty-ty-ty-ty A x≢y j≥i i≻C
    | subst-open-ty-ty-ty-ty B x≢y j≥i i≻C
    = refl
  subst-open-ty-ty-ty-ty {j = j} (∀ᵀ A) x≢y j≥i i≻C = cong ∀ᵀ_
    (subst-open-ty-ty-ty-ty {j = suc j} A x≢y (m≤n⇒m≤1+n j≥i) i≻C)

  subst-open-ty-ty-ty-ty-ctx {A = A} x≢y j≥i i≻C assump =
    ≡-with-⊢-ty assump (subst-open-ty-ty-ty-ty A x≢y j≥i i≻C)

  subst-open-ty-tm-ty-tm (fr z) x≢y j≥i i≻C = refl
  subst-open-ty-tm-ty-tm (# k) x≢y j≥i i≻C = refl
  subst-open-ty-tm-ty-tm (ƛ L) x≢y j≥i i≻C rewrite
    subst-open-ty-tm-ty-tm L x≢y j≥i i≻C = refl
  subst-open-ty-tm-ty-tm (L · M) x≢y j≥i i≻C rewrite
      subst-open-ty-tm-ty-tm L x≢y j≥i i≻C
    | subst-open-ty-tm-ty-tm M x≢y j≥i i≻C
    = refl
  subst-open-ty-tm-ty-tm {j = j} (Λ L) x≢y j≥i i≻C = cong Λ_
    (subst-open-ty-tm-ty-tm {j = suc j} L x≢y (m≤n⇒m≤1+n j≥i) i≻C)
  subst-open-ty-tm-ty-tm (L [ A ]) x≢y j≥i i≻C = cong₂ _[_]
    (subst-open-ty-tm-ty-tm L x≢y j≥i i≻C)
    (subst-open-ty-ty-ty-ty A x≢y j≥i i≻C)
  subst-open-ty-tm-ty-tm ‵zero x≢y j≥i i≻C = refl
  subst-open-ty-tm-ty-tm (‵suc L) x≢y j≥i i≻C rewrite
    (subst-open-ty-tm-ty-tm L x≢y j≥i i≻C) = refl

  subst-open-ty-tm-ty-tm-ctx {L = L} x≢y j≥i i≻C assump =
    ≡-with-⊢-tm assump (subst-open-ty-tm-ty-tm L x≢y j≥i i≻C)

\end{code}

\begin{code}
  -- subst-intro : ∀ {x i} (L N : Term)
  --   → x ∉ fv-tm L
  --   → tm-tm[ i :→ N ] L
  --     ≡ tm-tm[ x := N ] (tm-tm[ i —→ x ] L)
  subst-intro {x} (fr y) N x∉fv-L with x ≟lchar y
  ... | yes refl = contradiction refl (∉∷[]⇒≢ x∉fv-L)
  ... | no  x≢y  = refl
  subst-intro {x} {i} (# k) N x∉fv-L with i ≟ℕ k
  ... | no  i≢k = refl
  ... | yes refl with x ≟lchar x
  ...   | yes refl = refl
  ...   | no  x≢x  = contradiction refl x≢x
  subst-intro {x} {i} (ƛ L) N x∉fv-L
    rewrite subst-intro {x} {suc i} L N x∉fv-L = refl
  subst-intro (L · M) N x∉ =
    let ⟨ x∉fv-L , x∉fv-M ⟩ = ∉-++ {xs = fv-tm L} x∉
    in cong₂ _·_ (subst-intro L N x∉fv-L) (subst-intro M N x∉fv-M)
  subst-intro (Λ L) N x∉fv-L = cong Λ_ (subst-intro L N x∉fv-L)
  subst-intro (L [ A ]) N x∉fv-L =
    cong₂ _[_] (subst-intro L N x∉fv-L) refl
  subst-intro ‵zero N x∉fv-L = refl
  subst-intro (‵suc L) N x∉fv-L =
    cong ‵suc_ (subst-intro L N x∉fv-L)

  -- subst-intro-ty-ty : ∀ {x i B} (A : Type)
  --   → x ∉ ftv-ty A
  --   → ty-ty[ i :→ B ] A
  --     ≡ ty-ty[ x := B ] (ty-ty[ i —→ x ] A)
  subst-intro-ty-ty ‵ℕ x∉ = refl
  subst-intro-ty-ty {x} (frᵀ y) x∉ with x ≟lchar y
  ... | yes refl = contradiction refl (∉∷[]⇒≢ x∉)
  ... | no  x≢y  = refl
  subst-intro-ty-ty {x} {i} (#ᵀ k) x∉ with i ≟ℕ k
  ... | no  i≢k  = refl
  ... | yes refl with x ≟lchar x
  ...   | yes refl = refl
  ...   | no  x≢x  = contradiction refl x≢x
  subst-intro-ty-ty (A ⇒ B) x∉ = let ⟨ x∉A , x∉B ⟩ = ∉-++ x∉
    in cong₂ _⇒_ (subst-intro-ty-ty A x∉A) (subst-intro-ty-ty B x∉B)
  subst-intro-ty-ty {i = i} (∀ᵀ A) x∉ =
    cong ∀ᵀ_ (subst-intro-ty-ty {i = suc i} A x∉)

  -- subst-intro-ty-tm : ∀ {x i B} (L : Term)
  --   → x ∉ ftv-tm L
  --   → ty-tm[ i :→ B ] L
  --     ≡ ty-tm[ x := B ] (ty-tm[ i —→ x ] L)
  subst-intro-ty-tm (fr x) x∉ = refl
  subst-intro-ty-tm (# k) x∉ = refl
  subst-intro-ty-tm (ƛ L) x∉ = cong ƛ_ (subst-intro-ty-tm L x∉)
  subst-intro-ty-tm (L · M) x∉ = let ⟨ x∉L , x∉M ⟩ = ∉-++ x∉
    in cong₂ _·_ (subst-intro-ty-tm L x∉L) (subst-intro-ty-tm M x∉M)
  subst-intro-ty-tm (Λ L) x∉ = cong Λ_ (subst-intro-ty-tm L x∉)
  subst-intro-ty-tm (L [ A ]) x∉ = let ⟨ x∉L , x∉A ⟩ = ∉-++ x∉
    in cong₂ _[_] (subst-intro-ty-tm L x∉L) (subst-intro-ty-ty A x∉A )
  subst-intro-ty-tm ‵zero x∉ = refl
  subst-intro-ty-tm (‵suc L) x∉ = cong ‵suc_ (subst-intro-ty-tm L x∉)
\end{code}

\section{Well-typed terms are locally closed}
\label{appendix:f_well_typed_lc}
\begin{code}
  -- ⊢⇒lc-ty : ∀ {Γ L A} → Γ ⊢ L ⦂ A → Ty-LocallyClosed A
  ⊢⇒lc-ty {Γ} {fr x} (⊢free okΓ lc-A ∋x) = lc-A
  ⊢⇒lc-ty {Γ} {ƛ L} (⊢ƛ lc-B И⟨ Иe₁ , Иe₂ ⟩) j =
    let И⟨ B-Иe₁ , B-Иe₂ ⟩ = lc-B j
        И⟨ A-Иe₁ , A-Иe₂ ⟩ =
          (⊢⇒lc-ty (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})) j
    in И⟨ A-Иe₁ ++ B-Иe₁ , (λ a {a∉} → cong₂ _⇒_
      (B-Иe₂ a {proj₂ (∉-++ {xs = A-Иe₁} a∉)})
      (A-Иe₂ a {proj₁ (∉-++ a∉)})) ⟩
  ⊢⇒lc-ty {Γ} {L · M} (⊢· ⊢L ⊢M) = proj₂ (⇒-≻ (⊢⇒lc-ty ⊢L))
  ⊢⇒lc-ty {Γ} {Λ L} (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) j =
    let induction-hypo = ⊢⇒lc-ty (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
        И⟨ B-Иe₁ , B-Иe₂ ⟩ = induction-hypo (suc j) ⦃ z≤n ⦄
    in И⟨ B-Иe₁ ++ Иe₁ , (λ a {a∉} → cong ∀ᵀ_
      (open-rec-lc-lemma-ty
        (λ ())
        (B-Иe₂ a {proj₁ (∉-++ a∉)}))) ⟩
  ⊢⇒lc-ty {Γ} {L [ B ]} (⊢[] lc-B _ ⊢L) =
    let 1≻A = i≻∀A⇒si≻A (⊢⇒lc-ty ⊢L)
    in helper z≤n 1≻A lc-B
    where
      helper : ∀ {A B i j}
        → j ≥ i
        → (suc i) ≻ty A
        → i ≻ty B → j ≻ty (ty-ty[ i :→ B ] A)
      helper {‵ℕ} j≥i si≻A lc-B j = И⟨ [] , (λ _ → refl) ⟩
      helper {frᵀ x} j≥i si≻A lc-B j = И⟨ [] , (λ _ → refl) ⟩
      helper {#ᵀ n} {_} {i} j≥i si≻A i≻B k with i ≟ℕ n
      ... | yes refl = i≻B k ⦃ ≤-trans j≥i it ⦄
      ... | no  i≢n  with k ≟ℕ n
      ...   | no  _    = И⟨ [] , (λ _ → refl) ⟩
      ...   | yes refl with si≻A n ⦃ ≤∧≢⇒< (≤-trans j≥i it) i≢n ⦄
      ...     | И⟨ Иe₁ , Иe₂ ⟩ with n ≟ℕ n
      ...       | yes refl with () ← Иe₂ (fresh Иe₁) {fresh-correct Иe₁}
      ...       | no  n≢n =  contradiction refl n≢n
      helper {A ⇒ C} j≥i si≻A⇒C i≻B k =
        let ⟨ si≻A , si≻C ⟩ = ⇒-≻ si≻A⇒C
            И⟨ A-Иe₁ , A-Иe₂ ⟩ = (helper j≥i si≻A i≻B) k
            И⟨ C-Иe₁ , C-Иe₂ ⟩ = (helper j≥i si≻C i≻B) k
        in И⟨ A-Иe₁ ++ C-Иe₁ , (λ a {a∉} → cong₂ _⇒_
          (A-Иe₂ a {proj₁ (∉-++ a∉)})
          (C-Иe₂ a {proj₂ (∉-++ {xs = A-Иe₁} a∉)})) ⟩
      helper {∀ᵀ A} {B} {i} j≥i si≻∀A i≻B k =
        let ssi≻A = i≻∀A⇒si≻A si≻∀A
            И⟨ Иe₁ , Иe₂ ⟩ = (helper (s≤s j≥i) ssi≻A si≻B) (suc k) ⦃ s≤s it ⦄
        in И⟨ Иe₁ , (λ a {a∉} → cong ∀ᵀ_ (Иe₂ a {a∉})) ⟩
        where
          si≻B : suc i ≻ty B
          si≻B = lemma2·6-ty (n≤1+n i) i≻B
  ⊢⇒lc-ty {Γ} {‵zero} (⊢zero _) = n≻‵ℕ
  ⊢⇒lc-ty {Γ} {‵suc L} (⊢suc ⊢L) = n≻‵ℕ

  -- ⊢⇒lc-ty-tm : ∀ {Γ L A}
  --   → Γ ⊢ L ⦂ A → Ty-Tm-LocallyClosed L
  ⊢⇒lc-ty-tm (⊢free okΓ lc-A ∋x) j = И⟨ [] , (λ _ → refl) ⟩
  ⊢⇒lc-ty-tm (⊢ƛ lc-A И⟨ B-Иe₁ , B-Иe₂ ⟩) j =
    let И⟨ A-Иe₁ , A-Иe₂ ⟩ = lc-A j
        И⟨ Иe₁ , Иe₂ ⟩ = (⊢⇒lc-ty-tm (B-Иe₂ #-B-Иe₁ {#-B-Иe₁-✓})) j
    in И⟨ Иe₁ ++ A-Иe₁ , (λ a {a∉} → cong ƛ_
      (open-rec-lc-lemma-ty-tm-tm-tm
        (Иe₂ a {proj₁ (∉-++ a∉)}))) ⟩
    where
      #-B-Иe₁ : Id
      #-B-Иe₁ = fresh B-Иe₁
      #-B-Иe₁-✓ : #-B-Иe₁ ∉ B-Иe₁
      #-B-Иe₁-✓ = fresh-correct B-Иe₁
  ⊢⇒lc-ty-tm {Γ} (⊢· ⊢L ⊢M) j = И⟨ [] , (λ a → cong₂ _·_
    (lemma2·7-2-ty-tm it (⊢⇒lc-ty-tm ⊢L))
    (lemma2·7-2-ty-tm it (⊢⇒lc-ty-tm ⊢M))) ⟩
  ⊢⇒lc-ty-tm {Γ} {Λ L} (⊢Λ И⟨ Иe₁ , Иe₂ ⟩) j =
      let induc-hypo = ⊢⇒lc-ty-tm (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})
          sj≻ = lemma2·6-ty-tm z≤n induc-hypo
          И⟨ L-Иe₁ , L-Иe₂ ⟩ = (helper L z≤n sj≻) (suc j) ⦃ s≤s it ⦄
      in И⟨ L-Иe₁ , (λ a {a∉} → cong Λ_ (L-Иe₂ a {a∉})) ⟩
    where
      helper : ∀ {i x j} (L : Term)
        → j ≥ i
        → (suc i) ≻ty-tm (ty-tm[ i —→ x ] L)
        → (suc j) ≻ty-tm L
      helper L j≥i si≻[]L k =
        let И⟨ Иe₁ , Иe₂ ⟩ = si≻[]L k ⦃ ≤-trans (s≤s j≥i) it ⦄
            k≢i = sym-≢ (<⇒≢ (≤-trans (s≤s j≥i) it))
        in И⟨ Иe₁ , (λ a {a∉} →
          open-rec-lc-lemma-ty-tm k≢i (Иe₂ a {a∉})) ⟩
  ⊢⇒lc-ty-tm {Γ} (⊢[] lc _ ⊢L) j =
    И⟨ [] , (λ a → cong₂ _[_]
      (lemma2·7-2-ty-tm it (⊢⇒lc-ty-tm ⊢L))
      (lemma2·7-2-ty it lc)) ⟩
  ⊢⇒lc-ty-tm (⊢zero _) j = И⟨ [] , (λ _ → refl) ⟩
  ⊢⇒lc-ty-tm {Γ} (⊢suc ⊢L) j = И⟨ [] , (λ a →
    cong ‵suc_ (lemma2·7-2-ty-tm it (⊢⇒lc-ty-tm ⊢L))) ⟩
\end{code}

\chapter{Local closure definition equivalence}
\label{appendix:lc_equivalence}
We aim to prove that our definition of local closure is equivalent to the definition that
\citet{pitts_locally_2023} gives. I will show that the three local closure definitions given in
Section \ref{chapter3:local_closure} are each equivalent to a version using existential
quantification.

\begin{comment}
\begin{code}
  open import Data.Product using (∃; ∃-syntax)
\end{code}
\end{comment}

We will prove an if and only if relation between the two by having two functions for each direction
of the implication. We will only give an explanation of the Agda code for the type-in-type local
closure, but the proofs for the other two openings work similarly. We first define the existential
local closure predicate.
\begin{code}
  _≻'ty_ : ℕ → Type → Set
  i ≻'ty A = (j : ℕ) ⦃ _ : j ≥ i ⦄ → ∃[ T ] (ty-ty[ j —→ T ] A ≡ A)
\end{code}

The proof of the necessary condition is straight-forward. Since we can always create a new
identifier, we simply create one that is not in the `disallow' list provided by the cofinite
quantifier.

\begin{code}
  ≻ty⇒≻'ty : ∀ (i : ℕ) (A : Type)
    → i ≻ty A → i ≻'ty A
  ≻ty⇒≻'ty i A i≻tyA j =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻tyA j
    in ⟨ (fresh Иe₁) , Иe₂ (fresh Иe₁) {fresh-correct Иe₁} ⟩
\end{code}

Now we prove the sufficient condition by induction on the structure of the type.
\begin{code}
  ≻'ty⇒≻ty : ∀ (i : ℕ) (A : Type)
    → i ≻'ty A → i ≻ty A
  ≻'ty⇒≻ty i ‵ℕ i≻'tyA = n≻‵ℕ
  ≻'ty⇒≻ty i (frᵀ X) i≻'tyA j = И⟨ [] , (λ _ → refl) ⟩
\end{code}
The base cases \texttt{‵ℕ}, and \texttt{frᵀ} are trivial.
\begin{code}
  ≻'ty⇒≻ty i (#ᵀ k) i≻'tyA j with j ≟ℕ k
  ... | no  j≢k  = И⟨ [] , (λ _ → refl) ⟩
  ... | yes refl with i≻'tyA j
  ...   | ⟨ X , op-invariant ⟩ with k ≟ℕ k
  ...     | yes refl with () ← op-invariant
  ...     | no  k≢k  = contradiction refl k≢k
\end{code}
For a bound variable, if the bound variable is not the same as the index, we don't replace and so
the proof is completed by reflexivity. If they are the same, then that means that the other local
closure would have opened the term, which would \textit{not} have left the term unchanged---a
contradiction.
\begin{code}
  ≻'ty⇒≻ty i (A ⇒ B) i≻'ty j =
    let И⟨ A-Иe₁ , A-Иe₂ ⟩ = (≻'ty⇒≻ty i A i≻'tyA) j
        И⟨ B-Иe₁ , B-Иe₂ ⟩ = (≻'ty⇒≻ty i B i≻'tyB) j
    in И⟨ A-Иe₁ ++ B-Иe₁ , (λ X {X∉} →
      let ⟨ X∉A , X∉B ⟩ = ∉-++ X∉
      in cong₂ _⇒_ (A-Иe₂ X {X∉A}) (B-Иe₂ X {X∉B})) ⟩
    where
      i≻'tyA : i ≻'ty A
      i≻'tyA j = let ⟨ X , op-invariant ⟩ = i≻'ty j
        in ⟨ X , proj₁ (⇒-inj op-invariant) ⟩
      i≻'tyB : i ≻'ty B
      i≻'tyB j = let ⟨ X , op-invariant ⟩ = i≻'ty j
        in ⟨ X , proj₂ (⇒-inj op-invariant) ⟩
  ≻'ty⇒≻ty i (∀ᵀ A) i≻'ty j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo (suc j) ⦃ s≤s it ⦄
    in И⟨ Иe₁ , (λ X {X∉} → (cong ∀ᵀ_ (Иe₂ X {X∉}))) ⟩
    where
      si≻'tyA : (suc i) ≻'ty A
      si≻'tyA (suc j) =
        let ⟨ X , op-invariant ⟩ = i≻'ty j ⦃ ≤-pred it ⦄
        in ⟨ X , ∀-inj op-invariant ⟩
      induc-hypo : (suc i) ≻ty A
      induc-hypo = ≻'ty⇒≻ty (suc i) A si≻'tyA
\end{code}
The other cases are the inductive steps and simply use the inductive hypothesis together with the
injectivity of \texttt{⇒}, \texttt{∀ᵀ}, and \texttt{‵suc}.

The proofs for the other kinds of local closure work by the same reasoning.
\begin{code}
  _≻'tm_ : ℕ → Term → Set
  i ≻'tm L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → ∃[ T ] (tm-tm[ j —→ T ] L ≡ L)

  ≻tm⇒≻'tm : ∀ (i : ℕ) (L : Term)
    → i ≻tm L → i ≻'tm L
  ≻tm⇒≻'tm i L i≻tmA j = let И⟨ Иe₁ , Иe₂ ⟩ = i≻tmA j
    in ⟨ (fresh Иe₁) , Иe₂ (fresh Иe₁) {fresh-correct Иe₁} ⟩

  ≻'tm⇒≻tm : ∀ (i : ℕ) (L : Term)
    → i ≻'tm L → i ≻tm L
  ≻'tm⇒≻tm i (fr x) i≻'L j = И⟨ [] , (λ _ → refl) ⟩
  ≻'tm⇒≻tm i (# k) i≻'L j with j ≟ℕ k
  ... | no  _    = И⟨ [] , (λ _ → refl) ⟩
  ... | yes refl with i≻'L j
  ...   | ⟨ X , op-invariant ⟩ with k ≟ℕ k
  ...     | yes refl with () ← op-invariant
  ...     | no  k≢k = contradiction refl k≢k
  ≻'tm⇒≻tm i (ƛ L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo (suc j) ⦃ s≤s it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → cong ƛ_ (Иe₂ a {a∉})) ⟩
    where
      si≻'L : (suc i) ≻'tm L
      si≻'L (suc j) =
        let ⟨ X , op-invariant ⟩ = i≻' j ⦃ ≤-pred it ⦄
        in ⟨ X , ƛ-inj op-invariant ⟩
      induc-hypo : (suc i) ≻tm L
      induc-hypo = ≻'tm⇒≻tm (suc i) L si≻'L
  ≻'tm⇒≻tm i (L · M) i≻' j =
    let И⟨ L-Иe₁ , L-Иe₂ ⟩ = (≻'tm⇒≻tm i L i≻'L) j
        И⟨ M-Иe₁ , M-Иe₂ ⟩ = (≻'tm⇒≻tm i M i≻'M) j
    in И⟨ L-Иe₁ ++ M-Иe₁ , (λ a {a∉} →
      let ⟨ a∉L , a∉M ⟩ = ∉-++ a∉
      in cong₂ _·_ (L-Иe₂ a {a∉L}) (M-Иe₂ a {a∉M})) ⟩
    where
      i≻'L : i ≻'tm L
      i≻'L j = let ⟨ x , op-invariant ⟩ = i≻' j
        in ⟨ x , proj₁ (·-inj op-invariant) ⟩
      i≻'M : i ≻'tm M
      i≻'M j = let ⟨ x , op-invariant ⟩ = i≻' j
        in ⟨ x , proj₂ (·-inj op-invariant) ⟩      
  ≻'tm⇒≻tm i (Λ L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo j
    in И⟨ Иe₁ , (λ a {a∉} → cong Λ_ (Иe₂ a {a∉})) ⟩
    where
      i≻'L : i ≻'tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , Λ-inj op-invariant ⟩
      induc-hypo : i ≻tm L
      induc-hypo = ≻'tm⇒≻tm i L i≻'L
  ≻'tm⇒≻tm i (L [ A ]) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo j
    in И⟨ Иe₁ , (λ a {a∉} → cong _[ A ] (Иe₂ a {a∉})) ⟩
    where
      i≻'L : i ≻'tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , proj₁ ([]-inj op-invariant) ⟩
      induc-hypo : i ≻tm L
      induc-hypo = ≻'tm⇒≻tm i L i≻'L
  ≻'tm⇒≻tm i ‵zero i≻' j = И⟨ [] , (λ _ → refl) ⟩
  ≻'tm⇒≻tm i (‵suc L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo j
    in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩
    where
      i≻'L : i ≻'tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , ‵suc-inj op-invariant ⟩
      induc-hypo : i ≻tm L
      induc-hypo = ≻'tm⇒≻tm i L i≻'L

  _≻'ty-tm_ : ℕ → Term → Set
  i ≻'ty-tm L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → ∃[ a ] (ty-tm[ j —→ a ] L ≡ L)

  ≻ty-tm⇒≻'ty-tm : ∀ (i : ℕ) (L : Term)
    → i ≻ty-tm L → i ≻'ty-tm L
  ≻ty-tm⇒≻'ty-tm i L i≻L j =
    let И⟨ Иe₁ , Иe₂ ⟩ = i≻L j
    in ⟨ (fresh Иe₁) , Иe₂ (fresh Иe₁) {fresh-correct Иe₁} ⟩

  ≻'ty-tm⇒≻ty-tm : ∀ (i : ℕ) (L : Term)
    → i ≻'ty-tm L → i ≻ty-tm L
  ≻'ty-tm⇒≻ty-tm i (fr x) i≻'L j = И⟨ [] , (λ _ → refl) ⟩
  ≻'ty-tm⇒≻ty-tm i (# k) i≻'L j = И⟨ [] , (λ _ → refl) ⟩
  ≻'ty-tm⇒≻ty-tm i (ƛ L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo j
    in И⟨ Иe₁ , (λ a {a∉} → cong ƛ_ (Иe₂ a {a∉})) ⟩
    where
      i≻'L : i ≻'ty-tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , ƛ-inj op-invariant ⟩
      induc-hypo : i ≻ty-tm L
      induc-hypo = ≻'ty-tm⇒≻ty-tm i L i≻'L
  ≻'ty-tm⇒≻ty-tm i (L · M) i≻' j =
    let И⟨ L-Иe₁ , L-Иe₂ ⟩ = (≻'ty-tm⇒≻ty-tm i L i≻'L) j
        И⟨ M-Иe₁ , M-Иe₂ ⟩ = (≻'ty-tm⇒≻ty-tm i M i≻'M) j
    in И⟨ L-Иe₁ ++ M-Иe₁ , (λ a {a∉} →
      let ⟨ a∉L , a∉M ⟩ = ∉-++ a∉
      in cong₂ _·_ (L-Иe₂ a {a∉L}) (M-Иe₂ a {a∉M})) ⟩
    where
      i≻'L : i ≻'ty-tm L
      i≻'L j = let ⟨ x , op-invariant ⟩ = i≻' j
        in ⟨ x , proj₁ (·-inj op-invariant) ⟩
      i≻'M : i ≻'ty-tm M
      i≻'M j = let ⟨ x , op-invariant ⟩ = i≻' j
        in ⟨ x , proj₂ (·-inj op-invariant) ⟩      
  ≻'ty-tm⇒≻ty-tm i (Λ L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo (suc j) ⦃ s≤s it ⦄
    in И⟨ Иe₁ , (λ a {a∉} → cong Λ_ (Иe₂ a {a∉})) ⟩
    where
      si≻'L : (suc i) ≻'ty-tm L
      si≻'L (suc j) =
        let ⟨ X , op-invariant ⟩ = i≻' j ⦃ ≤-pred it ⦄
        in ⟨ X , Λ-inj op-invariant ⟩
      induc-hypo : (suc i) ≻ty-tm L
      induc-hypo = ≻'ty-tm⇒≻ty-tm (suc i) L si≻'L
  ≻'ty-tm⇒≻ty-tm i (L [ A ]) i≻' j =
    let И⟨ L-Иe₁ , L-Иe₂ ⟩ = L-induc-hypo j
        И⟨ A-Иe₁ , A-Иe₂ ⟩ = A-induc-hypo j
    in И⟨ L-Иe₁ ++ A-Иe₁ , (λ a {a∉} →
      let ⟨ a∉L , a∉A ⟩ = ∉-++ a∉
      in cong₂ _[_] (L-Иe₂ a {a∉L}) (A-Иe₂ a {a∉A}))⟩
    where
      i≻'L : i ≻'ty-tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , proj₁ ([]-inj op-invariant) ⟩
      L-induc-hypo : i ≻ty-tm L
      L-induc-hypo = ≻'ty-tm⇒≻ty-tm i L i≻'L
      i≻'A : i ≻'ty A
      i≻'A j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , proj₂ ([]-inj op-invariant) ⟩
      A-induc-hypo : i ≻ty A
      A-induc-hypo = ≻'ty⇒≻ty i A i≻'A
  ≻'ty-tm⇒≻ty-tm i ‵zero i≻' j = И⟨ [] , (λ _ → refl) ⟩
  ≻'ty-tm⇒≻ty-tm i (‵suc L) i≻' j =
    let И⟨ Иe₁ , Иe₂ ⟩ = induc-hypo j
    in И⟨ Иe₁ , (λ a {a∉} → cong ‵suc_ (Иe₂ a {a∉})) ⟩
    where
      i≻'L : i ≻'ty-tm L
      i≻'L j =
        let ⟨ X , op-invariant ⟩ = i≻' j
        in ⟨ X , ‵suc-inj op-invariant ⟩
      induc-hypo : i ≻ty-tm L
      induc-hypo = ≻'ty-tm⇒≻ty-tm i L i≻'L
\end{code}

\label{appendix:lc_note}
Note that this cannot be proven for any locally nameless set, but it does hold for any locally
nameless set. This is because the proof of the sufficient condition requires induction on the
structure of the set, and we cannot do this in the general case. However, if one works uses locally
nameless representation for a syntax for a programming language, we know the structure of the syntax
and thus \textit{can} use induction on the structure.

The proof for any programming language which uses an inductively defined structure with free and
bound variables follows the same strategy as presented above. For the base case of a bound variable,
if the index $j$ is equal to or smaller $i$, then the existential local closure predicate doesn't
hold and we have a contradiction. Otherwise, opening it will have no effect, and so the opened term
is trivially equal to itself. For the other base cases, opening will have no effect, and so again,
we are done. For the inductive steps, we simply use the injectivity of the syntax, optionally
requiring modifying the index if going under a binder, together with the inductive hypothesis.

\chapter{Prior work submitted for TSPL}
\label{appendix:tspl}
\input{tspl_prior_work.tex}

\chapter{Compilation instructions}
\label{appendix:compilation_instructions}

This document is a literate Agda file. It has been tested to work with
\begin{itemize}
  \item Agda 2.7.0,

  \item the Agda Standard Library 2.1 \citep{the_agda_community_agda_2024},

  \item XeLaTeX 3.141592653-2.6-0.999997 (TeX Live 2026/dev/Arch Linux) (using Arch Linux package
  \texttt{texlive-xetex} 2025.2-1).
\end{itemize}

You should have received the full source code with this document. If not, it is available at
\url{https://github.com/ettolrach/system-f-in-agda-via-pitts}.

To typecheck the \texttt{.agda} files, simply run \texttt{agda FILE.agda}, or open the file in an
editor with Agda support, like Emacs.

To compile the LaTeX files, located in the \texttt{./latex} directory, follow these instructions:

\begin{enumerate}
  \item Change directory to \texttt{./latex}.
  
  \item Choose a temporary directory to compile the LaTeX and PDF files to. We will refer to this as
  \texttt{\$TMP}.

  \item Run \texttt{./agda\_build.sh \$TMP} to build the literate Agda LaTeX files. The script will
  exit with code 0 if it is successful. The script is written for a Linux target, but should be
  relatively easy to modify for other operating systems by inspecting its source code.

  \item Run \texttt{latexmk -xelatex -shell-escape -cd \$TMP/dissertation.tex} (I would recommend
  the \texttt{-quiet} option too).

  \item The compiled document will be in \texttt{\$TMP/dissertation.pdf}.
\end{enumerate}

\end{document}

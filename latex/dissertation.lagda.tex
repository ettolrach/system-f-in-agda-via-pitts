% UG project example file, February 2024
%
%   Added the "online" option for equal margins, February 2024 [Hiroshi Shimodaira, Iain Murray]
%   A minor change in citation, September 2023 [Hiroshi Shimodaira]
%
% Do not change the first two lines of code, except you may delete "logo," if causing problems.
% Understand any problems and seek approval before assuming it's ok to remove ugcheck.
\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


% Include any packages you need below, but don't include any that change the page
% layout or style of the dissertation. By including the ugcheck package above,
% you should catch most accidental changes of page layout though.

\usepackage{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

% === Custom packages === %

% Syntax highlighting
\usepackage{minted}
% BNF
\usepackage{simplebnf}
% Unicode
%\usepackage[utf8]{inputenc}
% Inference rules
\usepackage{mathpartir}
% Agda
\usepackage{agda}
\AgdaNoSpaceAroundCode{}
% Hide output
\usepackage{comment}

% Unicode

\usepackage{fontspec}
\usepackage{newunicodechar}
\newfontface{\whatever}{Noto Sans Mono Regular}
\newunicodechar{ℕ}{{\whatever{ℕ}}}
\newunicodechar{∀}{{\whatever{∀}}}
\newunicodechar{≡}{{\whatever{≡}}}
\newunicodechar{≥}{{\whatever{≥}}}
\newunicodechar{≤}{{\whatever{≤}}}
\newunicodechar{≰}{{\whatever{≰}}}
\newunicodechar{⊔}{{\whatever{⊔}}}
\newunicodechar{≟}{{\whatever{≟}}}
\newunicodechar{⇒}{{\whatever{⇒}}}
\newunicodechar{≢}{{\whatever{≢}}}
\newunicodechar{≮}{{\whatever{≮}}}
\newunicodechar{⟪}{{\whatever{⟪}}}
\newunicodechar{⟫}{{\whatever{⟫}}}
\newunicodechar{⊤}{{\whatever{⊤}}}
\newunicodechar{⊥}{{\whatever{⊥}}}
\newunicodechar{∣}{{\whatever{∣}}}
\newunicodechar{⟨}{{\whatever{⟨}}}
\newunicodechar{⟩}{{\whatever{⟩}}}
\newunicodechar{∎}{{\whatever{∎}}}
%%\newunicodechar{¬}{{\whatever{¬}}}
\newunicodechar{⌊}{{\whatever{⌊}}}
\newunicodechar{⌋}{{\whatever{⌋}}}
%%\newunicodechar{×}{{\whatever{×}}}
\newunicodechar{₁}{{\whatever{₁}}}
\newunicodechar{₂}{{\whatever{₂}}}
\newunicodechar{∃}{{\whatever{∃}}}
\newunicodechar{∷}{{\whatever{∷}}}
\newunicodechar{∈}{{\whatever{∈}}}
\newunicodechar{∉}{{\whatever{∉}}}
\newunicodechar{λ}{{\whatever{λ}}}
\newunicodechar{И}{{\whatever{И}}}
\newunicodechar{∘}{{\whatever{∘}}}

% Maths:

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Real}{Re}
\DeclareMathOperator{\Imag}{Im}
\DeclareMathOperator{\complex}{\mathbb{C}}
\DeclareMathOperator{\reals}{\mathbb{R}}
\DeclareMathOperator{\nat}{\mathbb{N}}
\DeclareMathOperator{\integer}{\mathbb{Z}}
\DeclareMathOperator{\rational}{\mathbb{Q}}
\DeclareMathOperator{\Log}{Log}
\DeclareMathOperator{\Arg}{Arg}
\DeclareMathOperator{\cof}{\text{И}}

% Use minted for Agda

\let\oldcode\code
\NewCommandCopy{\mintedcopy}{\minted}
\NewCommandCopy{\endmintedcopy}{\endminted}
% Adapted from https://tex.stackexchange.com/a/488451/202867
\renewenvironment{code}{\mintedcopy[breaklines]{agda}}{\endmintedcopy}
% \let\oldcode\code
% % Adapted from https://tex.stackexchange.com/a/488451/202867
% \def\code{\minted{agda}}

\begin{document}
\begin{preliminary}

\title{System F in Agda via Pitts}

\author{Charlotte Ausel}

% CHOOSE YOUR DEGREE a):
% please leave just one of the following un-commented
% \course{Artificial Intelligence}
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Software Engineering}
%\course{Cognitive Science}
%\course{Computer Science}
%\course{Computer Science and Management Science}
\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}
%\course{Software Engineering}
%\course{Master of Informatics} % MInf students

% CHOOSE YOUR DEGREE b):
% please leave just one of the following un-commented
%\project{MInf Project (Part 1) Report}  % 4th year MInf students
%\project{MInf Project (Part 2) Report}  % 5th year MInf students
\project{4th Year Project Report}        % all other UG4 students


\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

TODO

\begin{code}
module dissertation where
\end{code}

\chapter{Background}

\section{Agda}
Agda is a dependently-typed functional programming language, which makes it
suitable as a proof-assistant for intuitionistic logic
\citep{norell_towards_2007}, similar to other such proof-assistants like Coq or
Lean. Its syntax is very similar to Haskell, and in fact, the two are closely
related; the Agda compiler is a transpiler to Haskell, and the Haskell standard
library can be used in Agda \citep{kusee_compiling_2017}. Yet, Agda has stricter
limitations on recursive functions and some other such language features which,
if included, would make it harder to reason about proofs
\citep{berghofer_brief_2009}.

Agda most commonly uses inductive definitions. For example, following the Peano
axioms for the natural numbers $\nat$ \citep{boolos_freges_1995}, we may define
them like so.

% \begin{code}
% module Example where
%   data ℕ : Set where
%     zero : ℕ
%     suc  : ℕ → ℕ
% \end{code}


Taking advantage of the Curry-Howard correspondence, a proof in Agda is simply a
function with an appropriate type signature and function body
\citep{wadler_propositions_2015}. So, a proof that addition is associative would
use recursion, which corresponds to induction, as shown below.

% \begin{code}
% open import Relation.Binary.PropositionalEquality
%   using (_≡_; refl; cong)
% open import Data.Nat using (ℕ; zero; suc; _+_)

% +-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
% +-assoc zero    n p = refl
% +-assoc (suc m) n p = cong suc (+-assoc m n p)
% \end{code}

We will need a lot of imports from the Agda standard library.

\begin{comment}
\begin{code}
-- Data types (naturals, strings, characters)
open import Data.Nat using (ℕ; zero; suc; _<_; _≥_; _≤_; _≤?_; _<?_; z≤n; s≤s; _⊔_)
  renaming (_≟_ to _≟ℕ_)
open import Data.Nat.Properties using (≤-refl; ≤-trans; ≤-<-trans; <-≤-trans; ≤-antisym; ≤-total;
  +-mono-≤; n≤1+n; m≤n⇒m≤1+n; suc-injective; <⇒≢; ≰⇒>; ≮⇒≥)
open import Data.String using (String; fromList) renaming (_≟_ to _≟str_; _++_ to _++str_;
  length to str-length; toList to ⟪_⟫)
open import Data.Char using (Char)
open import Data.Char.Properties using () renaming (_≟_ to _≟char_)
open import Data.Unit using (⊤; tt)

-- Function manipulation.
open import Function using (_∘_; flip; it; id; case_returning_of_)

-- Relations and predicates/decidability.
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; sym; trans; cong; cong-app; cong₂)
open Eq.≡-Reasoning using (begin_; step-≡-∣; step-≡-⟩; _∎)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Nullary.Decidable using (Dec; yes; no; True; False; toWitnessFalse;
  toWitness; fromWitness; ¬?; ⌊_⌋; From-yes)
open import Relation.Unary using (Decidable)
open import Relation.Binary using () renaming (Decidable to BinaryDecidable)
open import Relation.Nullary.Negation using (¬_; contradiction)
open import Data.Empty using (⊥-elim)

-- Products and exists quantifier.
open import Data.Product using (_×_; proj₁; proj₂; ∃-syntax) renaming (_,_ to ⟨_,_⟩)

-- Lists.
open import Data.List using (List; []; _∷_; _++_; length; filter; map; foldr; head; replicate)
open import Data.List.Properties using (≡-dec)
import Data.List.Membership.DecPropositional as DecPropMembership
open import Data.List.Relation.Unary.All using (All; all?; lookup)
  renaming (fromList to All-fromList; toList to All-toList)
open import Data.List.Relation.Unary.Any using (Any; here; there)
open import Data.List.Extrema Data.Nat.Properties.≤-totalOrder using (max; xs≤max)

-- Import list membership using List Char comparisons.
_≟lchar_ : ∀ (xs ys : List Char) → Dec (xs ≡ ys)
xs ≟lchar ys = ≡-dec (_≟char_) xs ys

open DecPropMembership _≟lchar_ using (_∈_; _∉_; _∈?_)
\end{code}
\end{comment}

We also need to forward-declare some theorems. These are proven in appendix A [TODO].

\begin{code}
All¬⇒¬Any : ∀ {A : Set} {P : A → Set} {xs : List A}
  → All (¬_ ∘ P) xs
    ---------------
  → (¬_ ∘ Any P) xs

¬Any⇒All¬ : ∀ {A : Set} {P : A → Set} {xs : List A}
  → (¬_ ∘ Any P) xs
    ---------------
  → All (¬_ ∘ P) xs

∉-++ : ∀ {s : List Char} {xs ys : List (List Char)}
  → s ∉ xs ++ ys
    --------------------
  → (s ∉ xs) × (s ∉ ys)

++-∉ : ∀ {s : List Char} {xs ys : List (List Char)}
  → s ∉ xs
  → s ∉ ys
    -------------
  → s ∉ xs ++ ys

∉∷[]⇒≢ : {x y : List Char} → x ∉ y ∷ [] → x ≢ y

sym-≢ : ∀ {A : Set} {x y : A}
  → x ≢ y
    -----
  → y ≢ x

∉⇒≢ : ∀ {xs : List (List Char)} {x y : List Char}
  → x ∈ xs
  → y ∉ xs
    -------
  → x ≢ y

\end{code}

\section{The $\lambda$-Calculus and System F}

\paragraph*{The $\lambda$-calculus.} The $\lambda$-calculus (pronounced
\textit{lambda calculus}), is a theoretical model of computation developed by
Alonzo Church in the 1930s (first described in \citet{church_set_1932}) and is
what System F is based upon. It looks and works similarly to familiar functional
programming languages, yet its definition is as minimal as possible while still
being Turing-complete\footnote{Although Turing machines would be invented after
the $\lambda$-calculus, `turing-complete' has become a shorthand for `universal
method of computation'. Such a universal method was not Church's initial goal,
but is why we're still interested in the $\lambda$-calculus.}. As described in
\cite{pierce_types_2002}, the most relevant results are summarised below.

We have the following familiar BNF grammar for any $\lambda$-calculus term $t$.

\begin{center}
\begin{bnf}
  $t$ ::=
  | $x$ : variables
  | $\lambda \, x. t$ : ($\lambda$)-abstractions
  | $t_1 t_2$ : function application
\end{bnf}
\end{center}

Function application is left-associative (so for all abstractions $f$, $f a b =
(f a) b$), and $\lambda$-abstractions extend as far as possible (e.g. $\lambda
f. f a b = \lambda f. (f a b)$).

The $\lambda$-calculus includes three reductions. $\alpha$-conversion is the
renaming of variables such that the semantics of the program are not changed;
terms which are semantically identical but use different variable bindings are
called $\alpha$-equivalent, and $\alpha$-equivalence is an equivalence-relation.
$\beta$-reduction is how functions are applied; for any term $t$, we write a
reduction as $t \mapsto_{\beta} t'$. For any function application $(\lambda \,
x. t) u$, we replace all occurrences of $x$ in $t$ with $u$. $\beta$-reduction
is a congruence, so if $t \mapsto_{\beta} t'$, then $st \mapsto_{\beta} st'$,
and $ts \mapsto_{\beta} t's$.

Finally, we have $\eta$-reduction; for all $\lambda$-abstractions $\lambda \, x.
f x$, we have that $\lambda \, x. f x \mapsto_{\eta} f$ (this is the idea of
function extensionality).
  
If further $\beta$-reducations do not simplify a term, we say that it is in its
\textit{normal form}. We shall represent an arbitrary number of successive
$\beta$-reductions as $\mapsto_{\beta^{\star}}$.

Lastly, the Church-Rosser theorem states that for any term $t$, if it
$\beta$-reduces to two terms $a$ and $b$, then there exists a common term $t'$
which both $a$ and $b$ eventually $\beta$-reduce to
\citep{church_properties_1936}.

Notably, some terms may not have a normal form. A famous example is
\textit{omega} (sometimes called the \textit{omega combinator}) defined as
$(\lambda \, x. (x x)) (\lambda \, x. (x x))$, which when applied to itself
doesn't reduce any further.

\begin{equation*}
  (\lambda \, x. (x x)) (\lambda \, x. (x x)) \quad \mapsto_{\beta} \quad (\lambda \, x. (x x)) (\lambda \, x. (x x))
\end{equation*}

Just the first $\lambda \, x. (x x)$ part on its own is called \textit{little
omega}. Another famous example is the fixpoint called the
\textit{y-combinator}\footnote{Defined as $\mathcal{Y} \triangleq (\lambda \, f.
(\lambda \, x. f (x x )) (\lambda \, x. f (xx)))$}. Given any argument, it will
$\beta$-reduce to the argument applied to itself.

We say that these terms \textit{do not have a normal form}.

\paragraph*{The simply-typed $\lambda$-calculus.} While not being
Turing-complete, the simply-typed $\lambda$-calculus (STLC for short and
sometimes given the symbol $\lambda^{\rightarrow}$) is an extension of the
untyped $\lambda$-calculus described above that was developed in
\citet{church_formulation_1940} which requires each term to have a
\textit{type}. Terms which do not have a normal form cannot be given a type. As
such, we only permit `nice' expressions, that is, all expressions will (after
successive $\beta$-reductions) result in an irreducible expression---their
normal form. This is also called \textit{strong normalisation}.
\citep{pierce_types_2002}

Since we can no longer represent all of the terms of the untyped
$\lambda$-calculus, the STLC is not Turing-complete. Nevertheless, the STLC is
still useful, since we can guarantee that any term which can be given a type
will have a normal form. Having a normal form is the $\lambda$-calculus
equivalent of a Turing machine encoding halting. The popular saying goes,
`well-typed programs can't go wrong!' \citep{milner_theory_1978}

The base types we will commonly be using are the booleans $\mathbb{B}$ and the
naturals $\nat$ (we could use just one, but using two will make the examples
easier to understand)\footnote{If we didn't include any base types, then our
computational model becomes \textit{degenerate} (that is, there are no terms).
This is because everything has to have a type, and if there are no types, then
nothing can exist.}. We shall call the set of base types $T$, so in our case, $T
= \{ \mathbb{B} , \nat \}$. The set of variables will be $V$. Our \textit{type
context} (also called \textit{type environment}) will be given the symbol
$\Gamma$, which is a map from variables to types $\Gamma \colon V \to T$
(alternatively, we can see it as a sequence indexed by variables $(T_v)_{v \in
V}$). We closely follow the syntax that is used by \citet{pierce_types_2002}.

In the STLC, we couldn't give a type to little omega, since we can't give a type
to both the argument and the argument applied to itself ($\lambda \, x  \colon ?
. x x \colon ??$). If our context contained the mapping $x \colon \nat$, then we
could write an function which applies its argument to $x$ like so,

\begin{equation*}
  x \colon \nat \in \Gamma \vdash (\lambda \, f \colon \nat \to \nat . f x) \colon \nat.
\end{equation*}

Crucially, if $x$ had type $\mathbb{B}$, we would fail to determine the type of
the function, and so we can guarantee that all permitted expressions `can't go
wrong' \citep{milner_theory_1978} (since untypable expresisons are disallowed).

This paper will build upon and borrow notation from the textbook
\textit{Programming Language Foundations in Agda}
\citep{wadler_programming_2022}, which includes an implementation of the STLC
and also serves as further background.

\paragraph*{System F.} System F has been the formal background to what many modern programming
languages call \textit{generics}. For example, in Rust, we could write a function which applies a
function twice to an argument.

\begin{minted}[samepage]{rust}
fn twice<A, F>(f: F, x: A) -> A
where
    F: Fn(A) -> A,
{
    f(f(x))
}
\end{minted}

Since we used a \textit{type parameter} in the function's type signature, in this case called
\texttt{T}, we can supply any appropriate function which has the type signature $T \to T$. One such
function is \texttt{u64::isqrt}, the (flooring) square root function. If this function was invoked
with \texttt{twice(u64::isqrt, 81)}, its output would be \texttt{3}. In this case, the compiler is
clever enough to infer that the type for \texttt{A} should be \texttt{u64}, so we don't need to
specify it manually.

System F is the STLC equipped with \textit{polymorphic types}, another term for type parameters. It
was independently discovered by Jean-Yves  and John (who gave it the more straight-forward name,
\textit{the polymorphic
$\lambda$-calulus}). We can write this \textit{twice} function like so in System F:

\begin{equation*}
  \Lambda \, T. \lambda \, f \colon T \to T . \lambda \, x \colon T . f (f x) \colon \forall T . (T \to T) \to T \to T.
\end{equation*}

If we wanted to use this function and be explicit about what type we're using, we could instantiate
it with a specific type, notated using [square brackets]. For instance,

\begin{align*}
  s \colon \nat \to \nat, z \colon \nat \in \Gamma \vdash &(\Lambda \, T. \lambda \, f \colon T \to T . \lambda \, x \colon T . f (f x))[\nat] s z \colon \nat\\
  &\mapsto_{\beta} (\lambda \, f \colon \nat \to \nat . \lambda \, x \colon \nat . f (f x)) s z \colon \nat\\
  &\mapsto_{\beta^{\star}} s s z \colon \nat.
\end{align*}

When trying to formalise System F, we will face a choice of using an
intrinsically- or extrinsically-typed approach; although these were first
described by Alonzo Church and Haskell Curry respectively, we will use the
former two terms. The different approaches are described in detail in
\citet{gries_what_2003}, but to summarise, an intrinsic approach will define the
types of terms before the terms themselves, whereas an extrinsic approach will
define terms first (without types), and only later justify that the type system
is consistent.

Using the intrinsic approach will require less code and effort, so we shall
proceed that way.

\section{De Bruijn indices and Locally Nameless Sets}

Suppose we had the following expression,

\begin{equation*}
  x \colon \nat \in \Gamma \vdash \lambda \, y \colon \nat \to \nat. y x \colon \nat.
\end{equation*}

This takes in a function $y$ and applies it to the $x$ that is in the context.
Now suppose we move this expression into a context where we already have a bound
$y$.

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \, y \colon \nat \to \nat. y x \colon \nat.
\end{equation*}

It's unclear whether we are referring to the local $y$ or the previously bound
$y$ that is in our context (if we were to use actual functions on the naturals,
then we could have a real problem if the outer $y$ is the squaring function and
the inner $y$ the successor function, for instance). We can use an
$\alpha$-conversion and resolve this issue. We shall apply the conversion $y
\mapsto_{\alpha} q$ to our inner expression,

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \, q \colon \nat \to \nat. q x \colon \nat,
\end{equation*}

which solves our problem. We can add further assumptions to our context without
affecting the semantics of the expression (for example, adding $k \colon \nat$
to $\Gamma$ won't change the semantics of the expression), this is called
weakening-invariance (taken from proof theory, where extra assumptions make a
theorem weaker).

Since we have these $\alpha$-equivalent expressions, we can say that we have
\textit{quotient} inductive definitions \citep{aydemir_engineering_2008}, since
we have both an inductive definition of the $\lambda$-calculus, but also
(infinitely) many $\alpha$-equivalence classes which we need to deal
with\footnote{The name \textit{quotient} is taken from other areas of
mathematics where equivalence classes produce quotient objects. For example, in
ring theory, for a ring $R$ and ideal $I \subseteq R$, the quotient ring $R/I$
is the set of equivalence classes where for all $a, b \in R$ we have the
relation $a \sim b \iff a - b \in I$. If we let $R = \integer$ and $I =
2\integer$, the relation is $a \sim b \iff a - b \in 2\integer \iff \text{they
have the same parity}$. The quotient ring $R/I$ is just the set $\{0, 1\}$. In
our case, the relation is $a \sim b \iff a =_{\alpha} b$, and our quotient
becomes the set of possible terms which are semantically distinct}. This becomes
difficult in Agda, since Agda primarily relies on inductive definitions
\citep{pitts_locally_2023}.

We can solve this by using \textit{De Bruijn indices}. Using these ensures that
no matter what variables we have in our context, we don't have any local
variable names which could cause issues (since we only use indices that directly
reference the scope). In our example,

\begin{equation*}
  x \colon \nat, y \colon \nat \to \nat \in \Gamma \vdash \lambda \nat \to \nat. 0 2 \colon \nat.
\end{equation*}

We can't use any $\alpha$-conversions since each bound variable is indexed by a
(unique) natural number. However, if we were to change the context, we would
need to change the index too. So we have a purely inductive definition. For
example, if we remove the $y$,

\begin{equation*}
  x \colon \nat, \in \Gamma \vdash \lambda \nat \to \nat. 0 1 \colon \nat,
\end{equation*}

then we need to reindex the $2$ to a $1$. We have lost weakening invariance
\citep{aydemir_engineering_2008}.

Using \textit{locally nameless sets}, we can get both purely inductive
definitions \textit{and} weakening-invariance. Free variables will use variable
names while bound variables will use indices. Our example becomes

\begin{align*}
  x \colon \nat, \in \Gamma &\vdash \lambda \nat \to \nat. 0 x \colon \nat,\quad \text{or with another variable in the context,}\\
  x \colon \nat, y \colon \nat \to \nat \in \Gamma &\vdash \lambda \nat \to \nat. 0 x \colon \nat.
\end{align*}

This approach has been of research interest as of late \citep{aydemir_engineering_2008}
\citep{chargueraud_locally_2012}. As part of using locally nameless terms, common operations (called
`infrastructure' by ) need to be defined for the language used as part of the metatheory. A recent
article by explores locally nameless sets in Agda, and proves that this infrastructure can be
defined in a syntax-agnostic way. This will form part of the basis of our approach to implementing
System F in Agda.

\section{Cofinite Quantification}

Often, we may want to prove a property for \textit{almost} all members of a set, where we exclude a
finite subset. For example, for \textit{almost} all natural numbers $n$, $n \geq 2$. Or in number
theory, \textit{almost} all natural numbers can be written as a product of primes. To prove this,
one would need to give a set of numbers which the proof will ignore (in the example, $\{ (0), 1
\}$), and then prove it for all $n \in \nat$ with the extra assumption that $n \not \in \{0, 1\}$.
Practically, this is never done, since we usually want the exceptions explicitly in the proof. But
this special pattern proves useful.

In several papers on the locally nameless representation, \textit{cofinite} quantification is
discussed. This is exactly what we would understand as `for almost all'.

While the Agda implementation that Pitts gave [TODO cite] uses an arbitrary set, I chose to use the
specific \texttt{List Char}, since we will only quantify over strings.

\begin{code}
record Cof (P : List Char → Set) : Set where
  constructor И⟨_,_⟩
  field
    Иe₁ : List (List Char)
    Иe₂ : (a : List Char) {_ : a ∉ Иe₁} → P a
open Cof
syntax Cof (λ a → P) = И a , P
\end{code}

For a simple example, I can show \textit{almost} all strings have a length greater or equal to $1$
(with the exception being the empty string).

\begin{code}
simple-cof : {s : String} → И s , (1 ≤ length s)
simple-cof = И⟨ [] ∷ [] , (
  λ{[] {a∉}  → contradiction refl (∉∷[]⇒≢ a∉)
  ; (x ∷ xs) → s≤s z≤n}) ⟩
\end{code}

\section{Prior research}
System F was previously formalised in Agda by \citet{hutton_system_2019}. However, the authors of that paper formalised a
variant of System F with language extensions known as \textit{System F$_{\omega \mu}$}. They also
used a different approach, opting to make use of De Bruijn indices. This paper will use the locally
nameless representation, which hasn't been used for System F in Agda before.

\subsection{Syntax and basic theorems of STLC}
I have previously submitted some work on STLC using locally nameless representation for a university
course called \textit{Types and Semantics of Programming Languages} [TODO: Cite DRPS]. I will
present my prior work in this subsection. Some functions which were submitted are presented without their
function bodies and are instead included in appendix A [TODO: appendix]. Any new additions are in
the next chapter.

\subsubsection{Creating new strings}
We will use \texttt{List Char} rather than the built-in \texttt{String} type, since it's easier to
reason with lists. The \texttt{String} type is opaque in Agda, and reasoning about length and other
properties of \texttt{String} is more difficult than if we just used \texttt{List Char}. To generate
arbitrary strings, we'll provide functions for \texttt{List A} for some set \texttt{A} and then use
the specific where \texttt{A} is \texttt{Char}. The `toList` function for `String` (which I have
renamed to \texttt{⟪\_⟫}) can be used to convert from a \texttt{String}.

\begin{code}
new-list : ∀ {A : Set} → A → List (List A) → List A
new-list a xss = a ∷ replicate (max 0 (map length xss)) a

fresh : List (List Char) → List Char
fresh xss = new-list 'q' xss
\end{code}

We can create a new string by finding the longest string and creating a string which is one
character longer. Now to prove that this function is correct:

\begin{code}

new-list-correct : ∀ {A : Set} (xss : List (List A)) (a : A)
  → ¬ Any ((new-list a xss) ≡_) xss
-- Function body in appendix.

fresh-correct : (xss : List (List Char)) → (fresh xss) ∉ xss
fresh-correct xss = new-list-correct xss 'q'
\end{code}

\chapter{Conclusions}

\section{Final Reminder}

The body of your dissertation, before the references and any appendices,
\emph{must} finish by page~40. The introduction, after preliminary material,
should have started on page~1.

You may not change the dissertation format (e.g., reduce the font size, change
the margins, or reduce the line spacing from the default single spacing). Be
careful if you copy-paste packages into your document preamble from elsewhere.
Some \LaTeX{} packages, such as \texttt{fullpage} or \texttt{savetrees}, change
the margins of your document. Do not include them!

Over-length or incorrectly-formatted dissertations will not be accepted and you
would have to modify your dissertation and resubmit. You cannot assume we will
check your submission before the final deadline and if it requires resubmission
after the deadline to conform to the page and style requirements you will be
subject to the usual late penalties based on your final submission time.

% \bibliographystyle{plain}
\bibliographystyle{plainnat}
% \bibliography{mybibfile}
\bibliography{dissertation}


% You may delete everything from \appendix up to \end{document} if you don't need it.
\appendix

\chapter{Miscellaneous Proofs}

Since we already declared these functions, it would be an error to declare them again. I decided to
include the type signatures anyway for clarity.

\section{PLFA adaption}

These functions are closely adapted from PLFA [TODO: cite].

\begin{code}
All-++ : ∀ {A : Set} {P : A → Set} (xs ys : List A)
  → All P (xs ++ ys)
    ---------------------
  → (All P xs × All P ys)
All-++ [] ys Pys = ⟨ All.[] , Pys ⟩
All-++ (x ∷ xs) ys (Px All.∷ Pxs++ys) with All-++ xs ys Pxs++ys
... | ⟨ Pxs , Pys ⟩ = ⟨ Px All.∷ Pxs , Pys ⟩

-- All¬⇒¬Any : ∀ {A : Set} {P : A → Set} {xs : List A}
--   → All (¬_ ∘ P) xs
--     ---------------
--   → (¬_ ∘ Any P) xs
All¬⇒¬Any {xs = x ∷ xs} (¬Px All.∷ All¬P) (here Px) = ¬Px Px
All¬⇒¬Any {xs = x ∷ xs} (¬Px All.∷ All¬P) (there Pxs) =
  All¬⇒¬Any {xs = xs} All¬P Pxs

-- ¬Any⇒All¬ : ∀ {A : Set} {P : A → Set} {xs : List A}
--   → (¬_ ∘ Any P) xs
--     ---------------
--   → All (¬_ ∘ P) xs
¬Any⇒All¬ {xs = []} ¬∘AnyP = All.[]
¬Any⇒All¬ {xs = (x ∷ xs)} ¬AnyP =
  (λ Px → ¬AnyP (here Px))
    All.∷ ¬Any⇒All¬ {xs = xs} (λ Pxs → ¬AnyP (there Pxs))

-- We have to use ¬Any⇒All¬ and its inverse because ∉ is an
-- alias for "¬ Any (_≡ x) xs".  So we have to go through
-- the process of converting to "All ¬" to apply the
-- "All-++" lemma.
-- ∉-++ : ∀ {s : List Char} {xs ys : List (List Char)}
--   → s ∉ xs ++ ys
--     --------------------
--   → (s ∉ xs) × (s ∉ ys)
∉-++ {s} {xs} {ys} s∉xs++ys =
  let ⟨ all¬xs , all¬ys ⟩ = All-++ xs ys (¬Any⇒All¬ s∉xs++ys) in
    ⟨ All¬⇒¬Any {xs = xs} all¬xs
    , All¬⇒¬Any {xs = ys} all¬ys ⟩

++-All : ∀ {A : Set} {P : A → Set} (xs ys : List A)
  → All P xs × All P ys
    -------------------
  → All P (xs ++ ys)
++-All [] ys ⟨ All.[] , Pys ⟩ = Pys
++-All (x ∷ xs) ys ⟨ Px All.∷ Pxs , Pys ⟩ =
  Px All.∷ ++-All xs ys ⟨ Pxs , Pys ⟩

-- ++-∉ : ∀ {s : List Char} {xs ys : List (List Char)}
--   → s ∉ xs
--   → s ∉ ys
--     -------------
--   → s ∉ xs ++ ys
++-∉ {_} {xs} {ys} s∉xs s∉ys =
  All¬⇒¬Any (++-All xs ys ⟨ (¬Any⇒All¬ s∉xs) , (¬Any⇒All¬ s∉ys) ⟩)
\end{code}

\section{Prior work submitted for TSPL}

\begin{code}
All≤⇒<⇒All< : ∀ {n m : ℕ} (xs : List ℕ)
  → n < m
  → All (_≤ n) xs
    -------------
  → All (_< m) xs
All≤⇒<⇒All< [] n<m All.[] = All.[]
All≤⇒<⇒All< (x ∷ xs) n<m (x≤n All.∷ all≤) =
  ≤-<-trans x≤n n<m All.∷ All≤⇒<⇒All< xs n<m all≤

-- sym-≢ : ∀ {A : Set} {x y : A}
--   → x ≢ y
--     -----
--   → y ≢ x
sym-≢ x≢y = λ y≡x → (x≢y (sym y≡x))

≡⇒<s : ∀ {n m : ℕ} → n ≡ m → n < suc m
≡⇒<s {zero} {m} n≡m = s≤s z≤n
≡⇒<s {suc n} {suc m} sn≡sm = s≤s (≡⇒<s (suc-injective sn≡sm))

-- ∉⇒≢ : ∀ {xs : List (List Char)} {x y : List Char}
--   → x ∈ xs
--   → y ∉ xs
--     -------
--   → x ≢ y
∉⇒≢ {xs} x∈ y∉ refl = y∉ x∈

len≠⇒≠ : ∀ {A : Set} (xs ys : List A)
  → length xs ≢ length ys → xs ≢ ys
len≠⇒≠ xs ys len≢ =
  λ xs≡ys → contradiction (cong length xs≡ys) len≢

-- ∉∷[]⇒≢ : {x y : List Char}
--   → x ∉ y ∷ []
--     -----------
--   → x ≢ y
∉∷[]⇒≢ x∉ with ¬Any⇒All¬ x∉
... | px All.∷ All.[] = px

len-replicate : ∀ {A : Set} (n : ℕ) (a : A)
  → length (replicate n a) ≡ n
len-replicate zero a = refl
len-replicate (suc n) a = cong suc (len-replicate n a)

len-new-list : ∀ {A : Set} (a : A) (xss : List (List A))
  → max 0 (map length xss) < length (new-list a xss)
len-new-list a xss =
  ≡⇒<s (sym (len-replicate (max 0 (map length xss)) a))

-- new-list-correct :
--   ∀ {A : Set} (xss : List (List A)) (a : A)
--   → ¬ Any ((new-list a xss) ≡_) xss
new-list-correct xss a = All¬⇒¬Any (go xss a)
  where
    go : ∀ {A : Set} (xss : List (List A)) (a : A)
      → All ((new-list a xss) ≢_) xss
    go xs a =
      helper
        xs
        (new-list a xs)
        (All≤⇒<⇒All<
          (map length xs)
          (len-new-list a xs)
          (xs≤max 0 (map length xs)))
      where
        helper : ∀ {A : Set} (xss : List (List A)) (ys : List A)
          → All (_< length ys) (map length xss)
          → All (ys ≢_) xss
        helper [] ys All.[] = All.[]
        helper (xs ∷ xss) ys (lenxs<lenys All.∷ all<) =
          sym-≢ (len≠⇒≠ xs ys (<⇒≢ lenxs<lenys))
            All.∷ helper xss ys all<
\end{code}

\chapter{Participants' information sheet}

If you had human participants, include key information that they were given in
an appendix, and point to it from the ethics declaration.

\chapter{Participants' consent form}

If you had human participants, include information about how consent was
gathered in an appendix, and point to it from the ethics declaration.
This information is often a copy of a consent form.


\end{document}

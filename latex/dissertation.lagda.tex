% UG project example file, February 2024
%
%   Added the "online" option for equal margins, February 2024 [Hiroshi Shimodaira, Iain Murray]
%   A minor change in citation, September 2023 [Hiroshi Shimodaira]
%
% Do not change the first two lines of code, except you may delete "logo," if causing problems.
% Understand any problems and seek approval before assuming it's ok to remove ugcheck.
\documentclass[logo,bsc,singlespacing,parskip,online]{infthesis}
\usepackage{ugcheck}


% Include any packages you need below, but don't include any that change the page
% layout or style of the dissertation. By including the ugcheck package above,
% you should catch most accidental changes of page layout though.

\usepackage{microtype} % recommended, but you can remove if it causes problems
\usepackage[round]{natbib} % recommended for citations

% === Custom packages === %

% Syntax highlighting
\usepackage{minted}
% BNF
\usepackage{simplebnf}
% Inference rules
\usepackage{mathpartir}
% Agda
\usepackage{agda}
\AgdaNoSpaceAroundCode{}
% Hide in output
\usepackage{comment}
% Colour
\usepackage{xcolor}

% Unicode

\usepackage{fontspec}
\usepackage{newunicodechar}
\newfontface{\notosansmono}{NotoSansMono-Regular.ttf}[Path = fonts/]
\newfontface{\ibmplexmath}{IBMPlexMath-Regular.otf}[Path = fonts/]
\newfontface{\hack}{HackNerdFontMono-Regular.ttf}[Path = fonts/]
\newunicodechar{ℕ}{{\notosansmono{ℕ}}}
\newunicodechar{∀}{{\notosansmono{∀}}}
\newunicodechar{≡}{{\notosansmono{≡}}}
\newunicodechar{≥}{{\notosansmono{≥}}}
\newunicodechar{≤}{{\notosansmono{≤}}}
\newunicodechar{≰}{{\notosansmono{≰}}}
\newunicodechar{⊔}{{\notosansmono{⊔}}}
\newunicodechar{≟}{{\notosansmono{≟}}}
\newunicodechar{⇒}{{\hack{⇒}}}
\newunicodechar{≢}{{\notosansmono{≢}}}
\newunicodechar{≮}{{\notosansmono{≮}}}
\newunicodechar{⟪}{{\notosansmono{⟪}}}
\newunicodechar{⟫}{{\notosansmono{⟫}}}
\newunicodechar{⊤}{{\notosansmono{⊤}}}
\newunicodechar{⊥}{{\notosansmono{⊥}}}
\newunicodechar{∣}{{\notosansmono{∣}}}
\newunicodechar{⟨}{{\notosansmono{⟨}}}
\newunicodechar{⟩}{{\notosansmono{⟩}}}
\newunicodechar{∎}{{\notosansmono{∎}}}
\newunicodechar{⌊}{{\notosansmono{⌊}}}
\newunicodechar{⌋}{{\notosansmono{⌋}}}
\newunicodechar{₁}{{\notosansmono{₁}}}
\newunicodechar{₂}{{\notosansmono{₂}}}
\newunicodechar{∃}{{\notosansmono{∃}}}
\newunicodechar{∷}{{\notosansmono{∷}}}
\newunicodechar{∈}{{\notosansmono{∈}}}
\newunicodechar{∉}{{\notosansmono{∉}}}
\newunicodechar{λ}{{\notosansmono{λ}}}
\newunicodechar{И}{{\notosansmono{И}}}
\newunicodechar{∘}{{\notosansmono{∘}}}
\newunicodechar{≠}{{\notosansmono{≠}}}
\newunicodechar{‵}{{\notosansmono{‵}}}
\newunicodechar{ƛ}{{\notosansmono{ƛ}}}
\newunicodechar{≻}{{\ibmplexmath{≻}}}
\newunicodechar{⦃}{{\ibmplexmath{⦃}}}
\newunicodechar{⦄}{{\ibmplexmath{⦄}}}
\newunicodechar{′}{{\notosansmono{′}}}
\newunicodechar{∋}{{\notosansmono{∋}}}
\newunicodechar{⦂}{{\ibmplexmath{⦂}}}
\newunicodechar{∅}{{\hack{∅}}}
\newunicodechar{⊢}{{\hack{⊢}}}
\newunicodechar{ξ}{{\notosansmono{ξ}}}
\newunicodechar{β}{{\notosansmono{β}}}
\newunicodechar{↠}{{\hack{↠}}}
\newunicodechar{ρ}{{\notosansmono{ρ}}}

% Maths:

\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{xurl}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Real}{Re}
\DeclareMathOperator{\Imag}{Im}
\DeclareMathOperator{\complex}{\mathbb{C}}
\DeclareMathOperator{\reals}{\mathbb{R}}
\DeclareMathOperator{\nat}{\mathbb{N}}
\DeclareMathOperator{\integer}{\mathbb{Z}}
\DeclareMathOperator{\rational}{\mathbb{Q}}
\DeclareMathOperator{\Log}{Log}
\DeclareMathOperator{\Arg}{Arg}
\DeclareMathOperator{\cof}{\text{И}}

% Use minted for Agda

\let\oldcode\code
\NewCommandCopy{\mintedcopy}{\minted}
\NewCommandCopy{\endmintedcopy}{\endminted}
% Adapted from https://tex.stackexchange.com/a/488451/202867
\renewenvironment{code}{\mintedcopy[breaklines,breaksymbolleft=\;]{agda}}{\endmintedcopy}

\begin{document}
\begin{preliminary}

\title{System F in Agda via Pitts}

\author{Charlotte Ausel}

% CHOOSE YOUR DEGREE a):
% please leave just one of the following un-commented
% \course{Artificial Intelligence}
%\course{Artificial Intelligence and Computer Science}
%\course{Artificial Intelligence and Mathematics}
%\course{Artificial Intelligence and Software Engineering}
%\course{Cognitive Science}
%\course{Computer Science}
%\course{Computer Science and Management Science}
\course{Computer Science and Mathematics}
%\course{Computer Science and Physics}
%\course{Software Engineering}
%\course{Master of Informatics} % MInf students

% CHOOSE YOUR DEGREE b):
% please leave just one of the following un-commented
%\project{MInf Project (Part 1) Report}  % 4th year MInf students
%\project{MInf Project (Part 2) Report}  % 5th year MInf students
\project{4th Year Project Report}        % all other UG4 students


\date{\today}

\abstract{
This skeleton demonstrates how to use the \texttt{infthesis} style for
undergraduate dissertations in the School of Informatics. It also emphasises the
page limit, and that you must not deviate from the required style.
The file \texttt{skeleton.tex} generates this document and should be used as a
starting point for your thesis. Replace this abstract text with a concise
summary of your report.
}

\maketitle

\newenvironment{ethics}
   {\begin{frontenv}{Research Ethics Approval}{\LARGE}}
   {\end{frontenv}\newpage}

\begin{ethics}
This project was planned in accordance with the Informatics Research
Ethics policy. It did not involve any aspects that required approval
from the Informatics Research Ethics committee.

\standarddeclaration
\end{ethics}


\begin{acknowledgements}
Any acknowledgements go here.
\end{acknowledgements}


\tableofcontents
\end{preliminary}


\chapter{Introduction}

TODO.

This document is a literate Agda file and uses {\color{violet}colour}. Please see appendix
\ref{appendix:compilation_instructions} for details.

\begin{code}
module dissertation where
\end{code}

\chapter{Background}

\section{Agda}
Agda is a dependently-typed functional programming language based on Martin--Löf type theory, which
makes it suitable as a proof-assistant using intuitionistic logic \citep{norell_towards_2007}.

In Agda, most definitions are done inductively, that is, using recursion. For example, following the
Peano axioms for the natural numbers $\nat$ \citep{boolos_freges_1995}, we may define them like so.

\begin{code}
module Example where
  data ℕ : Set where
    zero : ℕ
    suc  : ℕ → ℕ
\end{code}


\paragraph*{Propositions as types.} First noted by William A. Howard in 1969
\citep{howard_formulae-as-types_1980}, there is a direct correspondence between proofs and programs.
\citet{wadler_propositions_2015} calls this correspondence \textit{propositions as types}, known as
the Curry-Howard correspondence by some authors. Thanks to this correspondence, a correct Agda
function with the appropriate type signature matching the claim (proposition) suffices for a proof.
For example, a proof that addition is associative would use recursion, which corresponds to
induction, as shown below.

\begin{code}
  -- We can import from the standard library, here we're using
  -- the reflexive and congruence properties of equality.
  open import Relation.Binary.PropositionalEquality
    using (_≡_; refl; cong)

  _+_ : ℕ → ℕ → ℕ
  zero  + m = m
  suc n + m = suc (n + m)

  +-assoc : ∀ (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
  +-assoc zero    n p = refl
  +-assoc (suc m) n p = cong suc (+-assoc m n p)
\end{code}

Imports from the standard library \citep{the_agda_community_agda_2024} are omitted, but are
available in the full source file (see appendix \ref{appendix:compilation_instructions}).
\begin{comment}
\begin{code}
-- Data types (naturals, strings, characters)
open import Data.Nat using (ℕ; zero; suc; _<_; _≥_; _≤_; _≤?_; _<?_; z≤n; s≤s; _⊔_)
  renaming (_≟_ to _≟ℕ_)
open import Data.Nat.Properties using (≤-refl; ≤-trans; ≤-<-trans; <-≤-trans; ≤-antisym; ≤-total;
  +-mono-≤; n≤1+n; m≤n⇒m≤1+n; suc-injective; <⇒≢; ≰⇒>; ≮⇒≥)
open import Data.String using (String; fromList) renaming (_≟_ to _≟str_; _++_ to _++str_;
  length to str-length; toList to ⟪_⟫)
open import Data.Char using (Char)
open import Data.Char.Properties using () renaming (_≟_ to _≟char_)

-- Function manipulation.
open import Function using (_∘_; flip; it; id; case_returning_of_)

-- Relations and predicates/decidability.
import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; _≢_; refl; sym; trans; cong; cong-app; cong₂)
open Eq.≡-Reasoning using (begin_; step-≡-∣; step-≡-⟩; _∎)
open import Relation.Binary.Definitions using (DecidableEquality)
open import Relation.Nullary.Decidable using (Dec; yes; no; True; False; toWitnessFalse;
  toWitness; fromWitness; ¬?; ⌊_⌋; From-yes)
open import Relation.Unary using (Decidable)
open import Relation.Binary using () renaming (Decidable to BinaryDecidable)
open import Relation.Nullary.Negation using (¬_; contradiction)
open import Data.Empty using (⊥-elim)

-- Products and exists quantifier.
open import Data.Product using (_×_; proj₁; proj₂; ∃-syntax) renaming (_,_ to ⟨_,_⟩)

-- Lists.
open import Data.List using (List; []; _∷_; _++_; length; filter; map; foldr; head; replicate)
open import Data.List.Properties using (≡-dec)
import Data.List.Membership.DecPropositional as DecPropMembership
open import Data.List.Relation.Unary.All using (All; all?; lookup)
  renaming (fromList to All-fromList; toList to All-toList)
open import Data.List.Relation.Unary.Any using (Any; here; there)
open import Data.List.Extrema Data.Nat.Properties.≤-totalOrder using (max; xs≤max)

-- Import list membership using List Char comparisons.
_≟lchar_ : ∀ (xs ys : List Char) → Dec (xs ≡ ys)
xs ≟lchar ys = ≡-dec (_≟char_) xs ys

open DecPropMembership _≟lchar_ using (_∈_; _∉_; _∈?_)
\end{code}
\end{comment}

\section{Cofinite Quantification}

\input{cofinite.lagda}

\section{The Lambda Calculus and System F}
\input{background_lambda_calculus.tex}

\section{Locally Nameless Representation}
\input{background_locally_nameless.tex}

\section{Evaluation strategy}
\label{section:evaluation_strategy}
The idea of reducible expressions, called a \textit{redex}, was introduced by Church
\cite[p.~56]{pierce_types_2002}. We refer to any expression of the form $(\lambda \, x. M) N$ as a
redex, since we can perform a $\beta$-reduction (see equation \ref{equation:untyped_beta_rules}).

There are several ways of evaluating the $\lambda$-calculus. The main question is whether to treat
$\lambda$-abstractions as values, or to reduce these if they are a redex.

When evaluating, we need to consider some terms to be \textit{values}. These cannot be reduced any
further. One method is to consider $\lambda$-abstractions to be values and to only evaluated
\textit{closed} terms, that is, terms without any free variables. This is called weak-head
reduction, and the values are called weak-head normal forms \citep{wadler_programming_2022}. This
method is also used by popular programming languages such as Haskell \citep{hutchison_sharing_2005}.
The definition of $\lambda$-calculus as Church first described it uses what is nowadays referred to
as \textit{full normalisation} \citep{wadler_programming_2022}. The reduction rule which is absent in
weak-head reduction is the $\zeta$ rule (see equation \ref{equation:untyped_beta_rules} on page
\pageref{equation:untyped_beta_rules}), or \textit{reducing under a $\lambda$-abstraction}.

One of the early explorations of weak-head reduction was made by \citet{cagman_combinatory_1998},
comparing it to combinatory logic. They presented the necessity of another reduction rule. Since
evaluation stops at $\lambda$-abstractions, the Church-Rosser property no longer applies (and, in
fact, the system is no longer Turing complete). While one could introduce specific rules when one
can reduce under a $\lambda$-abstraction to restore this property \citep{hutchison_sharing_2005},
another, simpler, method is to introduce primitives \citep{wadler_programming_2022}. These
primitives are a small subset of Scott and Plotkin's Programming Computable Functions (PCF)
\citep{plotkin_lcf_1977}, described in section \ref{section:stlc_terms}.

Weak-head reduction was used by \citet{chargueraud_locally_2012} and
\citet[chapter~Lambda]{wadler_programming_2022}, so we choose to follow the same approach here.

\section{Prior research}
System F was previously formalised in Agda by \citet{hutton_system_2019}. However, the authors of
that paper formalised a variant of System F with language extensions known as \textit{System
F$_{\omega \mu}$}. They also used a different approach, opting to make use of De Bruijn indices.
This paper will use the locally nameless representation, which hasn't been used for System F in Agda
before.

I have previously submitted some work on STLC using locally nameless representation for a course
called \textit{Types and Semantics of Programming Languages} (TSPL). I have presented my prior work in
appendix \ref{appendix:tspl}. There are some new additions to this work which are presented in the
next chapter.

\chapter{Substitution and Evaluation in STLC}
The remaining properties of STLC, including creating an evaluator, were missing from my submission
to TSPL. Since it is a necessary prelude to System F, this new work is presented here. As explained
in section \ref{section:evaluation_strategy}, one evaluation strategy is weak-head reduction. We
follow the methods presented in \citet[chapter~Properties]{wadler_programming_2022} and
\citet[section~5]{chargueraud_locally_2012}, as they have also used weak-head reduction. Thus,
evaluation will be restricted to closed terms only (those without free variables).
\begin{code}
module chapter3 where
  open import plfa_adaptions
  open import tspl_prior_work
  open import cofinite
\end{code}

The syntax that the Agda formalisation uses and the syntax that is commonly used may be different.
For example, usually, we would simply write $\lambda x. x$ for the identity function. But because
$\lambda$ is a reserved keyword in Agda, we need to use a different symbol. Thus, we will use
substitutes, like ƛ for $\lambda$, or $\cdot$ for function application (which is usually left
implicit). For more information, please refer to \citet{wadler_programming_2022}.

\section{Substitution}
We need to show that substituting preserves types. As mentioned, we restrict ourselves to only
closed terms for substitution.
\begin{code}
  {-# TERMINATING #-}
  subst : ∀ {Γ x t u A B}
    → ∅ ⊢ u ⦂ A
    → Γ , x ⦂ A ⊢ t ⦂ B
      --------------------
    → Γ ⊢ [ x := u ] t ⦂ B
  subst {x = y} ⊢u (⊢free {x = x} (H refl)) with y ≟lchar y
  ... | yes _   = weaken ⊢u
  ... | no  y≢y = contradiction refl y≢y
  subst {x = y} ⊢u (⊢free {x = x} (T x≢y ∋x)) with y ≟lchar x
  ... | yes y≡x = contradiction (sym y≡x) x≢y
  ... | no  _   = ⊢free ∋x
  subst {x = x} {t = ƛ t} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
    ⊢ƛ И⟨ x ∷ Иe₁
        , (λ a {a∉} →
          let a≢y   = ∉∷[]⇒≢ (proj₁ (∉-++ a∉))
              a∉Иe₁ = proj₂ (∉-++ a∉)
          in subst-open-context
            {t = t}
            (sym-≢ a≢y)
            (⊢⇒lc ⊢u)
            (subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))) )
        ⟩
  subst ⊢u (⊢· ⊢t₁ ⊢t₂) = ⊢· (subst ⊢u ⊢t₁) (subst ⊢u ⊢t₂)
  subst ⊢u ⊢zero = ⊢zero
  subst ⊢u (⊢suc ⊢t) = ⊢suc (subst ⊢u ⊢t)
\end{code}

The property is proven by induction on the type judgement of the term \texttt{M}. Agda cannot
determine the termination of this function, and the problematic call is when the type judgement is a
$\lambda$-abstraction \texttt{ƛ M}. Specifically, it highlights the problematic code to be
\texttt{subst ⊢u (swap a≢y (Иe₂ a {a∉Иe₁}))}. Thus, I will only detail that
step\footnote{Technically, the Agda compiler also highlits a problematic call for the application
case, but this is caused by the problematic $\lambda$-abstraction case, so is irrelevant.}.

Since we are inducting on the type judgement, the inductive hypothesis for a term \texttt{ƛ M} of
type \texttt{A ⇒ A'} states that the property $P$ holds for $P(\texttt{И⟨ Иe₁ , Иe₂ ⟩})$. Let
\texttt{b} be an appropriate \texttt{List Char} to supply to \texttt{Иe₂}, then it will return a
proof that \texttt{Γ , x ⦂ A , b ⦂ A' ⊢ [ 0 —→ b ] t ⦂ B}. In this case, the \texttt{subst} function
is called on \texttt{Иe₂} (with a \texttt{swap} function applied, but since this function doesn't
call \texttt{subst} and only operates on the context, this call is irrelevant to this termination
issue). Since we are deconstructing the type judgement and are calling \texttt{subst} on the term
\texttt{Иe₂} which makes up the input type judgement, this function call corresponds to the
inductive hypothesis, and is thus valid.

Substituting a term for an index is similar to the definition of the free-variable substitution
(defined in appendix \ref{appendix:substitution_proofs}). This is, confusingly, also called
`opening' by \citet{chargueraud_locally_2012}.
\begin{code}
  [_:→_]_ : ℕ → Term → Term → Term
  [ k :→ u ] (free x) = free x
  [ k :→ u ] (bound i) with k ≟ℕ i
  ... | yes _ = u
  ... | no  _ = bound i
  [ k :→ u ] (ƛ t) = ƛ [ (suc k) :→ u ] t
  [ k :→ u ] (t₁ · t₂) = [ k :→ u ] t₁ · [ k :→ u ] t₂
  [ k :→ u ] ‵zero = ‵zero
  [ k :→ u ] (‵suc t) = ‵suc ([ k :→ u ] t)
\end{code}

Using an index $i$ to open with $x \in \texttt{List Char}$ is the same as using the index
substitution with the term \texttt{free $x$}.
\begin{code}
  —→≡:→free : ∀ {i : ℕ} {x : List Char} (t : Term)
    → [ i —→ x ] t ≡ [ i :→ free x ] t
  —→≡:→free {i} {x} (free y) = refl
  —→≡:→free {i} {x} (bound k) with i ≟ℕ k
  ... | yes _ = refl
  ... | no  _ = refl
  —→≡:→free {i} {x} (ƛ t) = cong ƛ_ (—→≡:→free t)
  —→≡:→free {i} {x} (t₁ · t₂) =
    cong₂ _·_ (—→≡:→free t₁) (—→≡:→free t₂)
  —→≡:→free {i} {x} ‵zero = refl
  —→≡:→free {i} {x} (‵suc t) = cong ‵suc_ (—→≡:→free t)
\end{code}

There are quite a few more properties of index substitution which \citet{chargueraud_locally_2012}
proves, but the only relevant one for evaluation is \texttt{subst-intro}. It proves that
substituting a term for an index is the same as first opening the term with an $x \in \texttt{List
Char}$ and then using the free variable substitution using this $x$.
\begin{code}
  subst-intro : ∀ {x : List Char} {i : ℕ} (t u : Term)
    → x # t
    → [ i :→ u ] t ≡ [ x := u ] ([ i —→ x ] t)
  subst-intro {x} (free y) u x#t with x ≟lchar y
  ... | yes refl with () ← x#t
  ... | no  x≢y  = refl
  subst-intro {x} {i} (bound j) u x#t with i ≟ℕ j
  ... | no  i≢j  = refl
  ... | yes refl with x ≟lchar x
  ...   | yes refl = refl
  ...   | no  x≢x  = contradiction refl x≢x
  subst-intro (ƛ t) u x#ƛt = cong ƛ_ (subst-intro t u (#-ƛ t x#ƛt))
  subst-intro {x} (t₁ · t₂) u x#t =
    let ⟨ x#t₁ , x#t₂ ⟩ = #-· t₁ t₂ x#t in
      cong₂ _·_ (subst-intro t₁ u x#t₁) (subst-intro t₂ u x#t₂)
  subst-intro ‵zero u x#t = refl
  subst-intro (‵suc t) u x#st =
    cong ‵suc_ (subst-intro t u (#-‵suc t x#st))
\end{code}

Since we need to replace bound variables for free ones to perform a $\beta$-reduction, we should
prove that this substitution preserves types.
\begin{code}
  subst-op : ∀ {Γ t u A B}
    → ∅ ⊢ u ⦂ A
    → Γ ⊢ ƛ t ⦂ A ⇒ B
      --------------------
    → Γ ⊢ [ 0 :→ u ] t ⦂ B
  subst-op {t = t} {u = u} ⊢u (⊢ƛ И⟨ Иe₁ , Иe₂ ⟩) =
    let x                  = fresh (fv t ++ Иe₁)
        ⟨ x∉fv-t , x∉Иe₁ ⟩ = ∉-++ {xs = fv t} {ys = Иe₁}
                                (fresh-correct (fv t ++ Иe₁))
    in ≡-with-⊢ (subst ⊢u (Иe₂ x {x∉Иe₁}))
      (sym (subst-intro t u (∉fv⇒# x t (x∉fv-t))))
\end{code}

\section{Evaluation}
Using weak-head reduction, only $\lambda$-abstractions are values, together with the two primitives
that were introduced.
\begin{code}
  data Value : Term → Set where
    V-ƛ : ∀ {t} → Value (ƛ t)
    V-zero : Value ‵zero
    V-suc : ∀ {t} → Value t → Value (‵suc t)
\end{code}

\citet{chargueraud_locally_2012} adds another requirement for $\lambda$-abstractions: $1 \succ M$,
or in other words, that $\lambda M$ is locally closed. However, since we are only evaluating
well-typed terms, and all well-typed terms are locally closed (see section
\ref{appendix:type_judgements}), this requirement isn't necessary here.

We follow the rules for small-step reduction given in \citet{chargueraud_locally_2012}. These are
encoded in Agda below.
\begin{code}
  infix 4 _—→_
  data _—→_ : Term → Term → Set where
    ξ₁ : ∀ {t₁ t₁' t₂}
      → t₁ —→ t₁'
      → LocallyClosed t₂
        -------------------
      → t₁ · t₂ —→ t₁' · t₂

    ξ₂ : ∀ {t₁ t₂ t₂'}
      → t₂ —→ t₂'
        ---------
      → t₁ · t₂ —→ t₁ · t₂'

    ξ-suc : ∀ {t t'}
      → t —→ t'
        ------------------
      → ‵suc t —→ ‵suc t'

    β : ∀ {t u}
      → 1 ≻ t
      → Value u
        -------
      → (ƛ t) · u —→ [ 0 :→ u ] t
\end{code}
Once again, the requirements for local closure could be removed, but they are kept here to follow
the rules presented in \citet{chargueraud_locally_2012}.

Following \citet{wadler_programming_2022}, we define some convenience functions, namely, reflexive
and transitive closure properties which will help reason about taking a reduction step. These follow
similar syntax to how equality reasoning is written in the Agda standard library
\citep{the_agda_community_agda_2024}.
\begin{comment}
\begin{code}
  infix  2 _—↠_
  infix  1 begin'_
  infixr 2 _—→⟨_⟩_
  infix  3 _∎'
\end{code}
\end{comment}
\begin{code}
  data _—↠_ : Term → Term → Set where
    _∎' : ∀ M
        ---------
      → M —↠ M

    step—→ : ∀ L {M N}
      → M —↠ N
      → L —→ M
        ---------
      → L —↠ N

  pattern _—→⟨_⟩_ L L—→M M—↠N = step—→ L M—↠N L—→M

  begin'_ : ∀ {M N}
    → M —↠ N
      ------
    → M —↠ N
  begin' M—↠N = M—↠N
\end{code}

There are two important properties which are required to implement evaluation. Progress (that terms
can always take a step, or are a value and are thus finished reducing) is presented below.
\begin{code}
  data Progress (t : Term) : Set where
    step : ∀ {t'}
      → t —→ t'
        ----------
      → Progress t

    done :
        Value t
        ----------
      → Progress t

  progress : ∀ {t A}
    → ∅ ⊢ t ⦂ A
      ----------
    → Progress t
  progress (⊢ƛ x) = done V-ƛ
  progress (⊢· ⊢t₁ ⊢t₂) with progress ⊢t₁
  ... | step t₁→t₁' = step (ξ₁ t₁→t₁' (⊢⇒lc ⊢t₂))
  ... | done V-ƛ with progress ⊢t₂
  ...   | step t₂→t₂' = step (ξ₂ t₂→t₂')
  ...   | done val    = step (β (i≻ƛt⇒si≻t (⊢⇒lc ⊢t₁)) val)
  progress ⊢zero = done V-zero
  progress (⊢suc ⊢t) with progress ⊢t
  ... | step t→t' = step (ξ-suc t→t')
  ... | done val  = done (V-suc val)
\end{code}

And preservation, that types are preserved when reducing.
\begin{code}
  preserve : ∀ {t t' A}
    → ∅ ⊢ t ⦂ A
    → t —→ t'
      ----------
    → ∅ ⊢ t' ⦂ A
  preserve (⊢· ⊢t₁ ⊢t₂) (ξ₁ t→t' _) = ⊢· (preserve ⊢t₁ t→t') ⊢t₂
  preserve (⊢· ⊢t₁ ⊢t₂) (ξ₂ t→t') = ⊢· ⊢t₁  (preserve ⊢t₂ t→t')
  preserve (⊢· ⊢t₁ ⊢t₂) (β x x₁) = subst-op ⊢t₂ ⊢t₁
  preserve (⊢suc ⊢t) (ξ-suc t→t') = ⊢suc (preserve ⊢t t→t')
\end{code}

Since STLC is not Turing complete \citep{church_formulation_1940}, we don't need to worry about
programs which don't terminate. Still, the evaluation function needs to receive a timeout argument,
as it would otherwise not be guaranteed that it would terminate. Thus, we define a record which
limits evaluation to a certain number of reduction steps. Then we can use the preserve and progress
properties to make an \texttt{eval} function. This is the same definition as
\citet{wadler_programming_2022} uses, so the explanation is ommitted here.
\begin{code}
  record Gas : Set where
    eta-equality
    constructor gas
    field
      amount : ℕ

  data Finished (t : Term) : Set where
    done : Value t → Finished t
    out-of-gas : Finished t

  data Steps (t : Term) : Set where
    steps : ∀ {t'} → t —↠ t' → Finished t' → Steps t

  eval : ∀ {t A} → Gas → ∅ ⊢ t ⦂ A → Steps t
  eval {t} (gas zero) ⊢t = steps (t ∎') out-of-gas
  eval {t} (gas (suc n)) ⊢t with progress ⊢t
  ... | done V-t = steps (t ∎') (done V-t)
  ... | step {t'} t→t' with eval (gas n) (preserve ⊢t t→t')
  ...   | steps t'→u fin-u = steps (t —→⟨ t→t' ⟩ t'→u) fin-u
\end{code}

We provide an example for evaluation. First, we require a type derivation for $2+2$. We would show
that it evaluates to $4$, but because the evaluation proof requires more than eleven thousand lines
of code, it is omitted. But we encourage the reader to try it out for themselves. The proofs of
\texttt{⊢two} and \texttt{⊢plus} are long and are omitted (but present in the source file).
\begin{code}
  two : Term
  two = ƛ ƛ bound 1 · (bound 1 · bound 0)

  plus : Term
  plus = ƛ ƛ ƛ ƛ bound 3 · bound 1 · (bound 2 · bound 1 · bound 0)

  suc' : Term
  suc' = ƛ ‵suc (bound 0)

  ⊢two : ∅ ⊢ two ⦂ (‵ℕ ⇒ ‵ℕ) ⇒ ‵ℕ ⇒ ‵ℕ
  -- omitted.

  ⊢plus : ∀ {Γ A} → Γ ⊢ plus ⦂
    ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A) ⇒ ((A ⇒ A) ⇒ A ⇒ A)
  -- omitted

  ⊢suc' : ∀ {Γ} → Γ ⊢ suc' ⦂ ‵ℕ ⇒ ‵ℕ
  ⊢suc' = ⊢ƛ И⟨ [] , (λ _ → ⊢suc (⊢free H′)) ⟩

  ⊢2+2 : ∅ ⊢ plus · two · two · suc' · ‵zero ⦂ ‵ℕ
  ⊢2+2 = ⊢· (⊢· (⊢· (⊢· ⊢plus  ⊢two) ⊢two) ⊢suc') ⊢zero

  -- Using Emacs, normalise "eval (gas 100) ⊢2+2" by pressing
  -- C-c C-n.
\end{code}
\begin{comment}
\begin{code}
  ⊢two = ⊢ƛ
    И⟨ []
    , (λ a → ⊢ƛ
      И⟨ (a ∷ [])
      , (λ b {b∉} →
        ⊢·
        (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′))
        (⊢· (⊢free (T (sym-≢ (∉∷[]⇒≢ b∉)) H′)) (⊢free (H′)))) ⟩) ⟩

  ⊢plus = ⊢ƛ
    И⟨ []
    , (λ a → ⊢ƛ
      И⟨ a ∷ []
      , (λ b {b∉} → ⊢ƛ
        И⟨ a ∷ b ∷ []
        , (λ c {c∉} → ⊢ƛ
          И⟨ a ∷ b ∷ c ∷ []
          , (λ d {d∉} →
          ⊢·
            (⊢·
              (⊢free (T (a≢d d∉) (T (a≢c c∉) (T (a≢b b∉) H′))))
              (⊢free (T (c≢d d∉) (H′))))
            (⊢·
              (⊢·
                (⊢free (T (b≢d d∉) (T (b≢c c∉) H′)))
                (⊢free (T (c≢d d∉) H′)))
              (⊢free H′))) ⟩) ⟩) ⟩) ⟩
    where
      a≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → a ≢ d
      a≢d d∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ d∉)))
      a≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → a ≢ c
      a≢c c∉ = sym-≢ (∉∷[]⇒≢ (proj₁ (∉-++ c∉)))
      a≢b : ∀ {a b} → b ∉ a ∷ [] → a ≢ b
      a≢b b∉ = sym-≢ (∉∷[]⇒≢ b∉)
      c≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → c ≢ d
      c≢d {a} {b} d∉ =
        sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ b ∷ []} d∉)))
      b≢d : ∀ {a b c d} → d ∉ a ∷ b ∷ c ∷ [] → b ≢ d
      b≢d {a} {b} d∉ =
        sym-≢ (∉∷[]⇒≢ (proj₂ (
          ∉-++
            {xs = a ∷ []}
            (proj₁ (∉-++ {xs = a ∷ b ∷ []} d∉)))))
      b≢c : ∀ {a b c} → c ∉ a ∷ b ∷ [] → b ≢ c
      b≢c {a} c∉ = sym-≢ (∉∷[]⇒≢ (proj₂ (∉-++ {xs = a ∷ []} c∉)))
\end{code}
\end{comment}

\chapter{System F}
Combining System F with the locally nameless representation was previously described by \citet{chargueraud_locally_2012}.
\begin{code}
module chapter4 where
  open import cofinite
  open import tspl_prior_work
    using (suc-preserves-≢; sym-≢; fresh; fresh-correct)
\end{code}

\section{Syntax of types and terms}
In System F, types become part of the syntax, as they no become part of how terms are built.
\begin{code}
  data Type : Set where
    t-free_  : List Char → Type   -- Free type variables.
    t-bound_ : ℕ → Type           -- Bound type variables.
    _t-⇒_    : Type → Type → Type -- Arrow types.
    t-∀      : Type → Type → Type -- "For all" type.

  data Term : Set where
    free_  : List Char → Term
    bound_ : ℕ → Term
    -- λ terms now have a type bound. E.g. λ: K. M
    ƛ_,_   : Type → Term → Term
    _·_    : Term → Term → Term
    ‵zero  : Term
    ‵suc_  : Term → Term

  _ : suc zero ≡ suc zero
  _ = refl
\end{code}

\section{Opening}
In System F, we only require the opening operation \citep{chargueraud_locally_2012}. There are three
kinds of opening:
\begin{itemize}
  \item opening a kind at an index by replacing the bound type variable at that index with a free
        type variable,
  \item opening a term at an index by replacing the bound type variable at that index in the term
        with a free type variable, and
  \item opening a term at an index by replacing the bound variable at that index with a free
        variable.
\end{itemize}

\begin{code}
  ty-ty[_—→_]_ : ℕ → List Char → Type → Type
  ty-ty[ i —→ x ] (t-free y) = t-free y
  ty-ty[ i —→ x ] (t-bound n) with i ≟ℕ n
  ... | yes _ = t-free x
  ... | no  _ = t-bound n
  ty-ty[ i —→ x ] (A t-⇒ B) = (ty-ty[ i —→ x ] A) t-⇒ (ty-ty[ i —→ x ] B)
  ty-ty[ i —→ x ] t-∀ A B = t-∀ (ty-ty[ i —→ x ] A) (ty-ty[ suc i —→ x ] B)

  ty-tm[_—→_]_ : ℕ → List Char → Term → Term
  ty-tm[ i —→ x ] (free y) = free y
  ty-tm[ i —→ x ] (bound n) = bound n
  ty-tm[ i —→ x ] (ƛ A , L) = ƛ (ty-ty[ i —→ x ] A) , (ty-tm[ i —→ x ] L)
  ty-tm[ i —→ x ] (L · M) = (ty-tm[ i —→ x ] L) · (ty-tm[ i —→ x ] M)
  ty-tm[ i —→ x ] ‵zero = ‵zero
  ty-tm[ i —→ x ] (‵suc L) = ‵suc ty-tm[ i —→ x ] L

  tm-tm[_—→_]_ : ℕ → List Char → Term → Term
  tm-tm[ i —→ x ] (free y) = free y
  tm-tm[ i —→ x ] (bound n) with i ≟ℕ n
  ... | yes _ = free x
  ... | no  _ = bound n
  tm-tm[ i —→ x ] (ƛ K , L) = ƛ K , tm-tm[ (suc i) —→ x ] L
  tm-tm[ i —→ x ] (L · M) = (tm-tm[ i —→ x ] L) · (tm-tm[ i —→ x ] M)
  tm-tm[ i —→ x ] ‵zero = ‵zero
  tm-tm[ i —→ x ] (‵suc L) = ‵suc tm-tm[ i —→ x ] L
\end{code}

\begin{comment}
However, I may use a different approach at some point and need to use closing. Just in case, I'll
define it here.
\begin{code}
  ty-ty[_←—_]_ : ℕ → List Char → Type → Type
  ty-ty[ i ←— x ] (t-free y) with x ≟lchar y
  ... | yes _ = t-bound i
  ... | no  _ = t-free y
  ty-ty[ i ←— x ] (t-bound n) = t-bound n
  ty-ty[ i ←— x ] (A t-⇒ B) = (ty-ty[ i ←— x ] A) t-⇒ (ty-ty[ i ←— x ] B)
  ty-ty[ i ←— x ] t-∀ A B = t-∀ (ty-ty[ i ←— x ] A) (ty-ty[ suc i ←— x ] B)

  ty-tm[_←—_]_ : ℕ → List Char → Term → Term
  ty-tm[ i ←— x ] (free y) = free y
  ty-tm[ i ←— x ] (bound n) = bound n
  ty-tm[ i ←— x ] (ƛ A , L) = ƛ (ty-ty[ i ←— x ] A) , (ty-tm[ i ←— x ] L)
  ty-tm[ i ←— x ] (L · M) = (ty-tm[ i ←— x ] L) · (ty-tm[ i ←— x ] M)
  ty-tm[ i ←— x ] ‵zero = ‵zero
  ty-tm[ i ←— x ] (‵suc L) = ‵suc ty-tm[ i ←— x ] L

  tm-tm[_←—_]_ : ℕ → List Char → Term → Term
  tm-tm[ i ←— x ] (free y) with x ≟lchar y
  ... | yes _ = bound i
  ... | no  _ = free y
  tm-tm[ i ←— x ] (bound n) = bound n
  tm-tm[ i ←— x ] (ƛ A , L) = ƛ A , tm-tm[ (suc i) ←— x ] L
  tm-tm[ i ←— x ] (L · M) = (tm-tm[ i ←— x ] L) · (tm-tm[ i ←— x ] M)
  tm-tm[ i ←— x ] ‵zero = ‵zero
  tm-tm[ i ←— x ] (‵suc L) = ‵suc tm-tm[ i ←— x ] L
\end{code}
\end{comment}

\section{Local closure}

Like before, a term or kind locally closed at level $i$ if it remains unchanged after opening it at
$i$, see equation \ref{equation:local_closure}.

\begin{comment}
\begin{code}
  _≻k_ : ℕ → Type → Set
  i ≻k A = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , (ty-ty[ j —→ a ] A ≡ A)

  _≻t_ : ℕ → Term → Set
  i ≻t L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , (tm-tm[ j —→ a ] L ≡ L)

  K-LocallyClosed : Type → Set
  K-LocallyClosed A = 0 ≻k A

  T-LocallyClosed : Term → Set
  T-LocallyClosed T = 0 ≻t T
\end{code}
\end{comment}

To make future proofs simpler, we will make use of Agda's instances, which are similar to
typeclasses in Haskell or traits in Rust or Scala. We will follow how \citet{pitts_locally_2023}
defined locally nameless sets, but require fewer of the locally nameless set axioms to be fulfilled
(as we'll only need axioms 1 and 5).

Thanks to using instances, we can prove the local closure properties for both kinds of local
closure.
\begin{code}
  record Lns (A : Set) : Set where
    infix 5 [_—→_]_
    field
      -- We only need opening.
      [_—→_]_ : ℕ → List Char → A → A
      ax1 : ∀ (i : ℕ) (a b : List Char) (L : A)
        → [ i —→ a ] ([ i —→ b ] L) ≡ [ i —→ b ] L
      ax5 : ∀ (i j : ℕ) (a b : List Char) (L : A)
        → (i≢j : i ≢ j)
        → [ i —→ a ] ([ j —→ b ] L) ≡ [ j —→ b ] ([ i —→ a ] L)
    -- Local closure definition.
    _≻_ : ℕ → A → Set
    i ≻ L = (j : ℕ) ⦃ _ : j ≥ i ⦄ → И a , ([ j —→ a ] L ≡ L)
    LocallyClosed : A → Set
    LocallyClosed L = 0 ≻ L
    -- Local closure lemmas.
    lemma2·6 : ∀ {i j : ℕ} {L : A}
      → j ≥ i   → i ≻ L
        ---------------
      → j ≻ L
    lemma2·6 j≥i i≻L k = i≻L k ⦃ ≤-trans j≥i it ⦄

    lemma2·7-1 : ∀ {i : ℕ} {x y : List Char} {L : A}
      → [ i —→ x ] L ≡ L
        ----------------
      → [ i —→ y ] L ≡ L
    lemma2·7-1 {i} {x} {y} {L} assump =
      begin
        [ i —→ y ] L
      ≡⟨ sym (cong ([ i —→ y ]_) assump) ⟩
        [ i —→ y ] ([ i —→ x ] L)
      ≡⟨ ax1 i y x L ⟩
        [ i —→ x ] L
      ≡⟨ assump ⟩
        L
      ∎
      
    lemma2·7-2 : ∀ {i j : ℕ} {x : List Char} {L : A}
      → j ≥ i → i ≻ L
        ----------------
      → [ j —→ x ] L ≡ L
    lemma2·7-2 {j = j} j≥i i≻L =
      let И⟨ Иe₁ , Иe₂ ⟩ = i≻L j ⦃ j≥i ⦄ in
        lemma2·7-1 (Иe₂ (fresh Иe₁) {fresh-correct Иe₁})

    lemma2·13 : ∀ {L : A} {x : List Char} {i : ℕ} (j : ℕ)
      → j ≥ i      → i ≻ L
        ------------------
      → i ≻ ([ j —→ x ] L)
    lemma2·13 {L} {x} j j≥i i≻L k
      with j ≟ℕ k | Иe₁ (i≻L j ⦃ j≥i ⦄)
    ... | yes refl | l = И⟨ l , (λ a → ax1 j a x L) ⟩
    ... | no  j≢k  | l = И⟨ l , (λ a → 
      begin
        [ k —→ a ] ([ j —→ x ] L)
      ≡⟨ ax5 k j a x L (sym-≢ j≢k) ⟩
        [ j —→ x ] ([ k —→ a ] L)
      ≡⟨ cong [ j —→ x ]_ (lemma2·7-2 it i≻L) ⟩
        [ j —→ x ] L
      ∎) ⟩

  open Lns
\end{code}

Now we simply prove axioms 1 and 5 for both kinds of opening, and we get the lemmas above for both.
\begin{code}
  ax1-type : ∀ (i : ℕ) (a b : List Char) (A : Type)
    → ty-ty[ i —→ a ] (ty-ty[ i —→ b ] A) ≡ ty-ty[ i —→ b ] A
  ax1-type i a b (t-free x) = refl
  ax1-type i a b (t-bound k) with i ≟ℕ k
  ... | yes _   = refl
  ... | no  i≢k with i ≟ℕ k
  ... | yes refl = contradiction refl i≢k
  ... | no  _    = refl
  ax1-type i a b (A t-⇒ B)
    rewrite ax1-type i a b A | ax1-type i a b B = refl
  ax1-type i a b (t-∀ A B)
    rewrite ax1-type i a b A | ax1-type (suc i) a b B = refl

  ax5-type : ∀ (i j : ℕ) (a b : List Char) (A : Type)
    → (i≢j : i ≢ j)
    → ty-ty[ i —→ a ] (ty-ty[ j —→ b ] A)
      ≡ ty-ty[ j —→ b ] (ty-ty[ i —→ a ] A)
  ax5-type i j a b (t-free x) i≢j = refl
  ax5-type i j a b (t-bound k) i≢j with j ≟ℕ k
  ... | yes refl with i ≟ℕ k
  ... |   yes refl = contradiction refl i≢j
  ... |   no  i≢k  with j ≟ℕ j
  ... |     yes refl = refl
  ... |     no  j≢j  = contradiction refl j≢j
  ax5-type i j a b (t-bound k) i≢j | no j≢k with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k  with j ≟ℕ k
  ... |   yes refl = contradiction refl j≢k
  ... |   no  _    = refl
  ax5-type i j a b (A t-⇒ B) i≢j
    rewrite ax5-type i j a b A i≢j | ax5-type i j a b B i≢j = refl
  ax5-type i j a b (t-∀ A B) i≢j
    rewrite ax5-type i j a b A i≢j
      | ax5-type (suc i) (suc j) a b B (suc-preserves-≢ i≢j)
          = refl
  
  instance
    LnsType : Lns Type
    LnsType = record
      { [_—→_]_ = ty-ty[_—→_]_
      ; ax1 = ax1-type
      ; ax5 = ax5-type }
\end{code}

The proof for \texttt{Term} is very similar and omitted here (see the source file for the full proof).
\begin{code}
  ax1-term : ∀ (i : ℕ) (a b : List Char) (L : Term)
    → tm-tm[ i —→ a ] (tm-tm[ i —→ b ] L) ≡ tm-tm[ i —→ b ] L
  -- omitted.
  ax5-term : ∀ (i j : ℕ) (a b : List Char) (L : Term)
    → (i≢j : i ≢ j)
    → tm-tm[ i —→ a ] (tm-tm[ j —→ b ] L)
        ≡ tm-tm[ j —→ b ] (tm-tm[ i —→ a ] L)
  -- omitted.

  instance
    LnsTerm : Lns Term
    LnsTerm = record
      { [_—→_]_ = tm-tm[_—→_]_
      ; ax1 = ax1-term
      ; ax5 = ax5-term }
\end{code}

\begin{comment}
\begin{code}
  ax1-term i a b (free x) = refl
  ax1-term i a b (bound k) with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k  with i ≟ℕ k
  ... |   yes refl = contradiction refl i≢k
  ... |   no  _    = refl
  ax1-term i a b (ƛ A , L) rewrite ax1-term (suc i) a b L = refl
  ax1-term i a b (L · M)
    rewrite ax1-term i a b L | ax1-term i a b M = refl
  ax1-term i a b ‵zero = refl
  ax1-term i a b (‵suc L) rewrite ax1-term i a b L = refl

  ax5-term i j a b (free x) i≢j = refl
  ax5-term i j a b (bound k) i≢j with j ≟ℕ k
  ... | yes refl with i ≟ℕ j
  ... |   yes refl = contradiction refl i≢j
  ... |   no  i≢j with j ≟ℕ j
  ... |     yes refl = refl
  ... |     no  j≢j  = contradiction refl j≢j
  ax5-term i j a b (bound k) i≢j | no j≢k with i ≟ℕ k
  ... | yes refl = refl
  ... | no  i≢k with j ≟ℕ k
  ... |   yes refl = contradiction refl j≢k
  ... |   no  j≢k  = refl
  ax5-term i j a b (ƛ A , L) i≢j
    rewrite ax5-term (suc i) (suc j) a b L (suc-preserves-≢ i≢j)
      = refl
  ax5-term i j a b (L · M) i≢j
    rewrite ax5-term i j a b L i≢j | ax5-term i j a b M i≢j = refl
  ax5-term i j a b ‵zero i≢j = refl
  ax5-term i j a b (‵suc L) i≢j rewrite ax5-term i j a b L i≢j
    = refl
\end{code}
\end{comment}

\chapter{Conclusions}

\section{Final Reminder}

The body of your dissertation, before the references and any appendices,
\emph{must} finish by page~40. The introduction, after preliminary material,
should have started on page~1.

You may not change the dissertation format (e.g., reduce the font size, change
the margins, or reduce the line spacing from the default single spacing). Be
careful if you copy-paste packages into your document preamble from elsewhere.
Some \LaTeX{} packages, such as \texttt{fullpage} or \texttt{savetrees}, change
the margins of your document. Do not include them!

Over-length or incorrectly-formatted dissertations will not be accepted and you
would have to modify your dissertation and resubmit. You cannot assume we will
check your submission before the final deadline and if it requires resubmission
after the deadline to conform to the page and style requirements you will be
subject to the usual late penalties based on your final submission time.

\bibliographystyle{plainnat}
\bibliography{dissertation}


% You may delete everything from \appendix up to \end{document} if you don't need it.
\appendix

\chapter{Miscellaneous Proofs}
\label{appendix:misc_proofs}

Since some of these functions were already declared above, it would be an error to declare them
again. I decided to include the type signatures anyway for clarity.

\section{PLFA adaption}
\input{plfa_adaptions.lagda}

\chapter{Prior work submitted for TSPL}
\label{appendix:tspl}
\input{tspl_prior_work.lagda}

\chapter{Compilation instructions}
\label{appendix:compilation_instructions}

This document is a literate Agda file. It has been tested to work with
\begin{itemize}
  \item Agda 2.7.0,
  \item the Agda Standard Library 2.1 \citep{the_agda_community_agda_2024},
  \item XeLaTeX 3.141592653-2.6-0.999996 (TeX Live 2024/Arch Linux 2024.2-4).
\end{itemize}

The full source code is available at [TO BE MADE PUBLIC LATER].

Since this document uses the Minted package [TODO: cite], XeLaTeX needs to be run with the
\texttt{--shell-escape} option. While Agda does provide its own typesetting of Agda code, it uses a
sans-serif typeface. I decided to use the Minted package to provide a monospace typeface for the
code blocks.

To typecheck the document, run Agda with the \texttt{--latex} option. If successful, it will give no
output and return an exit code \texttt{0}.

\end{document}
